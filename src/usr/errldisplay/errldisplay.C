/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/errldisplay/errldisplay.C $                           */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2013,2014                        */
/* [+] Google Inc.                                                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
/**
 *  @file /src/usr/errl/display/errldisplay.C
 *
 *  @brief Implementation of ErrlDisplay class
 *         This will display human-readable dumps of error log entries.
 *
 *  The strings displayed are automatically extracted from source code by
 *  the script ../errl/parser/genErrlParsers.pl
 *
 *  The base image is limited to 512K, and inclusion of the error strings
 *  in the base make it grow beyond that limit, so the text and display
 *  functions are put into the extended image.
 *
 *  The errl module in the base image will provide an interface for the
 *  display functions to register with it.
 *  When an errl is generated, the base image will see if a display function
 *  has been registered.  If so, then it will be called to display the error.
 *  If not, then the base image will display the raw error data and save the
 *  error information into a list.
 *  When the display function does register itself, the errl module in the
 *  base image will pretty-print all of the pending errors from the list
 *  it generated before that point.
 */

/*****************************************************************************/
// I n c l u d e s
/*****************************************************************************/
#include <trace/interface.H>
#include <errl/errlmanager.H>
#include <errl/errlentry.H>
#include <errldisplay/errldisplay.H>
#include <stdlib.h>
#include <string.h>
#include <initservice/taskargs.H>
#include <algorithm>
#include <console/consoleif.H>

namespace ERRORLOGDISPLAY
{

// Trace definition
trace_desc_t* g_trac_errldisp = NULL;
TRAC_INIT(&g_trac_errldisp, "ERRLDISP", KILOBYTE, TRACE::BUFFER_SLOW);

/**
 * @brief Default error log to display when we can't find one in the errorInfo
 *        table.
 *
 * The data tables and size variables
 *   static errLogInfo errorInfo []
 *   static compTableInfo compTable []
 *   static uint16_t errorInfoTableSize
 *   static uint16_t compTableSize
 * are automatically generated by the ../errl/parser/genErrlTable.pl script
 * and placed in the file $GENDIR/errldisplaydata.C
 */
static const ErrLogDisplay::errLogInfo unknownErrorInfo = {
    0,           // Module Id
    0,           // Reason Code
    "<none>",    // Description
    "unknown",   // Module Name
    "unknown",   // Reason
    "unknown",   // User Data 1 string
    "unknown"    // User Data 2 string
};


ErrLogDisplay& errLogDisplay()
{
    return Singleton<ErrLogDisplay>::instance();
}

const ErrLogDisplay::errLogInfo* ErrLogDisplay::findErrLogInfo (
                                    uint8_t i_moduleId, uint16_t i_reasonCode)
{
    // Create local errLogInfo to search for
    struct ErrLogDisplay::errLogInfo l_errLogInfo = {i_moduleId,i_reasonCode,
                                                     NULL,NULL,NULL,NULL,NULL};

    errLogInfo* l_result = std::lower_bound(errorInfo,
                                            errorInfo + errorInfoTableSize,
                                            l_errLogInfo,
                                            ErrLogDisplay::errorLogInfoCompare);

    // Check if the lower_bound found the correct result
    if ( (l_result != (errorInfo + errorInfoTableSize)) &&
         (l_result->moduleId == i_moduleId) &&
         (l_result->reasonCode == i_reasonCode) )
    {
        return l_result;
    }

    // Couldn't find it, so return the default unknown structure.
    return &unknownErrorInfo;
}

const char * ErrLogDisplay::findComponentName (compId_t i_compId)
{
    // Create local compTableInfo to search for
    struct ErrLogDisplay::compTableInfo l_compTableInfo = {i_compId, NULL};

    compTableInfo* l_result = std::lower_bound(compTable,
                                               compTable + compTableSize,
                                               l_compTableInfo,
                                               ErrLogDisplay::compTableCompare);

    // Check if the lower_bound found the correct result
    if ( (l_result != (compTable + errorInfoTableSize)) &&
         (l_result->value == i_compId) )
    {
        return l_result->name;
    }
    return "unknown";
}

void ErrLogDisplay::msgDisplay (const errlHndl_t &i_err,
                                compId_t i_committerComp)
{
    TRACFCOMP( g_trac_errldisp, ENTER_MRK "ErrLogDisplay::msgDisplay" );

    const ErrLogDisplay::errLogInfo* info = findErrLogInfo(i_err->moduleId(),
                                                           i_err->reasonCode());

    CONSOLE::displayf(NULL,
                      "================================================\n");
    CONSOLE::displayf(NULL, "Error reported by %s (0x%04X)\n",
                      findComponentName(i_committerComp), i_committerComp);
    CONSOLE::displayf(NULL, "  %s\n", info->descriptString);
    CONSOLE::displayf(NULL, "  ModuleId   0x%02x %s\n",
                      i_err->moduleId(), info->moduleName);
    CONSOLE::displayf(NULL, "  ReasonCode 0x%04x %s\n",
                      i_err->reasonCode(), info->reasonString);
    CONSOLE::displayf(NULL, "  UserData1  %s : 0x%016lx\n",
                      info->userData1String, i_err->getUserData1());
    CONSOLE::displayf(NULL, "  UserData2  %s : 0x%016lx\n",
                      info->userData2String, i_err->getUserData2());

    CONSOLE::flush();

    TRACFCOMP( g_trac_errldisp, EXIT_MRK "ErrLogDisplay::msgDisplay" );
}


/**
 * @brief This is the task entry point. It will register ErrlDisplay module with
 *        the base image Errl module.
 *
 * @param[in/out] io_taskRetErrl    Errl module to register with ErrlDisplay
 *                                  instance
 *
 * @return None
 */
static void errLogDisplayEntryPoint (errlHndl_t &io_taskRetErrl)
{
    TRACFCOMP( g_trac_errldisp, ENTER_MRK "ErrLogDisplay::errLogDisplayEntryPoint" );

    io_taskRetErrl = Singleton<ErrLogDisplay>::instance().init();

    TRACFCOMP( g_trac_errldisp, EXIT_MRK "ErrLogDisplay::errLogDisplayEntryPoint" );
}
TASK_ENTRY_MACRO( errLogDisplayEntryPoint );


errlHndl_t ErrLogDisplay::init()
{
    ERRORLOG::ErrlManager::errlResourceReady(ERRORLOG::ERRLDISP);
    return NULL;
}

} // End namespace
