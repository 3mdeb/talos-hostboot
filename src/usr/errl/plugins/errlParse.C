//  IBM_PROLOG_BEGIN_TAG
//  This is an automatically generated prolog.
//
//  $Source: src/usr/errl/plugins/errlParse.C $
//
//  IBM CONFIDENTIAL
//
//  COPYRIGHT International Business Machines Corp. 2012
//
//  p1
//
//  Object Code Only (OCO) source materials
//  Licensed Internal Code Source Materials
//  IBM HostBoot Licensed Internal Code
//
//  The source code for this program is not published or other-
//  wise divested of its trade secrets, irrespective of what has
//  been deposited with the U.S. Copyright Office.
//
//  Origin: 30
//
//  IBM_PROLOG_END

/**
 *  @file initsvcParse.C
 *
 *  errl user data parser
 */
#include <netinet/in.h>

// FSP includes
#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

// Hostboot includes.
#include <hbotcompid.H>
#include <hostBootSrcParse.H>
#include "symbols.H"

//-------------------------------------------------------------
// endian switch a uint64
// TODO all plugins are probably going to want this.

static uint64_t ntohll( uint64_t i )
#if __BYTE_ORDER == __LITTLE_ENDIAN
{
    //  CONTEXT_x86_nfp
    uint64_t hi;
    uint64_t lo;
    uint32_t * pword = reinterpret_cast<uint32_t*>(&i);

    hi = ntohl( *pword );
    lo = ntohl( *(pword+1) );

    return (hi<<32)|lo;
}
#elif __BYTE_ORDER == __BIG_ENDIAN
{
    // CONTEXT_ppc (or maybe CONTEXT_aix_nfp)
    return i;
}
#else
#error Unexpected endian context.
#endif

#include <errl/errludparserfactoryerrl.H>

static bool myDataParse(
    ErrlUsrParser& i_parser,
    void* i_buffer,
    uint32_t i_buflen,
    errlver_t i_ver,
    errlsubsec_t i_sst)
{

    bool l_rc = false;

    // Create a ErrlUserDetailsParserFactoryErrl object
    ERRORLOG::ErrlUserDetailsParserFactoryErrl l_factory;
    
    // Use the factory to create a ErrlUserDetailsParser object
    ERRORLOG::ErrlUserDetailsParser * l_pParser = l_factory.createParser(i_sst);
    
    if (l_pParser)
    {
        l_rc = true;
        l_pParser->parse(i_ver, i_parser, i_buffer, i_buflen);
    }
    
    return l_rc;
}

// Map my Hostboot component ID to the function above.
// static errl::DataPlugin g_DataPlugin( HBERRL_COMP_ID, hberrl_DataParse );
static errl::DataPlugin g_DataPlugin( HBERRL_COMP_ID, myDataParse );

//----------------------------------------------------------------------------
// Call the code generated by scanforsrc.pl

static bool hbSrcParse( ErrlUsrParser & i_parser, const SrciSrc & i_src  )
{
  uint32_t src = 0;

  sscanf( i_src.getAsciiString(), "%X", &src );

  // Call this function in obj/genfiles/hostBootSrcParse.H (a script-generated
  // file) which serves for any Hostboot component.   This will cause
  // the FSP errl tool to add the tagged information to the primary SRC
  // section of the error log. For example, the developer description
  // (devdesc) tag and associated info as well as the other tags describing
  // the userdata1 and userdata2 words.
  printErrorTags( i_parser, (src & 0xFFFF), i_src.moduleId()  );

  return false;
}

// Create an instance of SrcPlugin by type (instead of the usual component).
static errl::SrcPlugin  g_SrcPlugin( errl::Plugin::HOSTBOOT_SRCPARSE, hbSrcParse );

