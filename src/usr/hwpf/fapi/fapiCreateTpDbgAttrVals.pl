#!/usr/bin/perl -w
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: /afs/awd.austin.ibm.com/proj/p9/eclipz/KnowledgeBase/.cvsroot/eclipz/hwpf/working/hwp/tp_dbg_data_accessors/fapiCreateTpDbgAttrVals.pl,v $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2013,2015
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG
# $Id: fapiCreateTpDbgAttrVals.pl,v 1.1 2015/05/07 20:11:12 thi Exp $
#
# Purpose:  This perl script will parse HWP Attribute XML files
# and add attribute information to a file called fapiTpDbgAttr.H
#
# Version: 1.0
#
# Change Log **********************************************************
#
#  Flag  Track#    Userid    Date      Description
#  ----  --------  --------  --------  -----------
#        941745    thi       04/17/15  Created
#
# End Change Log ******************************************************

use strict;
use Cwd 'chdir';
use Env;

sub help;

my $ProgName       = "fapiCreateTpDbgAttrVals.pl";
my $spyAttrFile;
my $outputPwd;
my $DEBUG = 0;
my $VERBOSE = 0;
my $chip = "";
my $ec = "";
my $revision = "";
my $fileName = "fapiTpDbgDataAttr.H";

my  @fileList = ();
#Pull out the args passed in
&parseArgs;

my  $outputFile = "$outputPwd" . "$fileName";
my  $line = "";

my $dataCount = 0;

# Start to generate header file.

open (OUTFILE, ">$outputFile") or die "Couldn't open $outputFile for output. \n";

#Initial data types and definitions here

print OUTFILE "// fapiTpDbgDataAttr.H\n";
print OUTFILE "// This file is generated by perl script fapiCreateTpDbgAttrVals.pl\n";
print OUTFILE "\n";
print OUTFILE "\n";
print OUTFILE "#ifndef FAPI_TP_DBG_DATA_ATTR_H\n";
print OUTFILE "#define FAPI_TP_DBG_DATA_ATTR_H\n";
print OUTFILE "//----------------------------------------------------------------------\n";
print OUTFILE "//  Includes\n";
print OUTFILE "//----------------------------------------------------------------------\n";
print OUTFILE "#include <stdlib.h>\n";
print OUTFILE "\n";
print OUTFILE "#include <fapiAttributeIds.H>\n";
print OUTFILE "\n";
print OUTFILE "#define SPY_OFFSET_SIZE 24\n";


# Create array structure for TP_DBG_DATA attribute
print OUTFILE "struct TP_DBG_DATA_ATTR {\n";
print OUTFILE "    uint8_t  l_ATTR_CHIPTYPE;\n";
print OUTFILE "    uint8_t  l_ATTR_EC;\n";
print OUTFILE "    uint32_t l_ATTR_RING_LENGTH;\n";
print OUTFILE "    uint32_t l_ATTR_SPY_LENGTH;\n";
print OUTFILE "    uint32_t l_ATTR_TP_DBG_DATA[SPY_OFFSET_SIZE];\n";
print OUTFILE "};\n";
print OUTFILE "\n";
print OUTFILE "\n" . "const TP_DBG_DATA_ATTR TP_DBG_DATA_array [] = {\n";

# Loop over all attribute files
foreach $spyAttrFile (@fileList)
{
    if ($spyAttrFile =~ m"(\S+/)?(\S+?)_(\d+?)_tp_dbg_data.attributes") {
        $chip = $2;
        $ec = $3;
    } else
    {
        die "$ProgName ERROR : Couldn't parse chip type and ec from file $spyAttrFile \n\n";
    }
    my $dataArrayString = "";
    my $ringLengthVal = 0;
    my $spyLengthVal = 0;

# open the winkle ring attribute file
    open (FILE, "$spyAttrFile") or die "Couldn't open $spyAttrFile for input.\n";

    if ($spyAttrFile =~ m"\S+/(\S+)") {
        my $fileName = $1;
        my $temp = `head -1 $spyAttrFile`;
        if ($temp =~ m"Id: $fileName,v (\S+)") {
            $revision = $1;
        }
    }

    if (($DEBUG) || ($VERBOSE))
    {
        print "Chip: $chip \n";
        print "EC: $ec \n";
        print "File: $spyAttrFile \n";
        print "Output File: $outputFile\n";
    }


    #Embed some version info
    print OUTFILE "/**\n";
    print OUTFILE " \@kdbfile $spyAttrFile\n";
    print OUTFILE " \@chip $chip\n";
    print OUTFILE " \@ec $ec\n";
    print OUTFILE " \@version $revision\n";
    print OUTFILE "*/\n";

    while (<FILE>)
    {   
        # Store select value in array
        if ($_ =~ m"^ATTR_PROC_PERV_VITL_LENGTH u32\s+(\d+)\s+")
        {
            $dataCount = 0;
            $ringLengthVal = $1;
        
            my $chipEnum = 0;
            # Map chip type to fapi attribute enum values (p8=01, s1=02
            if ($chip eq "s1")
            {
               $chipEnum = "fapi::ENUM_ATTR_NAME_MURANO";
            }
            elsif ($chip eq "p8")
            {
               $chipEnum = "fapi::ENUM_ATTR_NAME_VENICE";
            }
            elsif ($chip eq "n1")
            {
               $chipEnum = "fapi::ENUM_ATTR_NAME_NAPLES";
            }
            else
            {
                die "$ProgName ERROR: Chip type $chip not supported by this script.  Either the spy attribute file is in error or support for the new chip type needs to be added.\n";
            }
            print OUTFILE "{\n";
            print OUTFILE "   $chipEnum, \t// CHIP TYPE  \n";
            print OUTFILE "   0x$ec, \t// EC LEVEL \n";
            print OUTFILE "   $ringLengthVal, \t// ATTR_PROC_PERV_VITL_LENGTH \n";
        }

        if ($_ =~ m"^ATTR_PROC_TP_VITL_SPY_LENGTH u32\s+(\d+)\s+")
        {
            $spyLengthVal = $1;
            print OUTFILE "   $spyLengthVal, \t// ATTR_PROC_TP_VITL_SPY_LENGTH \n";
            print OUTFILE "   {\n";
        }

        # Store values in array
        if ($_ =~ m"^ATTR_PROC_TP_VITL_SPY_OFFSETS\[(\d+)\]\s+\S+\s+(\S+)")
        {
            if ($dataCount != $1)
            {
                die "$ProgName: ERROR: Data array index value in file $spyAttrFile does not appear to be sequential.  There may be a script problem or a corrupted spy attribute file.\n";
            }
            $dataCount++;
            $dataArrayString = $dataArrayString . $2 . ", ";
            # If this is the last entry in the array (delta data size = 24)
            if ($dataCount eq 24)
            { 
                print OUTFILE "        $dataArrayString\n";
                print OUTFILE "   }, // ATTR_PROC_TP_VITL_SPY_OFFSETS\n";
                print OUTFILE "},\n";
                $dataArrayString = "";
            }
        }
    }

    close (FILE);

}
print OUTFILE "}; \n\n";

print OUTFILE "#endif  // FAPI_TP_DBG_DATA_ATTR_H\n";
close (OUTFILE);
exit 0;

sub help {
    printf("Usage:  $ProgName  <output directory> [<attributes-file1> [<attributes-file2> ...]] [--help|-h]\n");
    printf("Generates C header file from KB tp_dbg_data.attributes file(s).  \n");
    printf("Example: $ProgName \$PWD p8_20_tp_dbg_data.attributes -v\n\n");
    exit(0);
}

sub parseArgs {
    #Note that arg 0 MUST be output dir. If no args are specified, usage is printed.
    if (!defined $ARGV[0])
    {
        &help;
    }

    # Output directory is first parameter
    $outputPwd = $ARGV[0];
    $outputPwd .= "/";

    foreach my $argnum (1 .. $#ARGV)
    {
        my $Arg = $ARGV[$argnum];

        if ($Arg =~ m"^--debug" || $Arg =~ m"^-d")
        {
            $DEBUG = 1;
        }
        elsif ($Arg =~ m"^--verbose" || $Arg =~ m"^-v")
        {
            $VERBOSE = 1;
        }
        elsif ($Arg =~ m"^--help" || $Arg =~ m"^-h")
        {
            &help;
            exit 1;
        }
        else
        {
            push(@fileList,$Arg);
        }
    }
}
