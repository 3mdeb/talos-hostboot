/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/hwas/test/hwasGardTest.H $                            */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2011,2018                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
#ifndef _HWASGARDTEST_H
#define _HWASGARDTEST_H

/**
 *  @file hwasGardTest.H
 *
 *  @brief Unit tests for HWAS Deconfigure and GARD functionality
 */

//******************************************************************************
// Includes
//******************************************************************************

// CXXTEST
#include <cxxtest/TestSuite.H>
#include <errl/errlmanager.H>
#include <targeting/common/targetservice.H>
#include <targeting/common/utilFilter.H>
#include <hwas/common/hwas.H>
#include <hwas/common/deconfigGard.H>
#include <hwas/common/hwas_reasoncodes.H>

//  $$  make sure these are disabled before checking in!!
#define DISABLE_UNIT_TESTS        1
#define DISABLE_MBA_UNIT_TESTS    1
#define DISABLE_MEM_UNIT_TESTS    1
#define DISABLE_EX_UNIT_TESTS     1
//$$#define DISABLE_UNIT_TESTS        0

using namespace HWAS;
using namespace TARGETING;

bool compareAffinityCXX(const TargetInfo t1, const TargetInfo t2)
{
        return t1.affinityPath < t2.affinityPath;
}

class HwasGardTest: public CxxTest::TestSuite
{
public:

    /**
     *  @brief Test creating and getting a Deconfigure Record for a
     *      EX Target
     */
    void testDeconfigure2()
    {
        TS_TRACE(INFO_MRK "testDeconfigure2: Started");
        HWAS_INF("testDeconfigure2: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::DeconfigureRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeconfigure2: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // create a deconfigure record
            theDeconfigGard().
                    registerDeferredDeconfigure(*l_pTarget, 0x12);

            // Get that Deconfigure Record for the target
            l_pErr = theDeconfigGard().
                    _getDeconfigureRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testDeconfigure2: Error from _getDeconfigureRecords");
                break;
            }
            if (l_records.size() > 1)
            {
                TS_FAIL("testDeconfigure2: %d records for target",
                        l_records.size());
                break;
            }

            TS_TRACE(INFO_MRK "testDeconfigure2: Success. %d record",
                         l_records.size());

            // now delete it.
            theDeconfigGard().clearDeconfigureRecords(l_pTarget);

            // confirm that there aren't any deconfigure records - if so exit
            l_pErr = theDeconfigGard().
                        _getDeconfigureRecords(l_pTarget, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testDeconfigure2: Error from _getDeconfigureRecords");
                break;
            }

            TS_TRACE(INFO_MRK "testDeconfigure2: Success");
        }
        while (0);
    }

    /**
     *  @brief Test Deconfiguring a Target - EX directly
     */

    void testDeconfigure3()
    {
        TS_TRACE(INFO_MRK "testDeconfigure3: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigure3: Skipped");
#else
        HWAS_INF("testDeconfigure3: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeconfigure3: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            bool l_targetDeconfigured = false;
            l_pErr = theDeconfigGard().deconfigureTarget(*l_pTarget,
                       DeconfigGard::DECONFIGURED_BY_EX_DECONFIG,
                       &l_targetDeconfigured);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigure3: Error from deconfigureTarget");
                break;
            }
            if (l_targetDeconfigured == false)
            {
                TS_FAIL("testDeconfigure3: deconfigureTarget didn't set targetDeconfigured correctly");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigure3: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigure3: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring a Target multiple times directly
     */
    void testDeconfigure4()
    {
        TS_TRACE(INFO_MRK "testDeconfigure4: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigure4: Skipped");
#else
        HWAS_INF("testDeconfigure4: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeconfigure4: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get the current HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigure4: Error from deconfigureTarget");
                break;
            }

            // Deconfigure the target again
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xB);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigure4: Error from 2nd deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigure4: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigure4: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }


    /**
     *  @brief Test Deconfiguring a PEC Target directly
     */

    void testDeconfigurePECTarget()
    {
        TS_TRACE(INFO_MRK "testDeconfigurePECTarget: Started");

#if DISABLE_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigurePECTarget: Skipped");
#else
        HWAS_INF("testDeconfigurePECTarget: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            //Find a functional PEC Target for the deconfigure test
            Target * pSys;
            targetService().getTopLevelTarget(pSys);
            PredicateCTM predPEC(CLASS_UNIT, TYPE_PEC);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predPEC).push(&predFunctional).And();
            TargetHandleList l_pecList;
            targetService().getAssociated( l_pecList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            //Verify PEC list isn't empty
            if (l_pecList.empty())
            {
                TS_FAIL("testDeconfigurePECTarget: empty l_pecList");
                break;
            }

            //Iterate PEC targets doing the following
            // 1) Verify PEC is functional
            // 2) Verify Child PHB targets are functional
            // 3) Deconfigure PEC target
            // 4) Verify PEC target is non-functional
            // 5) Verify Child PHB targets are non-functional
            for (auto l_pec : l_pecList)
            {
                // Get the original HWAS_STATE of PEC
                HwasState l_state = l_pec->getAttr<ATTR_HWAS_STATE>();
                if (!l_state.functional)
                {
                    TS_FAIL("testDeconfigurePECTarget: PEC is non-functional"
                            " before deconfiguration");
                    break;
                }

                TargetHandleList l_phbList;
                // Get the list of PHB targets associated with the PEC target
                getChildAffinityTargets(l_phbList, l_pec,
                                        CLASS_NA, TYPE_PHB);

                if (l_phbList.empty())
                {
                    TS_FAIL("testDeconfigurePECTarget: empty l_phbList");
                    break;
                }

                //Iterate through the PHB's
                //   - Verify each is functional
                for (auto l_phb : l_phbList)
                {
                    l_state = l_phb->getAttr<ATTR_HWAS_STATE>();
                    //Verify the PHB is functional
                    if (!l_state.functional)
                    {
                        TS_FAIL("testDeconfigurePECTarget: PHB is non-functional before test");
                        break;
                    }
                }

                // Deconfigure the target PEC and check that works
                l_pErr = theDeconfigGard().
                        deconfigureTarget(*l_pec,
                            DeconfigGard::DECONFIGURED_BY_PEC_DECONFIG);
                if (l_pErr)
                {
                    TS_FAIL("testDeconfigurePECTarget: Error from deconfigureTarget");
                    break;
                }

                l_state = l_pec->getAttr<ATTR_HWAS_STATE>();
                if (l_state.functional)
                {
                    TS_FAIL("testDeconfigurePECTarget: PEC is functional after deconfiguration");
                    break;
                }
                // Reset the HWAS_STATE of PEC
                l_state.functional = 1;
                l_pec->setAttr<ATTR_HWAS_STATE>(l_state);

                // Iterate through child PHB targets and verify they were also
                //     deconfigured
                for (const auto l_phb : l_phbList)
                {
                    TS_TRACE("testDeconfigurePECTarget: PHB: %.8X",
                              get_huid(l_phb));
                    // Get the current HWAS_STATE of PHB
                    l_state = l_phb->getAttr<ATTR_HWAS_STATE>();
                    if (l_state.functional)
                    {
                        TS_FAIL("testDeconfigurePECTarget: PHB Functional after parent PEC deconfigured");
                        break;
                    }
                    //Reset HWAS State of the PHB
                    l_state.functional = 1;
                    l_phb->setAttr<ATTR_HWAS_STATE>(l_state);
                }
            }
        } while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }

#endif
    }

   /**
     *  @brief Verify PEC deconfigured when all PHB's deconfigured
     */
    void testDeconfigurePECwithAllBadPHBs()
    {
        TS_TRACE(INFO_MRK "testDeconfigurePECwithAllBadPHBs: Started");
#if DISABLE_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigurePECwithAllBadPHBs: Skipped");
#else
        HWAS_INF("testDeconfigurePECwithAllBadPHBs: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            //Find a functional PEC Target for the deconfigure test
            Target * pSys;
            targetService().getTopLevelTarget(pSys);
            PredicateCTM predPEC(CLASS_UNIT, TYPE_PEC);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predPEC).push(&predFunctional).And();
            TargetHandleList l_pecList;
            targetService().getAssociated( l_pecList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            //Verify PEC list isn't empty
            if (l_pecList.empty())
            {
                TS_FAIL("testDeconfigurePECwithAllBadPHBs: empty l_pecList");
                break;
            }

            //Iterate PEC targets doing the following
            // 1) Verify PEC is functional
            // 2) Verify Child PHB targets are functional
            // 3) Deconfigure all child PHB targets
            // 4) Verify PHB targets non-functional
            // 5) Verify PEC is non-functional after all child PHB targets are
            //    deconfigured
            for (auto l_pec : l_pecList)
            {
                HwasState l_state = l_pec->getAttr<ATTR_HWAS_STATE>();
                if (!l_state.functional)
                {
                    TS_FAIL("testDeconfigurePECwithAllBadPHBs: PEC is non-functional before test");
                    break;
                }

                TargetHandleList l_phbList;
                // Get the list of PHB targets associated with the PEC target
                getChildAffinityTargets(l_phbList, l_pec, CLASS_NA, TYPE_PHB);

                //Iterate through the PHB's
                //   - Verify each is functional
                //   - Deconfigure the PHB
                //   - Verify it is now-nonfunctional
                for (auto l_phb : l_phbList)
                {
                    l_state = l_phb->getAttr<ATTR_HWAS_STATE>();
                    //Verify the PHB is functional
                    if (!l_state.functional)
                    {
                        TS_FAIL("testDeconfigurePECwithAllBadPHBs: PHB is non-functional before test");
                        break;
                    }

                    //Deconfigure the PHB Target
                    l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_phb,
                        DeconfigGard::DECONFIGURED_BY_PHB_DECONFIG);
                    if (l_pErr)
                    {
                        TS_FAIL("testDeconfigurePECwithallBadPHBs: Error from deconfigureTarget");
                        break;
                    }

                    //Verify the PHB target is now non-functional
                    l_state = l_phb->getAttr<ATTR_HWAS_STATE>();
                    if (l_state.functional)
                    {
                        TS_FAIL("testDeconfigurePECwithAllBadPHBs: PHB is functional after deconfigure");
                        break;
                    }
                }

                //Verify PEC is now non-functional as all child PHB targets
                //  were deconfigured
                l_state = l_pec->getAttr<ATTR_HWAS_STATE>();
                if (l_state.functional)
                {
                    TS_FAIL("testDeconfigurePECwithAllBadPHBs: PEC is functional after deconfiguring all Child PHBs");
                    break;
                }

                //Reset HWAS State of the PEC
                l_state.functional = 1;
                l_pec->setAttr<ATTR_HWAS_STATE>(l_state);

                //Reset HWAS State of the Child PHB's
                for (auto l_phb : l_phbList)
                {
                    l_state.functional = 1;
                    l_phb->setAttr<ATTR_HWAS_STATE>(l_state);
                }

            }
        } while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }

#endif
    }

    /**
     *  @brief Test Deconfiguring a Target - EQ directly
     */
    void testDeconfigureEQTarget()
    {
        TS_TRACE(INFO_MRK "testDeconfigureEQTarget: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureEQTarget: Skipped");
#else
        HWAS_INF("testDeconfigureEQTarget: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find a eq unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEq(CLASS_UNIT, TYPE_EQ);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEq).push(&predFunctional).And();
            TargetHandleList pEqList;
            targetService().getAssociated( pEqList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pEqList.empty())
            {
                TS_FAIL("testDeconfigureEQTarget: empty pExList");
                break;
            }
            TargetHandle_t l_pTargetEQ = *pEqList.begin();

            // Get the original HWAS_STATE of EQ

            HwasState l_state = l_pTargetEQ->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testDeconfigureEQTarget: EQ is non-functional before deconfiguration");
                break;
            }

            TargetHandleList pExList, pCoreList[2];
            uint32_t cIndex = 0;
            // get the list of Exs
            getChildAffinityTargets(pExList, l_pTargetEQ, CLASS_NA ,TYPE_EX);

            if (pExList.empty())
            {
                TS_FAIL("testDeconfigureEQTarget: empty pExList");
                break;
            }

            // Pick up EX and cores and save them

            TargetHandle_t pEx, pCore;
            bool exitLoop = false;
            for (TargetHandleList::iterator pEx_it = pExList.begin();
                   (pEx_it != pExList.end()) || exitLoop; ++pEx_it)
            {
                pEx = *pEx_it;
                TS_TRACE("testDeconfigureEQTarget: EX: %.8X",
                         get_huid(pEx));
                // Get the original HWAS_STATE of EX
                l_state = pEx->getAttr<ATTR_HWAS_STATE>();
                if (!l_state.functional)
                {
                    TS_FAIL("testDeconfigureEQTarget: EX is non-functional before deconfiguration");
                    break;
                }
                getChildAffinityTargets(pCoreList[cIndex],
                                    pEx, CLASS_NA ,TYPE_NA);

                for (TargetHandleList::iterator pChild_it =
                       pCoreList[cIndex].begin();
                       pChild_it != pCoreList[cIndex].end(); ++pChild_it)
                {
                    pCore = *pChild_it;
                    TS_TRACE("testDeconfigureEQTarget: Core: %.8X",
                         get_huid(pCore));
                    // Get the original HWAS_STATE of the core
                    l_state = pCore->getAttr<ATTR_HWAS_STATE>();
                    if (!l_state.functional)
                    {
                        TS_FAIL("testDeconfigureEQTarget: Core is non-functional before deconfiguration");
                        exitLoop = true;
                        break;
                    }
                } // for CHILD
                cIndex++;
            } // for pEx_it

            if (exitLoop)
            {
                break;
            }

            // Deconfigure the target EQ
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTargetEQ,
                        DeconfigGard::DECONFIGURED_BY_EQ_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureEQTarget: Error from deconfigureTarget");
                break;
            }

            l_state = l_pTargetEQ->getAttr<ATTR_HWAS_STATE>();
            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureEQTarget: EQ is functional after deconfiguration");
                break;
            }
            // Reset the HWAS_STATE of EQ
            l_state.functional = 1;
            l_pTargetEQ->setAttr<ATTR_HWAS_STATE>(l_state);

            cIndex = 0;
            for (TargetHandleList::iterator pEx_it = pExList.begin();
                   (pEx_it != pExList.end()) || exitLoop; ++pEx_it)
            {
                pEx = *pEx_it;
                TS_TRACE("testDeconfigureEQTarget: EX: %.8X",
                         get_huid(pEx));
                // Get the original HWAS_STATE of EX
                l_state = pEx->getAttr<ATTR_HWAS_STATE>();
                if (l_state.functional)
                {
                    TS_FAIL("testDeconfigureEQTarget: EX is functional after deconfiguration");
                    break;
                }

                for (TargetHandleList::iterator pChild_it =
                       pCoreList[cIndex].begin();
                       pChild_it != pCoreList[cIndex].end(); ++pChild_it)
                {
                    pCore = *pChild_it;
                    TS_TRACE("testDeconfigureEQTarget: Core: %.8X",
                         get_huid(pCore));
                    // Get the original HWAS_STATE of the core
                    l_state = pCore->getAttr<ATTR_HWAS_STATE>();
                    if (l_state.functional)
                    {
                        TS_FAIL("testDeconfigureEQTarget: Core is functional after deconfiguration");
                        exitLoop = true;
                        break;
                    }
                    // Reset the HWAS_STATE of the core
                    l_state.functional = 1;
                    pCore->setAttr<ATTR_HWAS_STATE>(l_state);
                } // for CHILD
                cIndex++;
            }

            TS_TRACE(INFO_MRK "testDeconfigureEQTarget: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring by Association
     */
    void testDeconfigureAssoc1()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc1: Started");
#if DISABLE_MBA_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssoc1: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc1: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an MBA
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predMba(CLASS_UNIT, TYPE_MBA);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predMba).push(&predFunctional).And();
            TargetHandleList pMba;
            targetService().getAssociated( pMba, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pMba.empty())
            {
                TS_FAIL("testDeconfigureAssoc1: empty pMba");
                break;
            }
            //TargetHandle_t l_pTarget = *pMba.begin();
            TargetHandle_t l_pTarget = pMba[pMba.size()-1];

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA101);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc1: Error from deconfigureTarget");
                break;
            }

            l_pTarget = pMba[1];

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA102);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc1: Error from deconfigureTarget");
                break;
            }
            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc1: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc1: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring by Association
     */
    void testDeconfigureAssoc2()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc2: Started");
#if DISABLE_MEM_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssoc2: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc2: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an MEMBUF
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predMembuf(CLASS_CHIP, TYPE_MEMBUF);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predMembuf).push(&predFunctional).And();
            TargetHandleList pMembuf;
            targetService().getAssociated( pMembuf, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pMembuf.empty())
            {
                TS_FAIL("testDeconfigureAssoc2: empty pMembuf");
                break;
            }
            TargetHandle_t l_pTarget = *pMembuf.begin();

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA2);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc2: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc2: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc2: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring by Association
     */
    void testDeconfigureAssoc3()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc3: Started");
#if DISABLE_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssoc3: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc3: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an DIMM
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predDimm(CLASS_LOGICAL_CARD, TYPE_DIMM);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predDimm).push(&predFunctional).And();
            TargetHandleList pDimm;
            targetService().getAssociated( pDimm, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pDimm.empty())
            {
                TS_FAIL("testDeconfigureAssoc3: empty pDimm");
                break;
            }
            TargetHandle_t l_pTarget = *pDimm.begin();

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA3);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc3: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc3: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc3: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }
    /**
     *  @brief Test Deconfiguring by Association
     */
    void testDeconfigureAssoc4()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc4: Started");
#if DISABLE_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssoc4: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc4: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an MCS
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predMcs(CLASS_UNIT, TYPE_MCS);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predMcs).push(&predFunctional).And();
            TargetHandleList pMcs;
            targetService().getAssociated( pMcs, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pMcs.empty())
            {
                TS_FAIL("testDeconfigureAssoc4: empty pMcs");
                break;
            }
            TargetHandle_t l_pTarget = *pMcs.begin();

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA4);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc4: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc4: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc4: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring by Association
     */
    void testDeconfigureAssoc5()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc5: Started");
#if DISABLE_MBA_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversely affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE(" - SKIPPING -- other tests could be adversely affected");
        HWAS_INF("testDeconfigureAssoc5: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc5: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find a MBA, deconfigure the attached DIMMs
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predMba(CLASS_UNIT, TYPE_MBA);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr funcMbas;
            funcMbas.push(&predMba).push(&predFunctional).And();

            TargetHandleList pMbaList;
            targetService().getAssociated(pMbaList, pSys,
                TargetService::CHILD, TargetService::ALL,
                &funcMbas);

            if (pMbaList.empty())
            {
                TS_FAIL("testDeconfigureAssoc5: empty MBA list");
                break;
            }
            TargetHandle_t l_pMba = pMbaList[0];

            // Get the original HWAS_STATE of the MBA
            HwasState l_origState = l_pMba->getAttr<ATTR_HWAS_STATE>();

            // find all DIMM targets
            PredicateCTM predDimm(CLASS_LOGICAL_CARD, TYPE_DIMM);
            PredicatePostfixExpr funcDimms;
            funcDimms.push(&predDimm).push(&predFunctional).And();
            TargetHandleList pDimmList;
            targetService().getAssociated(pDimmList, l_pMba,
                    TargetService::CHILD_BY_AFFINITY, TargetService::ALL,
                    &funcDimms);
            if (pDimmList.empty())
            {
                TS_FAIL("testDeconfigureAssoc5: empty DIMM list");
                break;
            }

            // deconfigure all but one DIMM
            for (auto i = pDimmList.size() - 1;i > 0;--i)
            {
                TargetHandle_t l_pDimm = pDimmList[i];

                // Deconfigure the DIMM.
                l_pErr = theDeconfigGard().
                        deconfigureTarget(*l_pDimm, 0xA5);
                if (l_pErr)
                {
                    TS_FAIL("testDeconfigureAssoc5: Error from deconfigureTarget");
                    break;
                }
            }
            // Check the HWAS_STATE of the MBA
            HwasState l_state = l_pMba->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc5: MBA not functional after deconfiguring most DIMMS");
                break;
            }

            // deconfigure last functional DIMM
            TargetHandle_t l_pLastDimm = pDimmList[0];
            l_pErr = theDeconfigGard().deconfigureTarget(*l_pLastDimm, 0xA6);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc5: Error from deconfigureTarget");
                break;
            }
            // Check the HWAS_STATE of the MBA
            l_state = l_pMba->getAttr<ATTR_HWAS_STATE>();
            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc5: MBA functional after deconfiguring all DIMMS");
                break;
            }

            // Reset the HWAS_STATE of the DIMMs and MBA
            ATTR_HWAS_STATE_type functionalHwasState = {0};
            functionalHwasState.functional = true;
            for (auto l_pDimm: pDimmList)
                l_pDimm->setAttr<ATTR_HWAS_STATE>(functionalHwasState);
            l_pMba->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc5: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr, HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test Deconfiguring by Association
     *
     *  Ensure that if a parent of an MBA being deconfigured is not present
     *  (due to some other bug) that the deconfig by association code properly
     *  handles it.
     *
     */
    void testDeconfigureAssoc6()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssoc6: Started");
#if DISABLE_MEM_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssoc6: Skipped");
#else
        HWAS_INF("testDeconfigureAssoc6: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // find an MEMBUF
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predMembuf(CLASS_CHIP, TYPE_MEMBUF);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predMembuf).push(&predFunctional).And();
            TargetHandleList pMembuf;
            targetService().getAssociated( pMembuf, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pMembuf.empty())
            {
                TS_FAIL("testDeconfigureAssoc6: empty pMembuf");
                break;
            }
            TargetHandle_t l_pTarget = *pMembuf.begin();

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // Get it's parent DMI target
            TargetHandleList pParentDmiList;
            getParentAffinityTargetsByState(pParentDmiList, l_pTarget,
                    CLASS_UNIT, TYPE_DMI, UTIL_FILTER_PRESENT);
            if (pParentDmiList.empty())
            {
                TS_FAIL("testDeconfigureAssoc6: empty pParentDmiList");
                break;
            }
            TargetHandle_t l_parentTgt = *pParentDmiList.begin();

            // Save off parent state and set to not present
            HwasState l_parOrigState = l_parentTgt->getAttr<ATTR_HWAS_STATE>();
            HwasState l_parTestState = l_parOrigState;
            l_parTestState.present = 0;
            l_parentTgt->setAttr<ATTR_HWAS_STATE>(l_parTestState);

            // Deconfigure the target.
            l_pErr = theDeconfigGard().
                    deconfigureTarget(*l_pTarget, 0xA2);
            if (l_pErr)
            {
                TS_FAIL("testDeconfigureAssoc6: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDeconfigureAssoc6: target functional after deconfigure");
                break;
            }

            // Reset the HWAS_STATE of the target and it's parent
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);
            l_parentTgt->setAttr<ATTR_HWAS_STATE>(l_parOrigState);

            TS_TRACE(INFO_MRK "testDeconfigureAssoc6: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test EX with no good cores should be deconfigured
     */
    void testDeConfigEX2BadCores()
    {
        TS_TRACE(INFO_MRK "testDeConfigEX2BadCores: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeConfigEX2BadCores: Skipped");
#else
        HWAS_INF("testDeConfigEX2BadCores: Started");

        errlHndl_t l_pErr = NULL;
        do
        {

            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);

            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList, pCoreList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeConfigEX2BadCores: empty pExList");
                break;
            }

            // Pick up first EX
            TargetHandle_t pEx = *pExList.begin();
            TS_TRACE("testDeConfigEX2BadCores EX: %.8X",
                       get_huid(pEx));
            HwasState l_State, ex_State, oex_State;
            TargetHandle_t pCore;

            // find all CHILD_BY_AFFINITY matches for this EX i.e. cores
            // set state non-functional
            getChildAffinityTargets(pCoreList, pEx, CLASS_NA ,TYPE_NA);

            for (TargetHandleList::iterator pChild_it = pCoreList.begin();
                   pChild_it != pCoreList.end(); ++pChild_it)
            {
                pCore = *pChild_it;
                TS_TRACE("testDeConfigEX2BadCores Core: %.8X",
                         get_huid(pCore));
                // Get the original HWAS_STATE of the target
                l_State = pCore->getAttr<ATTR_HWAS_STATE>();
                l_State.functional  =   0 ;
                pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);
            } // for CHILD

            // Get the HWAS_STATE of EX
            oex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (!oex_State.functional)
            {
                TS_FAIL("testDeConfigEX2BadCores: Ex non-functional, expected functional");
                break;
            }

            // Deconfigure any of the core
            pCore = *pCoreList.begin();
            l_pErr = theDeconfigGard().deconfigureTarget(*pCore,
                          DeconfigGard::DECONFIGURED_BY_CORE_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeConfigEX2BadCores: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE EX
            ex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (ex_State.functional)
            {
                TS_FAIL("testDeConfigEX2BadCores: Ex functional when cores non-functional");
                break;
            }

            // Reset the HWAS_STATE of EX
            pEx->setAttr<ATTR_HWAS_STATE>(oex_State);

            // reset all core states
            for (TargetHandleList::iterator pChild_it = pCoreList.begin();
                   pChild_it != pCoreList.end(); ++pChild_it)
            {
                TargetHandle_t pCore = *pChild_it;
                TS_TRACE("testDeConfigEX2BadCores Core: %.8X",
                         get_huid(pCore));
                // Get the original HWAS_STATE of the target
                l_State = pCore->getAttr<ATTR_HWAS_STATE>();
                l_State.functional  =   1 ;
                pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);
            } // for CHILD
            TS_TRACE(INFO_MRK "testDeConfigEX2BadCores: Success");
        }
        while (0);

#endif
    }

    /**
     *  @brief Test EX with one good and one bad core should not be deconfigured
     */

    void testDeConfigEX1BadCore()
    {
        TS_TRACE(INFO_MRK "testDeConfigEX1BadCore: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeConfigEX1BadCore: Skipped");
#else
        HWAS_INF("testDeConfigEX1BadCore: Started");

        errlHndl_t l_pErr = NULL;
        do
        {

            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);

            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList, pCoreList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeConfigEX1BadCore: empty pExList");
                break;
            }

            // Pick up first EX
            TargetHandle_t pEx = *pExList.begin();
            TS_TRACE("testDeConfigEX1BadCore EX: %.8X",
                       get_huid(pEx));
            HwasState l_State, ex_State, oex_State;
            TargetHandle_t pCore;

            // find all CHILD_BY_AFFINITY matches for this EX i.e. cores
            // set state non-functional
            getChildAffinityTargets(pCoreList, pEx, CLASS_NA ,TYPE_NA);

            // Set first core state non-functional
            TargetHandleList::iterator pChild_it = pCoreList.begin();
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   0 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Set second core state functional
            ++pChild_it;
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Get the HWAS_STATE of EX
            oex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (!oex_State.functional)
            {
                TS_FAIL("testDeConfigEX1BadCore: Ex non-functional, expected functional");
                break;
            }

            // Deconfigure the first core
            pCore = *pCoreList.begin();
            l_pErr = theDeconfigGard().deconfigureTarget(*pCore,
                          DeconfigGard::DECONFIGURED_BY_CORE_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeConfigEX1BadCore: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE EX
            ex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (!ex_State.functional)
            {
                TS_FAIL("testDeConfigEX1BadCore: Ex non-functional when one core is functional");
                break;
            }

            // Set both cores state functional
            pChild_it = pCoreList.begin();
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            ++pChild_it;
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            TS_TRACE(INFO_MRK "testDeConfigEX1BadCore: Success");
        }
        while (0);

#endif
    }

    /**
     *  @brief Test EQ with no good EXs should be deconfigured
     */
    void testDeConfigEQ2BadEXs()
    {
        TS_TRACE(INFO_MRK "testDeConfigEQ2BadEXs: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeConfigEQ2BadEXs: Skipped");
#else
        HWAS_INF("testDeConfigEQ2BadEXs: Started");

        errlHndl_t l_pErr = NULL;

        do
        {

            // find a eq unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEq(CLASS_UNIT, TYPE_EQ);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);

            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEq).push(&predFunctional).And();

            TargetHandleList pEqList, pExList;
            targetService().getAssociated( pEqList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pEqList.empty())
            {
                TS_FAIL("testDeConfigEQ2BadEXs: empty pEqList");
                break;
            }

            // Pick up first EQ
            TargetHandle_t pEq = *pEqList.begin();
            TS_TRACE("testDeConfigEQ2BadEXs EQ: %.8X",
                       get_huid(pEq));
            HwasState l_State, eq_State, oeq_State;
            TargetHandle_t pEx;

            // find all CHILD_BY_AFFINITY matches for this EQ i.e. EXs
            // set state non-functional
            getChildAffinityTargets(pExList, pEq, CLASS_NA ,TYPE_NA);

            for (TargetHandleList::iterator pChild_it = pExList.begin();
                   pChild_it != pExList.end(); ++pChild_it)
            {
                pEx = *pChild_it;
                TS_TRACE("testDeConfigEQ2BadEXs EX: %.8X",
                         get_huid(pEx));
                // Get the original HWAS_STATE of the target
                l_State = pEx->getAttr<ATTR_HWAS_STATE>();
                l_State.functional  =   0 ;
                pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);
            } // for CHILD

            // Get the HWAS_STATE of EQ
            oeq_State = pEq->getAttr<ATTR_HWAS_STATE>();
            if (!oeq_State.functional)
            {
                TS_FAIL("testDeConfigEQ2BadEXs: Eq non-functional, expected functional");
                break;
            }

            // Deconfigure any of the EX
            pEx = *pExList.begin();
            l_pErr = theDeconfigGard().deconfigureTarget(*pEx,
                       DeconfigGard::DECONFIGURED_BY_EX_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeConfigEQ2BadEXs: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE EQ
            eq_State = pEq->getAttr<ATTR_HWAS_STATE>();
            if (eq_State.functional)
            {
                TS_FAIL("testDeConfigEQ2BadEXs: Eq functional when Exs non-functional");
                break;
            }

            // Reset the HWAS_STATE of EX
            pEq->setAttr<ATTR_HWAS_STATE>(oeq_State);

            // reset all core states
            for (TargetHandleList::iterator pChild_it = pExList.begin();
                   pChild_it != pExList.end(); ++pChild_it)
            {
                TargetHandle_t pEx = *pChild_it;
                TS_TRACE("testDeConfigEQ2BadEXs EX: %.8X",
                         get_huid(pEx));
                // Get the original HWAS_STATE of the target
                l_State = pEx->getAttr<ATTR_HWAS_STATE>();
                l_State.functional  =   1 ;
                pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);
            } // for CHILD
            TS_TRACE(INFO_MRK "testDeConfigEQ2BadEXs: Success");
        }
        while (0);

#endif
    }

    /**
     *  @brief Test EQ with one good and one bad EX should not be deconfigured
     */

    void testDeConfigEQ1BadEX()
    {
        TS_TRACE(INFO_MRK "testDeConfigEQ1BadEX: Started");
#if DISABLE_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeConfigEQ1BadEX: Skipped");
#else
        HWAS_INF("testDeConfigEQ1BadEX: Started");

        errlHndl_t l_pErr = NULL;
        do
        {

            // find a eq unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEq(CLASS_UNIT, TYPE_EQ);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);

            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEq).push(&predFunctional).And();

            TargetHandleList pEqList;
            targetService().getAssociated( pEqList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pEqList.empty())
            {
                TS_FAIL("testDeConfigEQ1BadEX: empty pEqList");
                break;
            }

            // Pick up first EQ
            TargetHandle_t pEq = *pEqList.begin();
            TS_TRACE("testDeConfigEQ1BadEX EQ: %.8X", get_huid(pEq));
            HwasState l_State, eq_State, oeq_State;

            // find all CHILD_BY_AFFINITY matches for this EX i.e. cores
            // set state non-functional
            TargetHandleList pExList;
            TargetHandle_t pEx;
            getChildAffinityTargets(pExList, pEq, CLASS_NA ,TYPE_NA);

            // Set first core state non-functional
            TargetHandleList::iterator pChild_it = pExList.begin();
            pEx = *pChild_it;
            l_State = pEx->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   0 ;
            pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Set second core state functional
            ++pChild_it;
            pEx = *pChild_it;
            l_State = pEx->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Get the HWAS_STATE of EQ
            oeq_State = pEq->getAttr<ATTR_HWAS_STATE>();
            if (!oeq_State.functional)
            {
                TS_FAIL("testDeConfigEQ1BadEX: Eq non-functional, expected functional");
                break;
            }

            // Deconfigure the first EX
            pEx = *pExList.begin();
            l_pErr = theDeconfigGard().deconfigureTarget(*pEx,
                         DeconfigGard::DECONFIGURED_BY_EX_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeConfigEQ1BadEX: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE EX
            eq_State = pEq->getAttr<ATTR_HWAS_STATE>();
            if (!eq_State.functional)
            {
                TS_FAIL("testDeConfigEQ1BadEX: Eq non-functional, one core functional");
                break;
            }

            // Set both EXs state functional
            pChild_it = pExList.begin();
            pEx = *pChild_it;
            l_State = pEx->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            ++pChild_it;
            pEx = *pChild_it;
            l_State = pEx->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pEx->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            TS_TRACE(INFO_MRK "testDeConfigEQ1BadEX: Success");
        }
        while (0);

#endif
    }

    /**
     *  @brief Test in fused core mode EX with one good and one bad core
     *  should be deconfigured
     */

    void testDeConfigEXInFusedCoreMode()
    {
        TS_TRACE(INFO_MRK "testDeConfigEXInFusedCoreMode: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeConfigEXInFusedCoreMode: Skipped");
#else
        HWAS_INF("testDeConfigEXInFusedCoreMode: Started");

        errlHndl_t l_pErr = NULL;
        do
        {

            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);

            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList, pCoreList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: empty pExList");
                break;
            }

            // Pick up first EX
            TargetHandle_t pEx = *pExList.begin();
            TS_TRACE("testDeConfigEXInFusedCoreMode EX: %.8X",
                       get_huid(pEx));
            HwasState l_State, ex_State, oex_State;
            TargetHandle_t pCore;

            // find all CHILD_BY_AFFINITY matches for this EX i.e. cores
            // set state non-functional
            getChildAffinityTargets(pCoreList, pEx, CLASS_NA ,TYPE_NA);

            // Set first core state non-functional
            TargetHandleList::iterator pChild_it = pCoreList.begin();
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   0 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Set second core state functional
            ++pChild_it;
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            // Get the HWAS_STATE of EX
            oex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (!oex_State.functional)
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: Ex non-functional, expected functional");
                break;
            }

            // Deconfigure the first core
            pCore = *pCoreList.begin();
            l_pErr = theDeconfigGard().deconfigureTarget(*pCore,
                         DeconfigGard::DECONFIGURED_BY_CORE_DECONFIG);
            if (l_pErr)
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: Error from deconfigureTarget");
                break;
            }

            // Get the new HWAS_STATE EX
            ex_State = pEx->getAttr<ATTR_HWAS_STATE>();
            if (ex_State.functional)
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: Ex functional in Fused Core Mode");
                break;
            }

            // Set both cores state functional
            pChild_it = pCoreList.begin();
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            if (l_State.functional)
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: Core1 is functional in Fused Core Mode");
                break;
            }
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            ++pChild_it;
            pCore = *pChild_it;
            l_State = pCore->getAttr<ATTR_HWAS_STATE>();
            if (l_State.functional)
            {
                TS_FAIL("testDeConfigEXInFusedCoreMode: Core2 is functional in Fused Core Mode");
                break;
            }
            l_State.functional  =   1 ;
            pCore->setAttr<TARGETING::ATTR_HWAS_STATE>(l_State);

            TS_TRACE(INFO_MRK "testDeConfigEXInFusedCoreMode: Success");
        }
        while (0);

#endif
    }

    /**
     *  @brief Test EQ with no good EXs should be deconfigured
     */
    /**
     *  @brief Test Deconfiguring a Target via deferred
     */
    void testDefDeconfig1()
    {
        TS_TRACE(INFO_MRK "testDefDeconfig1: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        HWAS_INF("testDefDeconfig1: Skipped");
#else
        HWAS_INF("testDefDeconfig1: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::DeconfigureRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testDefDeconfig1: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get any existing Deconfigure Record for the target
            l_pErr = theDeconfigGard().
                    _getDeconfigureRecords(l_pTarget, l_records);
            if (l_pErr)
            {
                TS_FAIL("testDefDeconfig1: Error from _getDeconfigureRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testDefDeconfig1: target has existing Deconfigure Record, skipping test");
                break;
            }

            // Get the original HWAS_STATE of the target
            HwasState l_origState = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            // create a deconfigure record
            theDeconfigGard().
                    registerDeferredDeconfigure(*l_pTarget, 0x12);

            // call function to process deferred deconfigure records
            theDeconfigGard().processDeferredDeconfig();

            // Get the new HWAS_STATE of the target
            HwasState l_state = l_pTarget->getAttr<ATTR_HWAS_STATE>();

            if (l_state.functional)
            {
                TS_FAIL("testDefDeconfig1: target functional after deconfigure");
                // intentionally continue
            }

            // Try to get the Deconfigure Record for the target
            l_pErr = theDeconfigGard().
                    _getDeconfigureRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testDefDeconfig1: Error from _getDeconfigureRecords (2)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testDefDeconfig1: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            // Reset the HWAS_STATE of the target
            l_pTarget->setAttr<ATTR_HWAS_STATE>(l_origState);

            TS_TRACE(INFO_MRK "testDefDeconfig1: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test getting all GARD Records
     */
    void testGard1()
    {
        TS_TRACE(INFO_MRK "testGard1: Started");
        HWAS_INF("testGard1: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
            TS_FAIL("testGard1: Error from getGardRecords(NULL)");
        }
        else
        {
            TS_TRACE(INFO_MRK "testGard1: get(NULL) Success. %d records",
                     l_records.size());
        }
    }

    /**
     *  @brief Test creating a GARD Record, getting the GARD Record and
     *         clearing the GARD Record
     */
    void testGard4()
    {
        TS_TRACE(INFO_MRK "testGard4: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard4: Skipped");
#else
        HWAS_INF("testGard4: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard4: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get any existing GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);
            if (l_pErr)
            {
                TS_FAIL("testGard4: Error from getGardRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testGard4: target has %d existing Gard Records, skipping test",
                         l_records.size());
                break;
            }

            // Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x12, GARD_Predictive);

            if (l_pErr)
            {
                TS_FAIL("testGard4: Error from platCreateGardRecord");
                break;
            }

            // Get the GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard4: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 1)
            {
                TS_FAIL("testGard4: %d records for target, expected 1",
                        l_records.size());
                break;
            }

            if (l_records[0].iv_errorType != GARD_Predictive)
            {
                TS_FAIL("testGard4: Record errorType %d, expected predictive",
                        l_records[0].iv_errorType);
                break;
            }

            // Clear the GARD Records for the target
            l_pErr = theDeconfigGard().clearGardRecords(l_pTarget);

            if (l_pErr)
            {
                TS_FAIL("testGard4: Error from clearGardRecords");
                break;
            }

            // Get the GARD Records for the target
            l_records.clear();

            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard4: Error from getGardRecords (3)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard4: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            TS_TRACE(INFO_MRK "testGard4: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test creating a GARD Record for a Target multiple times
     */
    void testGard5()
    {
        TS_TRACE(INFO_MRK "testGard5: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard5: Skipped");
#else
        HWAS_INF("testGard5: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard5: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get any existing GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from getGardRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testGard5: target has %d existing Gard Records, skipping test",
                         l_records.size());
                break;
            }

            // Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x23, GARD_Predictive);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from platCreateGardRecord");
                break;
            }

            // Create another GARD Record for the target
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x45, GARD_Fatal);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from platCreateGardRecord (2)");
                break;
            }

            // Get the GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 1)
            {
                TS_FAIL("testGard5: %d records for target, expected 1",
                        l_records.size());
                break;
            }

            // Clear the GARD Record for the target
            l_pErr = theDeconfigGard().clearGardRecords(l_pTarget);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from clearGardRecords");
                break;
            }

            // Get the GARD Records for the target
            l_records.clear();

            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard5: Error from getGardRecords (3)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard5: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            TS_TRACE(INFO_MRK "testGard5: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test creating a 2nd GARD Record overwrites manual gard
     */
    void testGard6()
    {
        TS_TRACE(INFO_MRK "testGard6: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard6: Skipped");
#else
        HWAS_INF("testGard6: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard6: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get any existing GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from getGardRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testGard6: target has %d existing Gard Records, skipping test",
                         l_records.size());
                break;
            }

            // Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x23, GARD_User_Manual);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from platCreateGardRecord");
                break;
            }

            // Create another GARD Record for the target - should overwrite
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x46, GARD_Fatal);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from platCreateGardRecord (2)");
                break;
            }

            // Get the GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 1)
            {
                TS_FAIL("testGard6: %d records for target, expected 1",
                        l_records.size());
                break;
            }

            if ((l_records[0].iv_errlogEid != 0x46) ||
                (l_records[0].iv_errorType != GARD_Fatal))
            {
                TS_FAIL("testGard6: unexpected data - errl 0x%X type %x",
                    l_records[0].iv_errlogEid, l_records[0].iv_errorType);
                break;
            }

            // Clear the GARD Record for the target
            l_pErr = theDeconfigGard().clearGardRecords(l_pTarget);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from clearGardRecords");
                break;
            }

            // Get the GARD Records for the target
            l_records.clear();

            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard6: Error from getGardRecords (3)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard6: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            TS_TRACE(INFO_MRK "testGard6: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test getting and clearing all GARD Records
     */
    void testGard7()
    {
        TS_TRACE(INFO_MRK "testGard7: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard7: Skipped");
#else
        HWAS_INF("testGard7: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard7: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get all existing GARD Records
            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard7: Error from getGardRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testGard7: %d existing Gard Records, skipping test",
                         l_records.size());
                break;
            }

            // Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x71, GARD_Predictive);

            if (l_pErr)
            {
                TS_FAIL("testGard7: Error from platCreateGardRecord");
                break;
            }

            // Clear all GARD Records
            l_pErr = theDeconfigGard().clearGardRecords(NULL);

            if (l_pErr)
            {
                TS_FAIL("testGard7: Error from clearGardRecords(NULL)");
                break;
            }

            // Get the GARD Records
            l_records.clear();

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard7: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard7: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            TS_TRACE(INFO_MRK "testGard7: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test create GARD record, call collect GARD to confirm targets
     *      are deconfigured, set changed bit ala HCDB, reprocess GARD to
     *      confirm GARD record is deleted.
     */
    void testGard8()
    {
        TS_TRACE(INFO_MRK "testGard8: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard8: Skipped");
#else
        HWAS_INF("testGard8: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard8: Error from getGardRecords");
                break;
            }

            if (l_records.size() > 0)
            {
                TS_FAIL("testGard8: already GARD records here. %d records",
                        l_records.size());
                break;
            }
            // find an ex unit that we can play with

            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard8: empty pExList");
                break;
            }

            TargetHandle_t l_target = *pExList.begin();

            // create GARD record, call 'doGard' step and confirm target is
            //  deconfigured
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_target, 0x12, GARD_Void);
            if (l_pErr)
            {
                TS_FAIL("testGard8: Error from platCreateGardRecord");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard8: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 1)
            {
                TS_FAIL("testGard8: should be 1 record; instead %d records",
                        l_records.size());
                break;
            }

            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard8: Error from collectGard");
                break;
            }

            HwasState l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (l_state.functional)
            {
                TS_FAIL("testGard8: target still functional");
                break;
            }

            // reset functional state
            l_state.functional = true;
            l_target->setAttr<ATTR_HWAS_STATE>(l_state);

            // emulate HCDB - target changed, call collectGard and confirm
            //  GARD record is gone and target is functional
            update_hwas_changed_mask(l_target);
            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard8: Error from collectGard2");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard8: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 0)
            {
                TS_FAIL("testGard8: should be 0 records; instead %d records",
                        l_records.size());
                break;
            }

            l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testGard8: target NOT functional");
                break;
            }

            TS_TRACE(INFO_MRK "testGard8: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test CDM modes to restrict creating GARD records
     */
    void testGard9()
    {
        TS_TRACE(INFO_MRK "testGard9: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard9: Skipped");
#else
        HWAS_INF("testGard9: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();
            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard9: empty pExList");
                break;
            }
            TargetHandle_t l_pTarget = *pExList.begin();

            // Get any existing GARD Records for the target
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard9: Error from getGardRecords");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_TRACE(INFO_MRK "testGard9: target has %d existing Gard Records, skipping test",
                         l_records.size());
                break;
            }

            // set Manufacturing policy to disabled,
            //  test that gard record is not created
            ATTR_CDM_POLICIES_type l_policies =
                pSys->getAttr<ATTR_CDM_POLICIES>();
            l_policies = CDM_POLICIES_MANUFACTURING_DISABLED;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);

            // (try to) Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x12, GARD_Fatal);

            if (l_pErr)
            {
                TS_FAIL("testGard9: Error from platCreateGardRecord");
                break;
            }

            // Get the GARD Records for the target - shouldn't be any
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard9: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard9: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            // set Predictive policy to disabled
            //  test that gard record isn't created
            l_policies = CDM_POLICIES_PREDICTIVE_DISABLED;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);

            // (try to) Create a GARD Record for the target.
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_pTarget, 0x12, GARD_Predictive);

            if (l_pErr)
            {
                TS_FAIL("testGard9: Error from platCreateGardRecord");
                break;
            }

            // Get the GARD Records for the target - shouldn't be any
            l_pErr = theDeconfigGard().getGardRecords(l_pTarget, l_records);

            if (l_pErr)
            {
                TS_FAIL("testGard9: Error from getGardRecords (2)");
                break;
            }

            if (l_records.size() != 0)
            {
                TS_FAIL("testGard9: %d records for target, expected 0",
                        l_records.size());
                break;
            }

            // restore
            l_policies = 0;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);
            TS_TRACE(INFO_MRK "testGard9: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test CDM modes to restrict processing GARD records
     */
    void testGard10()
    {
        TS_TRACE(INFO_MRK "testGard10: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard10: Skipped");
#else
        HWAS_INF("testGard10: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard10: Error from getGardRecords");
                break;
            }

            if (l_records.size() > 0)
            {
                TS_FAIL("testGard10: already GARD records here. %d records",
                        l_records.size());
                break;
            }

            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard10: empty pExList");
                break;
            }

            TargetHandle_t l_target = *pExList.begin();

            // create GARD record, set Policy, call 'doGard' step and confirm
            //  target is NOT deconfigured
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_target, 0x12, GARD_Predictive);
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from platCreateGardRecord");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard10: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 1)
            {
                TS_FAIL("testGard10: should be 1 record; instead %d records",
                        l_records.size());
                break;
            }

            // set Manufacturing policy to disabled,
            //  test that gard record is not created
            ATTR_CDM_POLICIES_type l_policies =
                pSys->getAttr<ATTR_CDM_POLICIES>();
            l_policies = CDM_POLICIES_MANUFACTURING_DISABLED;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);

            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from collectGard");
                break;
            }

            HwasState l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testGard10: target NOT functional");
                break;
            }

            // set Predictive policy to disabled,
            //  test that gard record is not created
            l_policies = CDM_POLICIES_PREDICTIVE_DISABLED;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);

            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from collectGard");
                break;
            }

            l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testGard10: target NOT functional");
                break;
            }

            // Clear all GARD Records
            l_pErr = theDeconfigGard().clearGardRecords(NULL);
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from clearGardRecords(NULL)");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard10: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 0)
            {
                TS_FAIL("testGard10: should be 0 records; instead %d records",
                        l_records.size());
                break;
            }

            // create GARD record, set Policy, call 'doGard' step and confirm
            //  target is NOT deconfigured
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_target, 0x12, GARD_Predictive);
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from platCreateGardRecord");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard10: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 1)
            {
                TS_FAIL("testGard10: should be 1 records; instead %d records",
                        l_records.size());
                break;
            }

            // Clear all GARD Records
            l_pErr = theDeconfigGard().clearGardRecords(NULL);
            if (l_pErr)
            {
                TS_FAIL("testGard10: Error from clearGardRecords(NULL)");
                break;
            }

            // restore
            l_policies = 0;
            pSys->setAttr<ATTR_CDM_POLICIES>(l_policies);
            TS_TRACE(INFO_MRK "testGard10: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }

    /**
     *  @brief Test create GARD record, call collect GARD to confirm targets
     *      are deconfigured, set changed bit ala HCDB, reprocess GARD to
     *      confirm GARD record is deleted.
     */
    void testGard11()
    {
        TS_TRACE(INFO_MRK "testGard11: Started");
#if DISABLE_EX_UNIT_TESTS
        // these tests deconfigure and gard targets. and even though they
        //  restore their state after the tests, since the cxxtests are
        //  all run in parallel, during the time that a target is non-
        //  functional due to this test, another test may be running that
        //  might be adversly affected.
        // tests are left in the code so that a developer can enable them
        //  to test these specific functions - just keep in mind that there
        //  could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testGard11: Skipped");
#else
        HWAS_INF("testGard11: Started");

        errlHndl_t l_pErr = NULL;
        DeconfigGard::GardRecords_t l_records;

        do
        {
            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard11: Error from getGardRecords");
                break;
            }

            if (l_records.size() > 0)
            {
                TS_FAIL("testGard11: already GARD records here. %d records",
                        l_records.size());
                break;
            }

            // Go through all targets to ensure changed flags are cleared
            for (TargetIterator t_iter = targetService().begin();
                 t_iter != targetService().end();
                 ++t_iter)
            {
                Target* l_pTarget = *t_iter;

                // Clear bits in changed flags for the target
                ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK_type l_mask =
                    l_pTarget->
                        getAttr<ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK>();
                clear_hwas_changed_bit(l_pTarget,
                                       static_cast<HWAS_CHANGED_BIT>(l_mask));
            } // for

            // find an ex unit that we can play with
            Target * pSys;
            targetService().getTopLevelTarget(pSys);

            PredicateCTM predEx(CLASS_UNIT, TYPE_EX);
            PredicateHwas predFunctional;
            predFunctional.poweredOn(true).present(true).functional(true);
            PredicatePostfixExpr checkExpr;
            checkExpr.push(&predEx).push(&predFunctional).And();

            TargetHandleList pExList;
            targetService().getAssociated( pExList, pSys,
                TargetService::CHILD, TargetService::ALL, &checkExpr );

            if (pExList.empty())
            {
                TS_FAIL("testGard11: empty pExList");
                break;
            }

            TargetHandle_t l_target = *pExList.begin();

            // Save ATTR_BLOCK_SPEC_DECONFIG value
            TARGETING::ATTR_BLOCK_SPEC_DECONFIG_type l_orig_block_spec_deconfig
                = pSys->getAttr<ATTR_BLOCK_SPEC_DECONFIG>();

            // Allow speculative deconfigs (clear ATTR_BLOCK_SPEC_DECONFIG)
            HWAS_INF("testGard11: Allow speculative deconfigs");
            pSys->setAttr<ATTR_BLOCK_SPEC_DECONFIG>(0);

            // create GARD record, call 'doGard' step and confirm target is
            //  deconfigured
            l_pErr = theDeconfigGard().
                    platCreateGardRecord(l_target, 0x12, GARD_Predictive);
            if (l_pErr)
            {
                TS_FAIL("testGard11: Error from platCreateGardRecord");
                break;
            }

            l_pErr = theDeconfigGard().getGardRecords(NULL, l_records);
            if (l_pErr)
            {
                errlCommit(l_pErr,HWAS_COMP_ID);
                TS_FAIL("testGard11: Error from getGardRecords");
                break;
            }
            if (l_records.size() != 1)
            {
                TS_FAIL("testGard11: should be 1 record; instead %d records",
                        l_records.size());
                break;
            }

            // Note that collectGard() makes various calls, including calls of
            // clearGardRecordsForReplacedTargets() and
            // deconfigureTargetsFromGardRecordsForIpl(i_pPredicate)
            // which in turn calls clearBlockSpecDeconfigForReplacedTargets().
            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard11: Error from collectGard");
                break;
            }

            HwasState l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (l_state.functional)
            {
                TS_FAIL("testGard11: target still functional");
                break;
            }

            // Block speculative deconfigs(set ATTR_BLOCK_SPEC_DECONFIG)
            HWAS_INF("testGard11: Block speculative deconfigs");
            pSys->setAttr<ATTR_BLOCK_SPEC_DECONFIG>(1);

            // restore functional state
            l_state.functional = true;
            l_target->setAttr<ATTR_HWAS_STATE>(l_state);

            // call collectGard and confirm Block speculative deconfigs stays
            //  set and target stays functional
            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard11: Error from collectGard call 2");
                break;
            }

            TARGETING::ATTR_BLOCK_SPEC_DECONFIG_type l_block_spec_deconfig
                = pSys->getAttr<ATTR_BLOCK_SPEC_DECONFIG>();
            if(l_block_spec_deconfig == 0)
            {
                TS_FAIL("testGard11: block spec deconfig cleared");
                break;
            }

            l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testGard11: target NOT functional");
                break;
            }

            // emulate HCDB - target changed, call collectGard and confirm Block
            //  speculative deconfigs is cleared and target is deconfigured
            update_hwas_changed_mask(l_target);
            l_pErr = collectGard();
            if (l_pErr)
            {
                TS_FAIL("testGard11: Error from collectGard call 2");
                break;
            }

            l_block_spec_deconfig = pSys->getAttr<ATTR_BLOCK_SPEC_DECONFIG>();
            if(l_block_spec_deconfig != 0)
            {
                TS_FAIL("testGard11: block spec deconfig NOT cleared, is %d",
                        l_block_spec_deconfig);
                break;
            }

            l_state = l_target->getAttr<ATTR_HWAS_STATE>();
            if (!l_state.functional)
            {
                TS_FAIL("testGard11: target NOT functional");
                break;
            }

            // Restore
            l_state.functional = true;
            l_target->setAttr<ATTR_HWAS_STATE>(l_state);
            pSys->setAttr<ATTR_BLOCK_SPEC_DECONFIG>(l_orig_block_spec_deconfig);

            TS_TRACE(INFO_MRK "testGard11: Success");
        }
        while (0);

        if (l_pErr)
        {
            errlCommit(l_pErr,HWAS_COMP_ID);
        }
#endif
    }


    /**
     *  @brief Test Deconfigure Associated Proc1
     */
    void testDeconfigureAssocProc1()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc1: Started");
        HWAS_INF("testDeconfigureAssocProc1: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 1: TULETA 4 System with Master proc's abus1
        // and proc2 abus1 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_tuletaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_tuletaProcs.insert(l_tuletaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_tuletaProcs[0].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[0].procHUID = 0;                 // HUID
        l_tuletaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[0].iv_masterCapable = true;      // Master proc
        l_tuletaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        // abus1 and 2 linked to proc2
        l_tuletaProcs[0].iv_pAProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[0].iv_pAProcs[1] = &l_tuletaProcs[2];
        // abus1 endpoint deconfigured
        l_tuletaProcs[0].iv_ADeconfigured[0] = true;
        // XBus links and states
        l_tuletaProcs[0].iv_pXProcs[0] = &l_tuletaProcs[1];

        // Proc1:
        l_tuletaProcs[1].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[1].procHUID = 1;                 // HUID
        l_tuletaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[1].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[1].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[1].iv_pAProcs[0] = &l_tuletaProcs[3];
        l_tuletaProcs[1].iv_pAProcs[1] = &l_tuletaProcs[3];
        // XBus links and states
        l_tuletaProcs[1].iv_pXProcs[0] = &l_tuletaProcs[0];

        // Proc2:
        l_tuletaProcs[2].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[2].procHUID = 2;                 // HUID
        l_tuletaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[2].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[2].iv_pAProcs[0] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_pAProcs[1] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_ADeconfigured[0] = true;
        // XBus links and states
        l_tuletaProcs[2].iv_pXProcs[0] = &l_tuletaProcs[3];

        // Proc3:
        l_tuletaProcs[3].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[3].procHUID = 3;                 // HUID
        l_tuletaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[3].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[3].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[3].iv_pAProcs[0] = &l_tuletaProcs[1];
        l_tuletaProcs[3].iv_pAProcs[1] = &l_tuletaProcs[2];
        // XBus links and states
        l_tuletaProcs[3].iv_pXProcs[0] = &l_tuletaProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_tuletaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_tuletaProcs[0].iv_deconfigured == false &&
            l_tuletaProcs[1].iv_deconfigured == false &&
            l_tuletaProcs[2].iv_deconfigured == true &&
            l_tuletaProcs[3].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc1: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc1: incorrect configuration returned");
        }
    }


    /**
     *  @brief Test Deconfigure Associated Proc2
     */
    void testDeconfigureAssocProc2()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc2: Started");
        HWAS_INF("testDeconfigureAssocProc2: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 2: TULETA 4 System with Master proc's xbus1
        // and proc3's xbus1 deconfigured, where the Master is
        // proc2

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_tuletaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_tuletaProcs.insert(l_tuletaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Proc0:
        l_tuletaProcs[0].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[0].procHUID = 0;                 // HUID
        l_tuletaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[0].iv_masterCapable = false;     // Note master proc
        l_tuletaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[0].iv_pAProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[0].iv_pAProcs[1] = &l_tuletaProcs[2];
        // XBus links and states
        l_tuletaProcs[0].iv_pXProcs[0] = &l_tuletaProcs[1];

        // Proc1:
        l_tuletaProcs[1].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[1].procHUID = 1;                 // HUID
        l_tuletaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[1].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[1].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[1].iv_pAProcs[0] = &l_tuletaProcs[3];
        l_tuletaProcs[1].iv_pAProcs[1] = &l_tuletaProcs[3];
        // XBus links and states
        l_tuletaProcs[1].iv_pXProcs[0] = &l_tuletaProcs[0];

        // Proc2:
        l_tuletaProcs[2].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[2].procHUID = 2;                 // HUID
        l_tuletaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[2].iv_masterCapable = true;      // Master proc
        l_tuletaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[2].iv_pAProcs[0] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_pAProcs[1] = &l_tuletaProcs[0];
        // XBus links and states
        l_tuletaProcs[2].iv_pXProcs[0] = &l_tuletaProcs[3];
        l_tuletaProcs[2].iv_XDeconfigured[0] = true;

        // Proc3:
        l_tuletaProcs[3].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[3].procHUID = 3;                 // HUID
        l_tuletaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[3].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[3].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[3].iv_pAProcs[0] = &l_tuletaProcs[1];
        l_tuletaProcs[3].iv_pAProcs[1] = &l_tuletaProcs[1];
        // XBus links and states
        l_tuletaProcs[3].iv_pXProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[3].iv_XDeconfigured[0] = true;

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_tuletaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_tuletaProcs[0].iv_deconfigured == false &&
            l_tuletaProcs[1].iv_deconfigured == true &&
            l_tuletaProcs[2].iv_deconfigured == false &&
            l_tuletaProcs[3].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc2: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc2: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc3
     */
    void testDeconfigureAssocProc3()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc3: Started");
        HWAS_INF("testDeconfigureAssocProc3: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 3: ORLENA System with Master and proc1's
        // xbus1 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 8;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_orlenaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_orlenaProcs.insert(l_orlenaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Proc0:
        l_orlenaProcs[0].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[0].procHUID = 0;                 // HUID
        l_orlenaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[0].iv_masterCapable = true;      // Master proc
        l_orlenaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[0].iv_pAProcs[0] = &l_orlenaProcs[2];
        l_orlenaProcs[0].iv_pAProcs[1] = &l_orlenaProcs[4];
        l_orlenaProcs[0].iv_pAProcs[2] = &l_orlenaProcs[6];
        // XBus links and states
        l_orlenaProcs[0].iv_pXProcs[0] = &l_orlenaProcs[1];
        l_orlenaProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_orlenaProcs[1].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[1].procHUID = 1;                 // HUID
        l_orlenaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[1].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[1].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[1].iv_pAProcs[0] = &l_orlenaProcs[5];
        l_orlenaProcs[1].iv_pAProcs[1] = &l_orlenaProcs[7];
        l_orlenaProcs[1].iv_pAProcs[2] = &l_orlenaProcs[3];
        // XBus links and states
        l_orlenaProcs[1].iv_pXProcs[0] = &l_orlenaProcs[0];
        l_orlenaProcs[1].iv_XDeconfigured[0] = true;

        // Proc2:
        l_orlenaProcs[2].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[2].procHUID = 2;                 // HUID
        l_orlenaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[2].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[2].iv_pAProcs[0] = &l_orlenaProcs[0];
        l_orlenaProcs[2].iv_pAProcs[1] = &l_orlenaProcs[6];
        l_orlenaProcs[2].iv_pAProcs[2] = &l_orlenaProcs[4];
        // XBus links and states
        l_orlenaProcs[2].iv_pXProcs[0] = &l_orlenaProcs[3];

        // Proc3:
        l_orlenaProcs[3].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[3].procHUID = 3;                 // HUID
        l_orlenaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[3].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[3].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[3].iv_pAProcs[0] = &l_orlenaProcs[7];
        l_orlenaProcs[3].iv_pAProcs[1] = &l_orlenaProcs[5];
        l_orlenaProcs[3].iv_pAProcs[2] = &l_orlenaProcs[1];
        // XBus links and states
        l_orlenaProcs[3].iv_pXProcs[0] = &l_orlenaProcs[2];

        // Proc4:
        l_orlenaProcs[4].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[4].procHUID = 4;                 // HUID
        l_orlenaProcs[4].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[4].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[4].iv_masterCapable = false;      // Master proc
        l_orlenaProcs[4].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[4].iv_pAProcs[0] = &l_orlenaProcs[6];
        l_orlenaProcs[4].iv_pAProcs[1] = &l_orlenaProcs[0];
        l_orlenaProcs[4].iv_pAProcs[2] = &l_orlenaProcs[2];
        // XBus links and states
        l_orlenaProcs[4].iv_pXProcs[0] = &l_orlenaProcs[5];

        // Proc5:
        l_orlenaProcs[5].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[5].procHUID = 5;                 // HUID
        l_orlenaProcs[5].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[5].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[5].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[5].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[5].iv_pAProcs[0] = &l_orlenaProcs[1];
        l_orlenaProcs[5].iv_pAProcs[1] = &l_orlenaProcs[3];
        l_orlenaProcs[5].iv_pAProcs[2] = &l_orlenaProcs[7];
        // XBus links and states
        l_orlenaProcs[5].iv_pXProcs[0] = &l_orlenaProcs[4];

        // Proc6:
        l_orlenaProcs[6].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[6].procHUID = 6;                 // HUID
        l_orlenaProcs[6].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[6].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[6].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[6].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[6].iv_pAProcs[0] = &l_orlenaProcs[4];
        l_orlenaProcs[6].iv_pAProcs[1] = &l_orlenaProcs[2];
        l_orlenaProcs[6].iv_pAProcs[2] = &l_orlenaProcs[0];
        // XBus links and states
        l_orlenaProcs[6].iv_pXProcs[0] = &l_orlenaProcs[7];

        // Proc7:
        l_orlenaProcs[7].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[7].procHUID = 7;                 // HUID
        l_orlenaProcs[7].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[7].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[7].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[7].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[7].iv_pAProcs[0] = &l_orlenaProcs[3];
        l_orlenaProcs[7].iv_pAProcs[1] = &l_orlenaProcs[1];
        l_orlenaProcs[7].iv_pAProcs[2] = &l_orlenaProcs[5];
        // XBus links and states
        l_orlenaProcs[7].iv_pXProcs[0] = &l_orlenaProcs[6];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_orlenaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_orlenaProcs[0].iv_deconfigured == false &&
            l_orlenaProcs[1].iv_deconfigured == true &&
            l_orlenaProcs[2].iv_deconfigured == false &&
            l_orlenaProcs[3].iv_deconfigured == true &&
            l_orlenaProcs[4].iv_deconfigured == false &&
            l_orlenaProcs[5].iv_deconfigured == true &&
            l_orlenaProcs[6].iv_deconfigured == false &&
            l_orlenaProcs[7].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc3: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc3: incorrect configuration returned");
        }
    }


    /**
     *  @brief Test Deconfigure Associated Proc4
     */
    void testDeconfigureAssocProc4()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc4: Started");
        HWAS_INF("testDeconfigureAssocProc4: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 4: ORLENA System with proc6/7xbus1 and
        // proc2/4 abus2 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 8;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_orlenaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_orlenaProcs.insert(l_orlenaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Proc0:
        l_orlenaProcs[0].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[0].procHUID = 0;                 // HUID
        l_orlenaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[0].iv_masterCapable = true;      // Master proc
        l_orlenaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[0].iv_pAProcs[0] = &l_orlenaProcs[2];
        l_orlenaProcs[0].iv_pAProcs[1] = &l_orlenaProcs[4];
        l_orlenaProcs[0].iv_pAProcs[2] = &l_orlenaProcs[6];
        // XBus links and states
        l_orlenaProcs[0].iv_pXProcs[0] = &l_orlenaProcs[1];

        // Proc1:
        l_orlenaProcs[1].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[1].procHUID = 1;                 // HUID
        l_orlenaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[1].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[1].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[1].iv_pAProcs[0] = &l_orlenaProcs[5];
        l_orlenaProcs[1].iv_pAProcs[1] = &l_orlenaProcs[7];
        l_orlenaProcs[1].iv_pAProcs[2] = &l_orlenaProcs[3];
        // XBus links and states
        l_orlenaProcs[1].iv_pXProcs[0] = &l_orlenaProcs[0];

        // Proc2:
        l_orlenaProcs[2].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[2].procHUID = 2;                 // HUID
        l_orlenaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[2].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[2].iv_pAProcs[0] = &l_orlenaProcs[0];
        l_orlenaProcs[2].iv_pAProcs[1] = &l_orlenaProcs[6];
        l_orlenaProcs[2].iv_pAProcs[2] = &l_orlenaProcs[4];
        l_orlenaProcs[2].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[2].iv_pXProcs[0] = &l_orlenaProcs[3];

        // Proc3:
        l_orlenaProcs[3].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[3].procHUID = 3;                 // HUID
        l_orlenaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[3].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[3].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[3].iv_pAProcs[0] = &l_orlenaProcs[7];
        l_orlenaProcs[3].iv_pAProcs[1] = &l_orlenaProcs[5];
        l_orlenaProcs[3].iv_pAProcs[2] = &l_orlenaProcs[1];
        // XBus links and states
        l_orlenaProcs[3].iv_pXProcs[0] = &l_orlenaProcs[2];

        // Proc4:
        l_orlenaProcs[4].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[4].procHUID = 4;                 // HUID
        l_orlenaProcs[4].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[4].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[4].iv_masterCapable = false;      // Master proc
        l_orlenaProcs[4].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[4].iv_pAProcs[0] = &l_orlenaProcs[6];
        l_orlenaProcs[4].iv_pAProcs[1] = &l_orlenaProcs[0];
        l_orlenaProcs[4].iv_pAProcs[2] = &l_orlenaProcs[2];
        l_orlenaProcs[4].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[4].iv_pXProcs[0] = &l_orlenaProcs[5];

        // Proc5:
        l_orlenaProcs[5].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[5].procHUID = 5;                 // HUID
        l_orlenaProcs[5].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[5].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[5].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[5].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[5].iv_pAProcs[0] = &l_orlenaProcs[1];
        l_orlenaProcs[5].iv_pAProcs[1] = &l_orlenaProcs[3];
        l_orlenaProcs[5].iv_pAProcs[2] = &l_orlenaProcs[7];
        // XBus links and states
        l_orlenaProcs[5].iv_pXProcs[0] = &l_orlenaProcs[4];

        // Proc6:
        l_orlenaProcs[6].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[6].procHUID = 6;                 // HUID
        l_orlenaProcs[6].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[6].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[6].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[6].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[6].iv_pAProcs[0] = &l_orlenaProcs[4];
        l_orlenaProcs[6].iv_pAProcs[1] = &l_orlenaProcs[2];
        l_orlenaProcs[6].iv_pAProcs[2] = &l_orlenaProcs[0];
        // XBus links and states
        l_orlenaProcs[6].iv_pXProcs[0] = &l_orlenaProcs[7];
        l_orlenaProcs[6].iv_XDeconfigured[0] = true;

        // Proc7:
        l_orlenaProcs[7].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[7].procHUID = 7;                 // HUID
        l_orlenaProcs[7].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[7].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[7].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[7].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[7].iv_pAProcs[0] = &l_orlenaProcs[3];
        l_orlenaProcs[7].iv_pAProcs[1] = &l_orlenaProcs[1];
        l_orlenaProcs[7].iv_pAProcs[2] = &l_orlenaProcs[5];
        // XBus links and states
        l_orlenaProcs[7].iv_pXProcs[0] = &l_orlenaProcs[6];
        l_orlenaProcs[7].iv_XDeconfigured[0] = true;

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_orlenaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_orlenaProcs[0].iv_deconfigured == false &&
            l_orlenaProcs[1].iv_deconfigured == false &&
            l_orlenaProcs[2].iv_deconfigured == false &&
            l_orlenaProcs[3].iv_deconfigured == false &&
            l_orlenaProcs[4].iv_deconfigured == true &&
            l_orlenaProcs[5].iv_deconfigured == true &&
            l_orlenaProcs[6].iv_deconfigured == true &&
            l_orlenaProcs[7].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc4: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc4: incorrect configuration returned");
        }
    }


    /**
     *  @brief Test Deconfigure Associated Proc5
     */
    void testDeconfigureAssocProc5()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc5: Started");
        HWAS_INF("testDeconfigureAssocProc5: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 5: ORLENA System with proc4 deconfigured (and
        // proc4's chiplets and peers deconfigured by association),
        // and proc5-abus2 / proc7-abus2 deconfigured.

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 8;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_orlenaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_orlenaProcs.insert(l_orlenaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Proc0:
        l_orlenaProcs[0].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[0].procHUID = 0;                 // HUID
        l_orlenaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[0].iv_masterCapable = true;      // Master proc
        l_orlenaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[0].iv_pAProcs[0] = &l_orlenaProcs[2];
        l_orlenaProcs[0].iv_pAProcs[1] = &l_orlenaProcs[4];
        l_orlenaProcs[0].iv_pAProcs[2] = &l_orlenaProcs[6];
        l_orlenaProcs[4].iv_ADeconfigured[1] = true;
        // XBus links and states
        l_orlenaProcs[0].iv_pXProcs[0] = &l_orlenaProcs[1];

        // Proc1:
        l_orlenaProcs[1].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[1].procHUID = 1;                 // HUID
        l_orlenaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_orlenaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[1].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[1].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[1].iv_pAProcs[0] = &l_orlenaProcs[5];
        l_orlenaProcs[1].iv_pAProcs[1] = &l_orlenaProcs[7];
        l_orlenaProcs[1].iv_pAProcs[2] = &l_orlenaProcs[3];
        // XBus links and states
        l_orlenaProcs[1].iv_pXProcs[0] = &l_orlenaProcs[0];

        // Proc2:
        l_orlenaProcs[2].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[2].procHUID = 2;                 // HUID
        l_orlenaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[2].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[2].iv_pAProcs[0] = &l_orlenaProcs[0];
        l_orlenaProcs[2].iv_pAProcs[1] = &l_orlenaProcs[6];
        l_orlenaProcs[2].iv_pAProcs[2] = &l_orlenaProcs[4];
        l_orlenaProcs[2].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[2].iv_pXProcs[0] = &l_orlenaProcs[3];

        // Proc3:
        l_orlenaProcs[3].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[3].procHUID = 3;                 // HUID
        l_orlenaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_orlenaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[3].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[3].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[3].iv_pAProcs[0] = &l_orlenaProcs[7];
        l_orlenaProcs[3].iv_pAProcs[1] = &l_orlenaProcs[5];
        l_orlenaProcs[3].iv_pAProcs[2] = &l_orlenaProcs[1];
        // XBus links and states
        l_orlenaProcs[3].iv_pXProcs[0] = &l_orlenaProcs[2];

        // Proc4:
        l_orlenaProcs[4].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[4].procHUID = 4;                 // HUID
        l_orlenaProcs[4].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[4].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[4].iv_masterCapable = false;      // Master proc
        l_orlenaProcs[4].iv_deconfigured = true;      // HWAS state
        // ABus links and states
        l_orlenaProcs[4].iv_pAProcs[0] = &l_orlenaProcs[6];
        l_orlenaProcs[4].iv_pAProcs[1] = &l_orlenaProcs[0];
        l_orlenaProcs[4].iv_pAProcs[2] = &l_orlenaProcs[2];
        l_orlenaProcs[4].iv_ADeconfigured[0] = true;
        l_orlenaProcs[4].iv_ADeconfigured[1] = true;
        l_orlenaProcs[4].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[4].iv_pXProcs[0] = &l_orlenaProcs[5];
        l_orlenaProcs[4].iv_XDeconfigured[0] = true;

        // Proc5:
        l_orlenaProcs[5].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[5].procHUID = 5;                 // HUID
        l_orlenaProcs[5].procFabricGroup = 2;          // FABRIC_GROUP_ID
        l_orlenaProcs[5].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[5].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[5].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[5].iv_pAProcs[0] = &l_orlenaProcs[1];
        l_orlenaProcs[5].iv_pAProcs[1] = &l_orlenaProcs[3];
        l_orlenaProcs[5].iv_pAProcs[2] = &l_orlenaProcs[7];
        l_orlenaProcs[5].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[5].iv_pXProcs[0] = &l_orlenaProcs[4];
        l_orlenaProcs[5].iv_XDeconfigured[0] = true;

        // Proc6:
        l_orlenaProcs[6].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[6].procHUID = 6;                 // HUID
        l_orlenaProcs[6].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[6].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_orlenaProcs[6].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[6].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[6].iv_pAProcs[0] = &l_orlenaProcs[4];
        l_orlenaProcs[6].iv_pAProcs[1] = &l_orlenaProcs[2];
        l_orlenaProcs[6].iv_pAProcs[2] = &l_orlenaProcs[0];
        l_orlenaProcs[6].iv_ADeconfigured[0] = true;
        // XBus links and states
        l_orlenaProcs[6].iv_pXProcs[0] = &l_orlenaProcs[7];

        // Proc7:
        l_orlenaProcs[7].iv_pThisProc = NULL;          // Target *
        l_orlenaProcs[7].procHUID = 7;                 // HUID
        l_orlenaProcs[7].procFabricGroup = 3;          // FABRIC_GROUP_ID
        l_orlenaProcs[7].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_orlenaProcs[7].iv_masterCapable = false;     // Not master proc
        l_orlenaProcs[7].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_orlenaProcs[7].iv_pAProcs[0] = &l_orlenaProcs[3];
        l_orlenaProcs[7].iv_pAProcs[1] = &l_orlenaProcs[1];
        l_orlenaProcs[7].iv_pAProcs[2] = &l_orlenaProcs[5];
        l_orlenaProcs[7].iv_ADeconfigured[2] = true;
        // XBus links and states
        l_orlenaProcs[7].iv_pXProcs[0] = &l_orlenaProcs[6];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_orlenaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_orlenaProcs[0].iv_deconfigured == false &&
            l_orlenaProcs[1].iv_deconfigured == false &&
            l_orlenaProcs[2].iv_deconfigured == false &&
            l_orlenaProcs[3].iv_deconfigured == false &&
            l_orlenaProcs[4].iv_deconfigured == true &&
            l_orlenaProcs[5].iv_deconfigured == true &&
            l_orlenaProcs[6].iv_deconfigured == false &&
            l_orlenaProcs[7].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc5: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc5: incorrect configuration returned");
        }
    }


    /**
     *  @brief Test Deconfigure Associated Proc6
     */
    void testDeconfigureAssocProc6()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc6: Started");
        HWAS_INF("testDeconfigureAssocProc6: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 6: BRAZOS System with proc0xbus0
        // and proc1xbus3 deconfigured
        // Note that procs in BRAZOS have xbus0,xbus1,
        // and xbus3 chiplets as defined by the mrw.xml file.

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_brazosProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_brazosProcs.insert(l_brazosProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_brazosProcs[0].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[0].procHUID = 0;                 // HUID
        l_brazosProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_brazosProcs[0].iv_masterCapable = true;      // Master proc
        l_brazosProcs[0].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[0].iv_pXProcs[0] = &l_brazosProcs[1];
        l_brazosProcs[0].iv_pXProcs[1] = &l_brazosProcs[2];
        l_brazosProcs[0].iv_pXProcs[3] = &l_brazosProcs[3];
        l_brazosProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_brazosProcs[1].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[1].procHUID = 1;                 // HUID
        l_brazosProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_brazosProcs[1].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[1].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        // XBus links and states
        l_brazosProcs[1].iv_pXProcs[0] = &l_brazosProcs[2];
        l_brazosProcs[1].iv_pXProcs[1] = &l_brazosProcs[3];
        l_brazosProcs[1].iv_pXProcs[3] = &l_brazosProcs[0];
        l_brazosProcs[1].iv_XDeconfigured[3] = true;

        // Proc2:
        l_brazosProcs[2].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[2].procHUID = 2;                 // HUID
        l_brazosProcs[2].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[2].procFabricChip = 2;           // FABRIC_CHIP_ID
        l_brazosProcs[2].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[2].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[2].iv_pXProcs[0] = &l_brazosProcs[3];
        l_brazosProcs[2].iv_pXProcs[1] = &l_brazosProcs[0];
        l_brazosProcs[2].iv_pXProcs[3] = &l_brazosProcs[1];

        // Proc3:
        l_brazosProcs[3].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[3].procHUID = 3;                 // HUID
        l_brazosProcs[3].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[3].procFabricChip = 3;           // FABRIC_CHIP_ID
        l_brazosProcs[3].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[3].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[3].iv_pXProcs[0] = &l_brazosProcs[0];
        l_brazosProcs[3].iv_pXProcs[1] = &l_brazosProcs[1];
        l_brazosProcs[3].iv_pXProcs[3] = &l_brazosProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_brazosProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_brazosProcs[0].iv_deconfigured == false &&
            l_brazosProcs[1].iv_deconfigured == true &&
            l_brazosProcs[2].iv_deconfigured == false &&
            l_brazosProcs[3].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc6: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc6: incorrect configuration returned");
        }
    }


    /**
     *  @brief Test Deconfigure Associated Proc7
     */
    void testDeconfigureAssocProc7()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc7: Started");
#if DISABLE_UNIT_TESTS
        // This test deconfigures proc2-xbus1 and proc3-xbus1 in a
        // TULETA-2S4U system. Even though this test
        // restores their states after the test, since the cxxtests are
        // all run in parallel, during the time that a target is non-
        // functional due to this test, another test may be running that
        // might be adversly affected.
        // tests are left in the code so that a developer can enable them
        // to test these specific functions - just keep in mind that there
        // could be side effects in other cxxtests.
        TS_TRACE( " - SKIPPING -- other tests could be adversly affected");
        HWAS_INF("testDeconfigureAssocProc7: Skipped");
#else
        HWAS_INF("testDeconfigureAssocProc7: Started");

        errlHndl_t l_pErr = NULL;

        do
        {
            // Define and populate vector of present procs
            // Get top level target
            TARGETING::Target * l_pSys;
            TARGETING::targetService().getTopLevelTarget(l_pSys);
            // Define predicate
            TARGETING::PredicateCTM predProc(TARGETING::CLASS_CHIP,
                                             TARGETING::TYPE_PROC);
            TARGETING::PredicateHwas predPres;
            predPres.present(true);
            TARGETING::PredicatePostfixExpr presProc;
            presProc.push(&predProc).push(&predPres).And();
            // Populate vector
            TARGETING::TargetHandleList l_presProcs;
            TARGETING::targetService().getAssociated(l_presProcs,
                                                     l_pSys,
                                            TARGETING::TargetService::CHILD,
                                            TARGETING::TargetService::ALL,
                                            &presProc);
            // Define HUIDs of targets to deconfigure based on
            // 4-proc configuration in simics_MURANO.system.xml
            ATTR_HUID_type l_proc2Xbus1HUID = 0x000E0009;
            ATTR_HUID_type l_proc3Xbus1HUID = 0x000E000D;
            // Define targeting*'s corresponding to HUIDs above
            TARGETING::Target * l_pProc2Xbus1;
            TARGETING::Target * l_pProc3Xbus1;
            // Define targets' original states corresponding to HUIDs above
            HwasState l_proc2Xbus1OrigState;
            HwasState l_proc3Xbus1OrigState;
            // Define vector of present bus endpoint chiplets
            TARGETING::PredicateCTM predXbus(TARGETING::CLASS_UNIT,
                                             TARGETING::TYPE_XBUS);
            TARGETING::PredicateCTM predAbus(TARGETING::CLASS_UNIT,
                                             TARGETING::TYPE_ABUS);
            TARGETING::PredicatePostfixExpr busPres;
            busPres.push(&predXbus).push(&predAbus).Or().push(&predPres).And();
            // Counter to keep track of deconfigureTarget calls
            uint8_t deconfigureTargetCallCounter = 0;
            // Iterate through present procs
            for (TARGETING::TargetHandleList::const_iterator
                 l_procsIter = l_presProcs.begin();
                 l_procsIter != l_presProcs.end();
                 ++l_procsIter)
            {
                // Populate vector of bus endpoints associated with this proc
                TARGETING::TargetHandleList l_presentBusChiplets;
                TARGETING::targetService().getAssociated(l_presentBusChiplets,
                                             (*l_procsIter),
                                             TARGETING::TargetService::CHILD,
                                             TARGETING::TargetService::ALL,
                                             &busPres);

                // Iterate through present bus endpoint chiplets
                for (TARGETING::TargetHandleList::iterator
                     l_busIter = l_presentBusChiplets.begin();
                     l_busIter != l_presentBusChiplets.end();
                     ++l_busIter)
                {
                    if (l_proc2Xbus1HUID == get_huid(*l_busIter))
                    {
                        // Save target
                        l_pProc2Xbus1 = (*l_busIter);
                        // Get the original HWAS_STATE of the target
                        l_proc2Xbus1OrigState = l_pProc2Xbus1->
                                    getAttr<ATTR_HWAS_STATE>();
                        // Deconfigure the target.
                        l_pErr = theDeconfigGard().
                                deconfigureTarget(*l_pProc2Xbus1,
                                    DeconfigGard::DECONFIGURED_BY_BUS_DECONFIG);
                        if (l_pErr)
                        {
                            TS_FAIL("testDeconfigureAssocProc7: "
                            "Could not deconfigure proc2xbus1");
                            break;
                        }
                        deconfigureTargetCallCounter++;
                    }
                    if (l_proc3Xbus1HUID == get_huid(*l_busIter))
                    {
                        // Save target
                        l_pProc3Xbus1 = (*l_busIter);
                        // Get the original HWAS_STATE of the target
                        l_proc3Xbus1OrigState = l_pProc3Xbus1->
                                    getAttr<ATTR_HWAS_STATE>();
                        // Deconfigure the target.
                        l_pErr = theDeconfigGard().
                                deconfigureTarget(*l_pProc3Xbus1,
                                    DeconfigGard::DECONFIGURED_BY_BUS_DECONFIG);
                        if (l_pErr)
                        {
                            TS_FAIL("testDeconfigureAssocProc7: "
                            "Could not deconfigure proc3xbus1");
                            break;
                        }
                        deconfigureTargetCallCounter++;
                    }
                }
            }
            // If both targets were deconfigured
            if (2 == deconfigureTargetCallCounter)
            {
                // Call deconfigureAssocProc()
                l_pErr = theDeconfigGard().deconfigureAssocProc();
                if (l_pErr)
                {
                    TS_FAIL("testDeconfigureAssocProc7: "
                            "Error from deconfigureAssocProc");
                            break;
                }
                TS_TRACE(INFO_MRK "testDeconfigureAssocProc7: Success");
                // Reset the HWAS_STATE of the targets
                l_pProc2Xbus1->setAttr<ATTR_HWAS_STATE>(l_proc2Xbus1OrigState);
                l_pProc3Xbus1->setAttr<ATTR_HWAS_STATE>(l_proc3Xbus1OrigState);
            }
            else
            {
                TS_FAIL("testDeconfigureAssocProc7: "
                "Not all xbuses were deconfigured");
            }
        }while (0);
#endif
    }



    /**
     *  @brief Test Deconfigure Associated Proc8
     */
    void testDeconfigureAssocProc8()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc8: Started");
        HWAS_INF("testDeconfigureAssocProc8: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 1: TULETA 4 System with proc2, proc3 and
        // all associated bus endpoints deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_tuletaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_tuletaProcs.insert(l_tuletaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_tuletaProcs[0].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[0].procHUID = 0;                 // HUID
        l_tuletaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[0].iv_masterCapable = true;      // Master proc
        l_tuletaProcs[0].iv_deconfigured = false;      // HWAS state
        l_tuletaProcs[0].iv_pAProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[0].iv_pAProcs[1] = &l_tuletaProcs[2];
        l_tuletaProcs[0].iv_ADeconfigured[0] = true;
        l_tuletaProcs[0].iv_ADeconfigured[1] = true;
        l_tuletaProcs[0].iv_pXProcs[0] = &l_tuletaProcs[1];

        // Proc1:
        l_tuletaProcs[1].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[1].procHUID = 1;                 // HUID
        l_tuletaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[1].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[1].iv_deconfigured = false;      // HWAS state
        l_tuletaProcs[1].iv_pAProcs[0] = &l_tuletaProcs[3];
        l_tuletaProcs[1].iv_pAProcs[1] = &l_tuletaProcs[3];
        l_tuletaProcs[1].iv_ADeconfigured[0] = true;
        l_tuletaProcs[1].iv_ADeconfigured[1] = true;
        l_tuletaProcs[1].iv_pXProcs[0] = &l_tuletaProcs[0];

        // Proc2:
        l_tuletaProcs[2].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[2].procHUID = 2;                 // HUID
        l_tuletaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[2].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[2].iv_deconfigured = true;      // HWAS state
        l_tuletaProcs[2].iv_pAProcs[0] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_pAProcs[1] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_ADeconfigured[0] = true;
        l_tuletaProcs[2].iv_ADeconfigured[1] = true;
        l_tuletaProcs[2].iv_pXProcs[0] = &l_tuletaProcs[3];
        l_tuletaProcs[2].iv_XDeconfigured[0] = true;


        // Proc3:
        l_tuletaProcs[3].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[3].procHUID = 3;                 // HUID
        l_tuletaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[3].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[3].iv_deconfigured = true;      // HWAS state
        l_tuletaProcs[3].iv_pAProcs[0] = &l_tuletaProcs[1];
        l_tuletaProcs[3].iv_pAProcs[1] = &l_tuletaProcs[2];
        l_tuletaProcs[3].iv_ADeconfigured[0] = true;
        l_tuletaProcs[3].iv_ADeconfigured[1] = true;
        l_tuletaProcs[3].iv_pXProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[3].iv_XDeconfigured[0] = true;


        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_tuletaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_tuletaProcs[0].iv_deconfigured == false &&
            l_tuletaProcs[1].iv_deconfigured == false &&
            l_tuletaProcs[2].iv_deconfigured == true &&
            l_tuletaProcs[3].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc8: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc8: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc9
     */
    void testDeconfigureAssocProc9()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc9: Started");
        HWAS_INF("testDeconfigureAssocProc9: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO 1: TULETA 4 System with Proc 3 NP which is indicated by
        // No Abus endpoints on Proc 1 and 3 and no Xbus endpoint on Proc1

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_tuletaProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_tuletaProcs.insert(l_tuletaProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_tuletaProcs[0].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[0].procHUID = 0;                 // HUID
        l_tuletaProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[0].iv_masterCapable = true;      // Master proc
        l_tuletaProcs[0].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[0].iv_pAProcs[0] = &l_tuletaProcs[2];
        l_tuletaProcs[0].iv_pAProcs[1] = &l_tuletaProcs[2];
        // XBus links and states
        l_tuletaProcs[0].iv_pXProcs[0] = &l_tuletaProcs[1];

        // Proc1:
        l_tuletaProcs[1].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[1].procHUID = 1;                 // HUID
        l_tuletaProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_tuletaProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[1].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[1].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_tuletaProcs[1].iv_pXProcs[0] = &l_tuletaProcs[0];

        // Proc2:
        l_tuletaProcs[2].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[2].procHUID = 2;                 // HUID
        l_tuletaProcs[2].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[2].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_tuletaProcs[2].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[2].iv_deconfigured = false;      // HWAS state
        // ABus links and states
        l_tuletaProcs[2].iv_pAProcs[0] = &l_tuletaProcs[0];
        l_tuletaProcs[2].iv_pAProcs[1] = &l_tuletaProcs[0];
        // No xbus because proc3 is "not present"

        // Proc3:
        l_tuletaProcs[3].iv_pThisProc = NULL;          // Target *
        l_tuletaProcs[3].procHUID = 3;                 // HUID
        l_tuletaProcs[3].procFabricGroup = 1;          // FABRIC_GROUP_ID
        l_tuletaProcs[3].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_tuletaProcs[3].iv_masterCapable = false;     // Not master proc
        l_tuletaProcs[3].iv_deconfigured = true;      // HWAS state
        // Xbus links still has xbus to proc 2 because proc 2 is functional
        l_tuletaProcs[3].iv_pXProcs[0] = &l_tuletaProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_tuletaProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_tuletaProcs[0].iv_deconfigured == false &&
            l_tuletaProcs[1].iv_deconfigured == false &&
            l_tuletaProcs[2].iv_deconfigured == true &&
            l_tuletaProcs[3].iv_deconfigured == true)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc9: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc9: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc10
     */
    void testDeconfigureAssocProc10()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc10: Started");
        HWAS_INF("testDeconfigureAssocProc10: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO: Single node, 2 master procs (one master, one alternate)
        // System with proc0xbus0 and proc1xbus3 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_brazosProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_brazosProcs.insert(l_brazosProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_brazosProcs[0].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[0].procHUID = 0;                 // HUID
        l_brazosProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_brazosProcs[0].iv_masterCapable = true;      // Master proc
        l_brazosProcs[0].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[0].iv_pXProcs[0] = &l_brazosProcs[1];
        l_brazosProcs[0].iv_pXProcs[1] = &l_brazosProcs[2];
        l_brazosProcs[0].iv_pXProcs[3] = &l_brazosProcs[3];
        l_brazosProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_brazosProcs[1].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[1].procHUID = 1;                 // HUID
        l_brazosProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_brazosProcs[1].iv_masterCapable = true;     // Not master proc
        l_brazosProcs[1].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        // XBus links and states
        l_brazosProcs[1].iv_pXProcs[0] = &l_brazosProcs[2];
        l_brazosProcs[1].iv_pXProcs[1] = &l_brazosProcs[3];
        l_brazosProcs[1].iv_pXProcs[3] = &l_brazosProcs[0];
        l_brazosProcs[1].iv_XDeconfigured[3] = true;

        // Proc2:
        l_brazosProcs[2].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[2].procHUID = 2;                 // HUID
        l_brazosProcs[2].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[2].procFabricChip = 2;           // FABRIC_CHIP_ID
        l_brazosProcs[2].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[2].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[2].iv_pXProcs[0] = &l_brazosProcs[3];
        l_brazosProcs[2].iv_pXProcs[1] = &l_brazosProcs[0];
        l_brazosProcs[2].iv_pXProcs[3] = &l_brazosProcs[1];

        // Proc3:
        l_brazosProcs[3].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[3].procHUID = 3;                 // HUID
        l_brazosProcs[3].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[3].procFabricChip = 3;           // FABRIC_CHIP_ID
        l_brazosProcs[3].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[3].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[3].iv_pXProcs[0] = &l_brazosProcs[0];
        l_brazosProcs[3].iv_pXProcs[1] = &l_brazosProcs[1];
        l_brazosProcs[3].iv_pXProcs[3] = &l_brazosProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_brazosProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_brazosProcs[0].iv_deconfigured == false &&
            l_brazosProcs[1].iv_deconfigured == true &&
            l_brazosProcs[2].iv_deconfigured == false &&
            l_brazosProcs[3].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc10: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc10: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc11
     */
    void testDeconfigureAssocProc11()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc11: Started");
        HWAS_INF("testDeconfigureAssocProc11: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO: Single node, 2 master procs (one master, one alternate)
        // System with master proc, proc0xbus0 and proc1xbus3 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_brazosProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_brazosProcs.insert(l_brazosProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_brazosProcs[0].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[0].procHUID = 0;                 // HUID
        l_brazosProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_brazosProcs[0].iv_masterCapable = true;      // Master proc
        l_brazosProcs[0].iv_deconfigured = true;      // HWAS state
        // XBus links and states
        l_brazosProcs[0].iv_pXProcs[0] = &l_brazosProcs[1];
        l_brazosProcs[0].iv_pXProcs[1] = &l_brazosProcs[2];
        l_brazosProcs[0].iv_pXProcs[3] = &l_brazosProcs[3];
        l_brazosProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_brazosProcs[1].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[1].procHUID = 1;                 // HUID
        l_brazosProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_brazosProcs[1].iv_masterCapable = true;     // Not master proc
        l_brazosProcs[1].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        // XBus links and states
        l_brazosProcs[1].iv_pXProcs[0] = &l_brazosProcs[2];
        l_brazosProcs[1].iv_pXProcs[1] = &l_brazosProcs[3];
        l_brazosProcs[1].iv_pXProcs[3] = &l_brazosProcs[0];
        l_brazosProcs[1].iv_XDeconfigured[3] = true;

        // Proc2:
        l_brazosProcs[2].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[2].procHUID = 2;                 // HUID
        l_brazosProcs[2].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[2].procFabricChip = 2;           // FABRIC_CHIP_ID
        l_brazosProcs[2].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[2].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[2].iv_pXProcs[0] = &l_brazosProcs[3];
        l_brazosProcs[2].iv_pXProcs[1] = &l_brazosProcs[0];
        l_brazosProcs[2].iv_pXProcs[3] = &l_brazosProcs[1];

        // Proc3:
        l_brazosProcs[3].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[3].procHUID = 3;                 // HUID
        l_brazosProcs[3].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[3].procFabricChip = 3;           // FABRIC_CHIP_ID
        l_brazosProcs[3].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[3].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[3].iv_pXProcs[0] = &l_brazosProcs[0];
        l_brazosProcs[3].iv_pXProcs[1] = &l_brazosProcs[1];
        l_brazosProcs[3].iv_pXProcs[3] = &l_brazosProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_brazosProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_brazosProcs[0].iv_deconfigured == true &&
            l_brazosProcs[1].iv_deconfigured == false &&
            l_brazosProcs[2].iv_deconfigured == false &&
            l_brazosProcs[3].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc11: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc11: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc12
     */
    void testDeconfigureAssocProc12()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc12: Started");
        HWAS_INF("testDeconfigureAssocProc12: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO: Single node, 2 master procs (one master, one alternate)
        // System with alt master proc, proc0xbus0 and proc1xbus3 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_brazosProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_brazosProcs.insert(l_brazosProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_brazosProcs[0].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[0].procHUID = 0;                 // HUID
        l_brazosProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_brazosProcs[0].iv_masterCapable = true;      // Master proc
        l_brazosProcs[0].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[0].iv_pXProcs[0] = &l_brazosProcs[1];
        l_brazosProcs[0].iv_pXProcs[1] = &l_brazosProcs[2];
        l_brazosProcs[0].iv_pXProcs[3] = &l_brazosProcs[3];
        l_brazosProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_brazosProcs[1].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[1].procHUID = 1;                 // HUID
        l_brazosProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_brazosProcs[1].iv_masterCapable = true;     // Not master proc
        l_brazosProcs[1].iv_deconfigured = true;      // HWAS state
        // XBus links and states
        // XBus links and states
        l_brazosProcs[1].iv_pXProcs[0] = &l_brazosProcs[2];
        l_brazosProcs[1].iv_pXProcs[1] = &l_brazosProcs[3];
        l_brazosProcs[1].iv_pXProcs[3] = &l_brazosProcs[0];
        l_brazosProcs[1].iv_XDeconfigured[3] = true;

        // Proc2:
        l_brazosProcs[2].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[2].procHUID = 2;                 // HUID
        l_brazosProcs[2].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[2].procFabricChip = 2;           // FABRIC_CHIP_ID
        l_brazosProcs[2].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[2].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[2].iv_pXProcs[0] = &l_brazosProcs[3];
        l_brazosProcs[2].iv_pXProcs[1] = &l_brazosProcs[0];
        l_brazosProcs[2].iv_pXProcs[3] = &l_brazosProcs[1];

        // Proc3:
        l_brazosProcs[3].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[3].procHUID = 3;                 // HUID
        l_brazosProcs[3].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[3].procFabricChip = 3;           // FABRIC_CHIP_ID
        l_brazosProcs[3].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[3].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[3].iv_pXProcs[0] = &l_brazosProcs[0];
        l_brazosProcs[3].iv_pXProcs[1] = &l_brazosProcs[1];
        l_brazosProcs[3].iv_pXProcs[3] = &l_brazosProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_brazosProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_brazosProcs[0].iv_deconfigured == false &&
            l_brazosProcs[1].iv_deconfigured == true &&
            l_brazosProcs[2].iv_deconfigured == false &&
            l_brazosProcs[3].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc12: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc12: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfigure Associated Proc13
     */
    void testDeconfigureAssocProc13()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc13: Started");
        HWAS_INF("testDeconfigureAssocProc13: Started");

        // This test populates structs which contain information
        // regarding a processor and its child chiplet's linkage
        // and states.  A vector of these structs, effectively
        // describing the system, is passed to the
        // _deconfigureAssocProc algorithm which marks procs to
        // be deconfigured based on existing bus deconfigurations.

        // SCENARIO: Single node, 2 master procs (one master, one alternate)
        // System with master proc, proc0xbus0, proc1xbus3, proc1xbus0, and
        // proc2xbus3 deconfigured

        // Return error for _deconfigureAssocProc
        errlHndl_t l_pErr = NULL;

        // User-defined number of procs
        size_t NUM_PROCS = 4;

        // Define and populate vector
        DeconfigGard::ProcInfoVector l_brazosProcs;
        DeconfigGard::ProcInfo l_ProcInfo = DeconfigGard::ProcInfo();
        l_brazosProcs.insert(l_brazosProcs.begin(), NUM_PROCS, l_ProcInfo);

        // Set proc options
        // Proc0:
        l_brazosProcs[0].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[0].procHUID = 0;                 // HUID
        l_brazosProcs[0].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[0].procFabricChip = 0;           // FABRIC_CHIP_ID
        l_brazosProcs[0].iv_masterCapable = true;      // Master proc
        l_brazosProcs[0].iv_deconfigured = true;      // HWAS state
        // XBus links and states
        l_brazosProcs[0].iv_pXProcs[0] = &l_brazosProcs[1];
        l_brazosProcs[0].iv_pXProcs[1] = &l_brazosProcs[2];
        l_brazosProcs[0].iv_pXProcs[3] = &l_brazosProcs[3];
        l_brazosProcs[0].iv_XDeconfigured[0] = true;

        // Proc1:
        l_brazosProcs[1].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[1].procHUID = 1;                 // HUID
        l_brazosProcs[1].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[1].procFabricChip = 1;           // FABRIC_CHIP_ID
        l_brazosProcs[1].iv_masterCapable = true;      // Not master proc
        l_brazosProcs[1].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        // XBus links and states
        l_brazosProcs[1].iv_pXProcs[0] = &l_brazosProcs[2];
        l_brazosProcs[1].iv_pXProcs[1] = &l_brazosProcs[3];
        l_brazosProcs[1].iv_pXProcs[3] = &l_brazosProcs[0];
        l_brazosProcs[1].iv_XDeconfigured[0] = true;
        l_brazosProcs[1].iv_XDeconfigured[3] = true;

        // Proc2:
        l_brazosProcs[2].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[2].procHUID = 2;                 // HUID
        l_brazosProcs[2].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[2].procFabricChip = 2;           // FABRIC_CHIP_ID
        l_brazosProcs[2].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[2].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[2].iv_pXProcs[0] = &l_brazosProcs[3];
        l_brazosProcs[2].iv_pXProcs[1] = &l_brazosProcs[0];
        l_brazosProcs[2].iv_pXProcs[3] = &l_brazosProcs[1];
        l_brazosProcs[2].iv_XDeconfigured[3] = true;

        // Proc3:
        l_brazosProcs[3].iv_pThisProc = NULL;          // Target *
        l_brazosProcs[3].procHUID = 3;                 // HUID
        l_brazosProcs[3].procFabricGroup = 0;          // FABRIC_GROUP_ID
        l_brazosProcs[3].procFabricChip = 3;           // FABRIC_CHIP_ID
        l_brazosProcs[3].iv_masterCapable = false;     // Not master proc
        l_brazosProcs[3].iv_deconfigured = false;      // HWAS state
        // XBus links and states
        l_brazosProcs[3].iv_pXProcs[0] = &l_brazosProcs[0];
        l_brazosProcs[3].iv_pXProcs[1] = &l_brazosProcs[1];
        l_brazosProcs[3].iv_pXProcs[3] = &l_brazosProcs[2];

        // Call _deconfigureAssocProc to determine which procs
        // should be deconfigured based on state of system passed in
        l_pErr = DeconfigGard::_deconfigureAssocProc(l_brazosProcs);
        if (l_pErr)
        {
            HWAS_ERR("Error from _deconfigureAssocProc ");
        }

        // Check result
        if (l_brazosProcs[0].iv_deconfigured == true &&
            l_brazosProcs[1].iv_deconfigured == false &&
            l_brazosProcs[2].iv_deconfigured == true &&
            l_brazosProcs[3].iv_deconfigured == false)
        {
            TS_TRACE(INFO_MRK "testDeconfigureAssocProc13: Success");
        }
        else
        {
            TS_FAIL("testDeconfigureAssocProc13: incorrect configuration returned");
        }
    }

    /**
     *  @brief Test Deconfig Present Association 1
     */
    void testdeconfigPresentByAssoc1()
    {
        TS_TRACE(INFO_MRK "testDeconfigureAssocProc1: Started");
        HWAS_INF("testdeconfigPresentByAssoc1: Started");

        // This tests the scenario where there is 1 mc, mi, dmi, membuff, mba and dimm
        // This is done to ensure that the algorithm works on each edge case

        TargetInfoVector l_targets;
        TargetInfoVector l_targToDeconfig;
        TargetInfo l_TargetInfo;

        l_TargetInfo.pThisTarget = NULL;
        EntityPath l_ep[6];

        // MC only
        l_ep[0].addLast(TYPE_MC, 0);
        l_TargetInfo.affinityPath = l_ep[0]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_MC;

        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);
        
        // MI only
        l_ep[1].addLast(TYPE_MC, 0);
        l_ep[1].addLast(TYPE_MI, 0);
        l_TargetInfo.affinityPath = l_ep[1]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_MI;

        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);
        
        // DMI only
        l_ep[2].addLast(TYPE_MC, 0);
        l_ep[2].addLast(TYPE_MI, 0);
        l_ep[2].addLast(TYPE_DMI, 0);
        l_TargetInfo.affinityPath = l_ep[2]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_DMI;

        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);

        // MEMBUF only
        l_ep[3].addLast(TYPE_MC, 0);
        l_ep[3].addLast(TYPE_MI, 0);
        l_ep[3].addLast(TYPE_DMI, 0);
        l_ep[3].addLast(TYPE_MEMBUF, 0);
        l_TargetInfo.affinityPath = l_ep[3]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_MEMBUF;
        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);

        // MBA only
        l_ep[4].addLast(TYPE_MC, 0);
        l_ep[4].addLast(TYPE_MI, 0);
        l_ep[4].addLast(TYPE_DMI, 0);
        l_ep[4].addLast(TYPE_MEMBUF, 0);
        l_ep[4].addLast(TYPE_MBA, 0);
        l_TargetInfo.affinityPath = l_ep[4]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_MBA;
        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);

        // DIMM only
        l_ep[5].addLast(TYPE_MC, 0);
        l_ep[5].addLast(TYPE_MI, 0);
        l_ep[5].addLast(TYPE_DMI, 0);
        l_ep[5].addLast(TYPE_MEMBUF, 0);
        l_ep[5].addLast(TYPE_MBA, 0);
        l_ep[5].addLast(TYPE_DIMM, 0);
        l_TargetInfo.affinityPath = l_ep[5]; // SHOULD GET DECONFIGURED
        l_TargetInfo.type = TYPE_DIMM;
        l_targets.push_back(l_TargetInfo);

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 6) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) &&
            (l_targToDeconfig[1].affinityPath == l_ep[1]) &&
            (l_targToDeconfig[2].affinityPath == l_ep[2]) &&
            (l_targToDeconfig[3].affinityPath == l_ep[3]) &&
            (l_targToDeconfig[4].affinityPath == l_ep[4]) &&
            (l_targToDeconfig[5].affinityPath == l_ep[5]) )
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc1: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc1: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 2
     */
    void testdeconfigPresentByAssoc2()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc2: Started");
        HWAS_INF("testdeconfigPresentByAssoc2: Started");

        // This test the scenario where MC Group 0 does not have a membuf
        // MC Group 1 is fully populated

        // User-defined number of targets
        size_t NUM_TARGS = 7;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.pThisTarget = NULL;
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add MC Group 0
        //l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);        
        l_ep[0] = l_targets[0].affinityPath; // SHOULD GET DECONFIGURED
        l_targets[0].type = TYPE_MC;

        // Add MEMBUF Group 1
        //l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC,1);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[1] = l_targets[1].affinityPath;
        l_targets[1].type = TYPE_MEMBUF;

        // Add MBA Group 1
        //l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC,1);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[2].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[2].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[2] = l_targets[2].affinityPath;
        l_targets[2].type = TYPE_MBA;

        // Add DIMM Group 1
        //l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC,1);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[3].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[3].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[3].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[3] = l_targets[3].affinityPath;
        l_targets[3].type = TYPE_DIMM;

        // Add MI Group 1
        //l_targets[4].pThisTarget = NULL;
        l_targets[4].affinityPath.addLast(TYPE_MC,1);
        l_targets[4].affinityPath.addLast(TYPE_MI, 0);
        l_ep[4] = l_targets[4].affinityPath;
        l_targets[4].type = TYPE_MI;
        
        // Add DMI Group 1
        //l_targets[5].pThisTarget = NULL;
        l_targets[5].affinityPath.addLast(TYPE_MC,1);
        l_targets[5].affinityPath.addLast(TYPE_MI, 0);
        l_targets[5].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[5] = l_targets[5].affinityPath;
        l_targets[5].type = TYPE_DMI;


        // Add MC Group 1
        l_targets[6].affinityPath.addLast(TYPE_MC,1);
        l_ep[6] = l_targets[6].affinityPath;
        l_targets[6].type = TYPE_MC;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 1) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) )
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc2: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc2: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 3
     */
    void testdeconfigPresentByAssoc3()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc3: Started");
        HWAS_INF("testdeconfigPresentByAssoc3: Started");

        // This test the scenario where MEMBUF Group 1 has no DMI and then
        // DIMM Group 1 has no MEMBUF because MEMBUF 1 will be marked for
        // deconfigure

        // User-defined number of targets
        size_t NUM_TARGS = 9;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add DMI Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[0] = l_targets[0].affinityPath;
        l_targets[0].type = TYPE_DMI;

        // Add MEMBUF Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[1] = l_targets[1].affinityPath;
        l_targets[1].type = TYPE_MEMBUF;

        // Add MBA Group 0
        l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC, 0);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[2].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[2].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[2] = l_targets[2].affinityPath;
        l_targets[2].type = TYPE_MBA;

        // Add MBA Group 1
        l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC, 0);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 1);
        l_targets[3].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[3].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[3] = l_targets[3].affinityPath; // SHOULD GET DECONFIGURED
        l_targets[3].type = TYPE_MBA;

        // Add MEMBUF Group 1
        l_targets[4].pThisTarget = NULL;
        l_targets[4].affinityPath.addLast(TYPE_MC, 0);
        l_targets[4].affinityPath.addLast(TYPE_MI, 0);
        l_targets[4].affinityPath.addLast(TYPE_DMI, 1);
        l_targets[4].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[4] = l_targets[4].affinityPath; // SHOULD GET DECONFIGURED
        l_targets[4].type = TYPE_MEMBUF;

        // Add DIMM Group 0
        l_targets[5].pThisTarget = NULL;
        l_targets[5].affinityPath.addLast(TYPE_MC, 0);
        l_targets[5].affinityPath.addLast(TYPE_MI, 0);
        l_targets[5].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[5].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[5].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[5].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[5] = l_targets[5].affinityPath;
        l_targets[5].type = TYPE_DIMM;

        // Add DIMM Group 1
        l_targets[6].pThisTarget = NULL;
        l_targets[6].affinityPath.addLast(TYPE_MC, 0);
        l_targets[6].affinityPath.addLast(TYPE_MI, 0);
        l_targets[6].affinityPath.addLast(TYPE_DMI, 1);
        l_targets[6].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[6].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[6].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[6] = l_targets[6].affinityPath; // SHOULD GET DECONFIGURED
        l_targets[6].type = TYPE_DIMM;

        // Add MC
        l_targets[7].pThisTarget = NULL;
        l_targets[7].affinityPath.addLast(TYPE_MC, 0);
        l_ep[7] = l_targets[7].affinityPath;
        l_targets[7].type = TYPE_MC;
        
        // Add MI
        l_targets[8].pThisTarget = NULL;
        l_targets[8].affinityPath.addLast(TYPE_MC, 0);
        l_targets[8].affinityPath.addLast(TYPE_MI, 0);
        l_ep[8] = l_targets[8].affinityPath;
        l_targets[8].type = TYPE_MI;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 3) &&
            (l_targToDeconfig[0].affinityPath == l_ep[4]) && // 0010 MEMBUF
            (l_targToDeconfig[1].affinityPath == l_ep[3]) && // 00100 MBA
            (l_targToDeconfig[2].affinityPath == l_ep[6]) )  // 001000 DIMM
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc3: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc3: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 4
     */
    void testdeconfigPresentByAssoc4()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc4: Started");
        HWAS_INF("testdeconfigPresentByAssoc4: Started");

        // This test the scenario where MEMBUF Group 0 has no MBAs causing
        // MC Group 0 to also be deconfigured.

        // User-defined number of targets
        size_t NUM_TARGS = 4;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add MC Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_ep[0] = l_targets[0].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[0].type = TYPE_MC;
        
        // Add MI Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_ep[1] = l_targets[1].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[1].type = TYPE_MI;
        
        // Add DMI Group 0
        l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC, 0);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[2] = l_targets[2].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[2].type = TYPE_DMI;

        // Add MEMBUF Group 0
        l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC, 0);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[3].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[3] = l_targets[3].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[3].type = TYPE_MEMBUF;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 4) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) && // 0 MC
            (l_targToDeconfig[1].affinityPath == l_ep[1]) && // 00 MI
            (l_targToDeconfig[2].affinityPath == l_ep[2]) && // 000 DMI
            (l_targToDeconfig[3].affinityPath == l_ep[3]) )  // 0000 MEMBUF
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc4: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc4: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 5
     */
    void testdeconfigPresentByAssoc5()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc5: Started");
        HWAS_INF("testdeconfigPresentByAssoc5: Started");

        // This test the scenario where MEMBUF Group 0 and MBA Group 0 having
        // no DMI. This tests the DMIINDEX edge case because one never existed

        // User-defined number of targets
        size_t NUM_TARGS = 2;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add MEMBUF Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[0].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[0] = l_targets[0].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[0].type = TYPE_MEMBUF;

        // Add MBA Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[1].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[1] = l_targets[1].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[1].type = TYPE_MBA;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 2) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) && // 0000 MEMBUF
            (l_targToDeconfig[1].affinityPath == l_ep[1]) )  // 00000 MBA
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc5: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc5: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 6
     */
    void testdeconfigPresentByAssoc6()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc6: Started");
        HWAS_INF("testdeconfigPresentByAssoc6: Started");

        // This test the scenario where MBA Group 0 and DIMM Group 0 having
        // no MEMBUF. This tests the MEMBUFIndex edge case because one never existed

        // User-defined number of targets
        size_t NUM_TARGS = 2;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add MBA Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[0].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[0].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[0] = l_targets[0].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[0].type = TYPE_MBA;

        // Add DIMM Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[1].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[1].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[1] = l_targets[1].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[1].type = TYPE_DIMM;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 2) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) && // 00000 MBA
            (l_targToDeconfig[1].affinityPath == l_ep[1]) )  // 000000 DIMM
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc6: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc6: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 7
     */
    void testdeconfigPresentByAssoc7()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc7: Started");
        HWAS_INF("testdeconfigPresentByAssoc7: Started");

        // This test the scenario where MBA Group 1 has no DIMMS

        // User-defined number of targets
        size_t NUM_TARGS = 7;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add DMI Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[0] = l_targets[0].affinityPath;
        l_targets[0].type = TYPE_DMI;

        // Add MEMBUF Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[1] = l_targets[1].affinityPath;
        l_targets[1].type = TYPE_MEMBUF;

        // Add MBA Group 0
        l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC, 0);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[2].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[2].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[2] = l_targets[2].affinityPath;
        l_targets[2].type = TYPE_MBA;

        // Add DIMM Group 0
        l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC, 0);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[3].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[3].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[3].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[3] = l_targets[3].affinityPath;
        l_targets[3].type = TYPE_DIMM;

        // Add MBA Group 1
        l_targets[4].pThisTarget = NULL;
        l_targets[4].affinityPath.addLast(TYPE_MC, 0);
        l_targets[4].affinityPath.addLast(TYPE_MI, 0);
        l_targets[4].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[4].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[4].affinityPath.addLast(TYPE_MBA, 1);
        l_ep[4] = l_targets[4].affinityPath; // SHOULD BE DECONFIGURED
        l_targets[4].type = TYPE_MBA;

        // Add MI Group 0
        l_targets[5].pThisTarget = NULL;
        l_targets[5].affinityPath.addLast(TYPE_MC, 0);
        l_targets[5].affinityPath.addLast(TYPE_MI, 0);
        l_ep[5] = l_targets[5].affinityPath;
        l_targets[5].type = TYPE_MI;
        
        // Add MC  Group 0
        l_targets[6].pThisTarget = NULL;
        l_targets[6].affinityPath.addLast(TYPE_MC, 0);
        l_ep[6] = l_targets[6].affinityPath;
        l_targets[6].type = TYPE_MC;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 1) &&
            (l_targToDeconfig[0].affinityPath == l_ep[4]) ) // 001 MBA
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc7: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc7: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 8
     */
    void testdeconfigPresentByAssoc8()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc8: Started");
        HWAS_INF("testdeconfigPresentByAssoc8: Started");

        // This test the scenario where each type is missing it's child
        //  and the cascade

        // User-defined number of targets
        size_t NUM_TARGS = 13;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add DMI Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[0] = l_targets[0].affinityPath;
        l_targets[0].type = TYPE_DMI; // SHOULD BE DECONFIGURED

        // Add MEMBUF Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[1] = l_targets[1].affinityPath;
        l_targets[1].type = TYPE_MEMBUF; // SHOULD BE DECONFIGURED

        // Add MBA Group 0
        l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC, 0);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[2].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[2].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[2] = l_targets[2].affinityPath;
        l_targets[2].type = TYPE_MBA; // SHOULD BE DECONFIGURED


        // Add DMI Group 1
        l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC, 0);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 1);
        l_ep[3] = l_targets[3].affinityPath;
        l_targets[3].type = TYPE_DMI; // SHOULD BE DECONFIGURED


        // Add MCS Group 2
        l_targets[4].pThisTarget = NULL;
        l_targets[4].affinityPath.addLast(TYPE_MC, 0);
        l_targets[4].affinityPath.addLast(TYPE_MI, 1);
        l_targets[4].affinityPath.addLast(TYPE_DMI, 0);
        l_ep[4] = l_targets[4].affinityPath;
        l_targets[4].type = TYPE_DMI;

        // Add MEMBUF Group 0
        l_targets[5].pThisTarget = NULL;
        l_targets[5].affinityPath.addLast(TYPE_MC, 0);
        l_targets[5].affinityPath.addLast(TYPE_MI, 1);
        l_targets[5].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[5].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[5] = l_targets[5].affinityPath;
        l_targets[5].type = TYPE_MEMBUF; // SHOULD BE DECONFIGURED

        // Add MEMBUF Group 1
        l_targets[6].pThisTarget = NULL;
        l_targets[6].affinityPath.addLast(TYPE_MC, 0);
        l_targets[6].affinityPath.addLast(TYPE_MI, 1);
        l_targets[6].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[6].affinityPath.addLast(TYPE_MEMBUF, 1);
        l_ep[6] = l_targets[6].affinityPath;
        l_targets[6].type = TYPE_MEMBUF;

        // Add MBA Group 0
        l_targets[7].pThisTarget = NULL;
        l_targets[7].affinityPath.addLast(TYPE_MC, 0);
        l_targets[7].affinityPath.addLast(TYPE_MI, 1);
        l_targets[7].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[7].affinityPath.addLast(TYPE_MEMBUF, 1);
        l_targets[7].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[7] = l_targets[7].affinityPath;
        l_targets[7].type = TYPE_MBA; // SHOULD BE DECONFIGURED

        // Add MBA Group 1
        l_targets[8].pThisTarget = NULL;
        l_targets[8].affinityPath.addLast(TYPE_MC, 0);
        l_targets[8].affinityPath.addLast(TYPE_MI, 1);
        l_targets[8].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[8].affinityPath.addLast(TYPE_MEMBUF, 1);
        l_targets[8].affinityPath.addLast(TYPE_MBA, 1);
        l_ep[8] = l_targets[8].affinityPath;
        l_targets[8].type = TYPE_MBA;

        // Add DIMM Group 1
        l_targets[9].pThisTarget = NULL;
        l_targets[9].affinityPath.addLast(TYPE_MC, 0);
        l_targets[9].affinityPath.addLast(TYPE_MI, 1);
        l_targets[9].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[9].affinityPath.addLast(TYPE_MEMBUF, 1);
        l_targets[9].affinityPath.addLast(TYPE_MBA, 1);
        l_targets[9].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[9] = l_targets[9].affinityPath;
        l_targets[9].type = TYPE_DIMM;

        // Add MC 0
        l_targets[10].pThisTarget = NULL;
        l_targets[10].affinityPath.addLast(TYPE_MC, 0);
        l_ep[10] = l_targets[10].affinityPath;
        l_targets[10].type = TYPE_MC;

        // Add MI 0
        l_targets[11].pThisTarget = NULL;
        l_targets[11].affinityPath.addLast(TYPE_MC, 0);
        l_targets[11].affinityPath.addLast(TYPE_MI, 0);
        l_ep[11] = l_targets[11].affinityPath;
        l_targets[11].type = TYPE_MI;  // SHOULD BE DECONFIGURED
        
        // Add MI 1
        l_targets[12].pThisTarget = NULL;
        l_targets[12].affinityPath.addLast(TYPE_MC, 0);
        l_targets[12].affinityPath.addLast(TYPE_MI, 1);
        l_ep[12] = l_targets[12].affinityPath;
        l_targets[12].type = TYPE_MI;

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 7) &&
            (l_targToDeconfig[0].affinityPath == l_ep[11]) && // 00 MI
            (l_targToDeconfig[1].affinityPath == l_ep[0]) &&  // 000 DMI
            (l_targToDeconfig[2].affinityPath == l_ep[1]) &&  // 0000 MEMBUF
            (l_targToDeconfig[3].affinityPath == l_ep[2]) &&  // 00000 MBA
            (l_targToDeconfig[4].affinityPath == l_ep[3]) &&  // 001 DMI
            (l_targToDeconfig[5].affinityPath == l_ep[5]) &&  // 0100 MEMBUF
            (l_targToDeconfig[6].affinityPath == l_ep[7])  )  // 01010 MBA
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc8: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc8: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_WARN("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

    /**
     *  @brief Test Deconfig Present Association 9
     */
    void testdeconfigPresentByAssoc9()
    {
        TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc9: Started");
        HWAS_INF("testdeconfigPresentByAssoc9: Started");

        // This test the scenario where each type is missing it's parent
        //  and the cascade

        // User-defined number of targets
        size_t NUM_TARGS = 6;

        // Input target vector
        TargetInfoVector l_targets;
        TargetInfo l_TargInfo;
        EntityPath l_ep[NUM_TARGS];
        l_TargInfo.affinityPath = l_ep[0];
        l_targets.insert(l_targets.begin(), NUM_TARGS, l_TargInfo);
        // Output target vector
        TargetInfoVector l_targToDeconfig;

        // Add MEMBUF Group 0
        l_targets[0].pThisTarget = NULL;
        l_targets[0].affinityPath.addLast(TYPE_MC, 0);
        l_targets[0].affinityPath.addLast(TYPE_MI, 0);
        l_targets[0].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[0].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_ep[0] = l_targets[0].affinityPath;
        l_targets[0].type = TYPE_MEMBUF; // SHOULD BE DECONFIGURED

        // Add MBA Group 0
        l_targets[1].pThisTarget = NULL;
        l_targets[1].affinityPath.addLast(TYPE_MC, 0);
        l_targets[1].affinityPath.addLast(TYPE_MI, 0);
        l_targets[1].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[1].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[1].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[1] = l_targets[1].affinityPath;
        l_targets[1].type = TYPE_MBA; // SHOULD BE DECONFIGURED

        // Add DIMM Group 0
        l_targets[2].pThisTarget = NULL;
        l_targets[2].affinityPath.addLast(TYPE_MC, 0);
        l_targets[2].affinityPath.addLast(TYPE_MI, 0);
        l_targets[2].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[2].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[2].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[2].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[2] = l_targets[2].affinityPath;
        l_targets[2].type = TYPE_DIMM; // SHOULD BE DECONFIGURED

        // Add MBA Group 1
        l_targets[3].pThisTarget = NULL;
        l_targets[3].affinityPath.addLast(TYPE_MC, 0);
        l_targets[3].affinityPath.addLast(TYPE_MI, 0);
        l_targets[3].affinityPath.addLast(TYPE_DMI, 1);
        l_targets[3].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[3].affinityPath.addLast(TYPE_MBA, 0);
        l_ep[3] = l_targets[3].affinityPath;
        l_targets[3].type = TYPE_MBA; // SHOULD BE DECONFIGURED

        // Add DIMM Group 1
        l_targets[4].pThisTarget = NULL;
        l_targets[4].affinityPath.addLast(TYPE_MC, 0);
        l_targets[4].affinityPath.addLast(TYPE_MI, 0);
        l_targets[4].affinityPath.addLast(TYPE_DMI, 1);
        l_targets[4].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[4].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[4].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[4] = l_targets[4].affinityPath;
        l_targets[4].type = TYPE_DIMM; // SHOULD BE DECONFIGURED

        // Add DIMM Group 2
        l_targets[5].pThisTarget = NULL;
        l_targets[5].affinityPath.addLast(TYPE_MC, 0);
        l_targets[5].affinityPath.addLast(TYPE_MI, 1);
        l_targets[5].affinityPath.addLast(TYPE_DMI, 0);
        l_targets[5].affinityPath.addLast(TYPE_MEMBUF, 0);
        l_targets[5].affinityPath.addLast(TYPE_MBA, 0);
        l_targets[5].affinityPath.addLast(TYPE_DIMM, 0);
        l_ep[5] = l_targets[5].affinityPath;
        l_targets[5].type = TYPE_DIMM; // SHOULD BE DECONFIGURED

        presentByAssoc(l_targets, l_targToDeconfig);

        // Check result
        std::sort(l_targToDeconfig.begin(), l_targToDeconfig.end(),
              compareAffinityCXX);
        if ((l_targToDeconfig.size() == 6) &&
            (l_targToDeconfig[0].affinityPath == l_ep[0]) &&
            (l_targToDeconfig[1].affinityPath == l_ep[1]) &&
            (l_targToDeconfig[2].affinityPath == l_ep[2]) &&
            (l_targToDeconfig[3].affinityPath == l_ep[3]) &&
            (l_targToDeconfig[4].affinityPath == l_ep[4]) &&
            (l_targToDeconfig[5].affinityPath == l_ep[5]) )
        {
            TS_TRACE(INFO_MRK "testdeconfigPresentByAssoc9: Success");
        }
        else
        {
            TS_FAIL("testdeconfigPresentByAssoc9: incorrect configuration returned");
            for (uint8_t i=0;i<l_targToDeconfig.size();i++)
            {
                char *s = l_targToDeconfig[i].affinityPath.toString();
                TS_TRACE("deconfig %s reason %x",s, l_targToDeconfig[i].reason);
                free(s);
            }
        }
    }

};

#undef DISABLE_UNIT_TESTS
#undef DISABLE_MBA_UNIT_TESTS
#undef DISABLE_MEM_UNIT_TESTS
#undef DISABLE_EX_UNIT_TESTS

#endif
