/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/isteps/istep08/call_host_set_voltages.C $             */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2019                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

/******************************************************************************/
// Includes
/******************************************************************************/

//  Component ID support
#include <hbotcompid.H>                // HWPF_COMP_ID

//  TARGETING support
#include <attributeenums.H>            // TYPE_PROC

//  Error handling support
#include <isteps/hwpisteperror.H>      // ISTEP_ERROR::IStepError
#include <errl/errlentry.H>            // errlHndl_t
#include <istepHelperFuncs.H>          // captureError

//  Tracing support
#include <trace/interface.H>           // TRACFCOMP
#include <initservice/isteps_trace.H>  // g_trac_isteps_trace

//  HWP call support
#include <p9_setup_evid.H>
#include <nest/nestHwpHelperFuncs.H>   // fapiHWPCallWrapperForChip
#include <hbToHwsvVoltageMsg.H>        // platform_set_nest_voltages
#ifdef CONFIG_AXONE
#include <chipids.H> // for EXPLORER ID
#include <pmic_enable.H>
#endif
//  Init Service support
#include <initservice/initserviceif.H> // INITSERVICE::spBaseServicesEnabled

namespace ISTEP_08
{
using   namespace   ISTEP;
using   namespace   ISTEP_ERROR;
using   namespace   ISTEPS_TRACE;
using   namespace   TARGETING;

//*****************************************************************************
// Wrapper function to call host_set_voltages
//*****************************************************************************
void* call_host_set_voltages(void *io_pArgs)
{
    TRACFCOMP(g_trac_isteps_trace, ENTER_MRK"call_host_set_voltages enter");

    errlHndl_t l_err(nullptr);
    IStepError l_stepError;

    do
    {
        // Skip p9_setup_evid on Axone, no targets exist
        #ifndef CONFIG_AXONE_BRING_UP

        TargetHandleList l_procList;
        // Get the system's procs
        getAllChips( l_procList,
                     TYPE_PROC,
                     true ); // true: return functional procs

        // Iterate over the found procs calling p9_setup_evid
        for( const auto & l_procTarget : l_procList )
        {
            // Cast to fapi2 target
            const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP>
                        l_fapiProcTarget( l_procTarget );

            TRACFCOMP(g_trac_isteps_trace,
                      "Running p9_setup_evid HWP on processor target %.8X",
                      get_huid( l_procTarget ) );

            FAPI_INVOKE_HWP(l_err,
                            p9_setup_evid,
                            l_fapiProcTarget,
                            APPLY_VOLTAGE_SETTINGS);

            if( l_err )
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                        "Error running p9_setup_evid on processor target %.8X",
                        get_huid( l_procTarget ) );

                // Capture error and continue
                captureError(l_err,
                             l_stepError,
                             HWPF_COMP_ID,
                             l_procTarget);
            }

            TRACFCOMP(g_trac_isteps_trace, "Done with p9_setup_evid" );
        } // Processor Loop

        // Exit if FAPI call failed or returned an error
        if (!l_stepError.isNull())
        {
            break;
        }
        #endif

        // If no error occurred and FSP is present,
        // send voltage information to HWSV
        if (INITSERVICE::spBaseServicesEnabled())
        {
            l_err = platform_set_nest_voltages();

            if( l_err )
            {
                TRACFCOMP(g_trac_isteps_trace,
                 "Error in call_host_set_voltages::platform_set_nest_voltages()")

                // Capture error and continue
                captureError(l_err,
                             l_stepError,
                             ISTEP_COMP_ID);
            }
        }

        // Exit if setting voltage failed or returned an error
        if (!l_stepError.isNull())
        {
            break;
        }

        if (INITSERVICE::isSMPWrapConfig())
        {
            // Make the FAPI call to p9_fbc_eff_config_links
            // Make the FAPI call to p9_sys_chiplet_scominit, if previous call succeeded
            fapiHWPCallWrapperHandler(P9_FBC_EFF_CONFIG_LINKS_F_T, l_stepError,
                                      HWPF_COMP_ID, TYPE_PROC)                  &&
            fapiHWPCallWrapperHandler(P9_SYS_CHIPLET_SCOMINIT, l_stepError,
                                      HWPF_COMP_ID, TYPE_PROC)                  &&
            // Make call to p9_io_obus_image_build
            fapiHWPCallWrapperHandler(P9_IO_OBUS_IMAGE_BUILD, l_stepError,
                                      HWPF_COMP_ID, TYPE_OBUS)                  &&
            // Make call to p9_io_xbus_image_build
            fapiHWPCallWrapperHandler(P9_IO_XBUS_IMAGE_BUILD, l_stepError,
                                      HWPF_COMP_ID, TYPE_PROC);
        }

#ifdef CONFIG_AXONE
        // Create a vector of TARGETING::Target pointers
        TargetHandleList l_chipList;

        // Get a list of all of the functioning ocmb chips
        TARGETING::getAllChips(l_chipList, TARGETING::TYPE_OCMB_CHIP, true);

        for (const auto & l_ocmb: l_chipList)
        {
            // PMICs are not present on Gemini, so skip this enable call
            // check EXPLORER first as this is most likely the configuration
            uint32_t chipId = l_ocmb->getAttr< TARGETING::ATTR_CHIP_ID>();
            if (chipId == POWER_CHIPID::EXPLORER_16)
            {
                TRACFCOMP( g_trac_isteps_trace, "call_host_set_voltages: "
                    "calling pmic_enable on OCMB 0x%.8X", get_huid(l_ocmb) );

                fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>l_fapi2_target(l_ocmb);

                // Invoke procedure
                FAPI_INVOKE_HWP(l_err, pmic_enable, l_fapi2_target);
            }

            if (l_err)
            {
                TRACFCOMP(g_trac_isteps_trace,
                    "Error from pmic_enable for 0x%.8X target",
                    TARGETING::get_huid(l_ocmb));

                // Capture error and continue to next OCMB
                captureError(l_err, l_stepError, HWPF_COMP_ID, l_ocmb);
            }
        }
#endif

    }while( 0 );

    TRACFCOMP(g_trac_isteps_trace, EXIT_MRK"call_host_set_voltages exit");

    // end task, returning any errorlogs to IStepDisp
    return l_stepError.getErrorHandle();
}

};   // end namespace ISTEP_08
