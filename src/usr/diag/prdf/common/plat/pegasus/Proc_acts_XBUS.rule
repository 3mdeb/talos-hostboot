# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Proc_acts_XBUS.rule $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2012,2013
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG

################################################################################
# XBUS Chiplet Registers
################################################################################

rule XbusChipletFir
{
  CHECK_STOP:
     (XBUS_CHIPLET_CS_FIR       & `1F80000000000000`) & ~XBUS_CHIPLET_FIR_MASK;
  RECOVERABLE:
    ((XBUS_CHIPLET_RE_FIR >> 2) & `1F80000000000000`) & ~XBUS_CHIPLET_FIR_MASK;
};

group gXbusChipletFir filter singlebit
{
    /** XbusChipletFir[3]
     *  Attention from LFIR
     */
    (XbusChipletFir, bit(3)) ? analyze(gXbusLFir);

    /** XbusChipletFir[4]
     *  Attention from PBENFIR
     */
    (XbusChipletFir, bit(4)) ? analyze(gPbenFir);

    /** XbusChipletFir[5]
     *  Attention from IOXFIR_0 (Venice only)
     */
    (XbusChipletFir, bit(5)) ? defaultMaskedError;

    /** XbusChipletFir[6]
     *  Attention from IOXFIR_1
     */
    (XbusChipletFir, bit(6)) ? analyze(gIoxFir_1);

    /** XbusChipletFir[7]
     *  Attention from IOXFIR_2 (Venice only)
     */
    (XbusChipletFir, bit(7)) ? defaultMaskedError;

    /** XbusChipletFir[8]
     *  Attention from IOXFIR_3 (Venice only)
     */
    (XbusChipletFir, bit(8)) ? defaultMaskedError;
};

################################################################################
# XBUS Chiplet LFIR
################################################################################

rule XbusLFir
{
  CHECK_STOP:  XBUS_LFIR & ~XBUS_LFIR_MASK & ~XBUS_LFIR_ACT0 & ~XBUS_LFIR_ACT1;
  RECOVERABLE: XBUS_LFIR & ~XBUS_LFIR_MASK & ~XBUS_LFIR_ACT0 &  XBUS_LFIR_ACT1;
};

group gXbusLFir filter singlebit
{
    /** XBUS_LFIR[0]
     *  CFIR internal parity error
     */
    (XbusLFir, bit(0)) ? TBDDefaultCallout;

    /** XBUS_LFIR[1]
     *  Local errors from GPIO (PCB error)
     */
    (XbusLFir, bit(1)) ? TBDDefaultCallout;

    /** XBUS_LFIR[2]
     *  Local errors from CC (PCB error)
     */
    (XbusLFir, bit(2)) ? TBDDefaultCallout;

    /** XBUS_LFIR[3]
     *  Local errors from CC (OPCG, parity, scan collision, ...)
     */
    (XbusLFir, bit(3)) ? TBDDefaultCallout;

    /** XBUS_LFIR[4]
     *  Local errors from PSC (PCB error)
     */
    (XbusLFir, bit(4)) ? TBDDefaultCallout;

    /** XBUS_LFIR[5]
     *  Local errors from PSC (parity error)
     */
    (XbusLFir, bit(5)) ? TBDDefaultCallout;

    /** XBUS_LFIR[6]
     *  Local errors from Thermal (parity error)
     */
    (XbusLFir, bit(6)) ? TBDDefaultCallout;

    /** XBUS_LFIR[7]
     *  Local errors from Thermal (PCB error)
     */
    (XbusLFir, bit(7)) ? TBDDefaultCallout;

    /** XBUS_LFIR[8|9]
     *  Local errors from Thermal (Trip error)
     */
    (XbusLFir, bit(8|9)) ? TBDDefaultCallout;

    /** XBUS_LFIR[10|11]
     *  Local errors from Trace Array ( error)
     */
    (XbusLFir, bit(10|11)) ? TBDDefaultCallout;
};

################################################################################
# XBUS Chiplet PBENFIR
################################################################################

rule PbenFir
{
    CHECK_STOP:  PBENFIR & ~PBENFIR_MASK & ~PBENFIR_ACT0 & ~PBENFIR_ACT1;
    RECOVERABLE: PBENFIR & ~PBENFIR_MASK & ~PBENFIR_ACT0 &  PBENFIR_ACT1;
};

group gPbenFir filter singlebit
{
    /** PBENFIR[0]
     *  X0_LINK_RCV_CE: x0 link rcv ce
     */
    (PbenFir, bit(0)) ? TBDDefaultCallout;

    /** PBENFIR[1]
     *  X0_LINK_RCV_DERR: x0 link rcv derr
     */
    (PbenFir, bit(1)) ? TBDDefaultCallout;

    /** PBENFIR[2]
     *  X0_LINK_RCV_UE: x0 link rcv ue
     */
    (PbenFir, bit(2)) ? TBDDefaultCallout;

    /** PBENFIR[3]
     *  X1_LINK_RCV_CE: x1 link rcv ce
     */
    (PbenFir, bit(3)) ? TBDDefaultCallout;

    /** PBENFIR[4]
     *  X1_LINK_RCV_DERR: x1 link rcv derr
     */
    (PbenFir, bit(4)) ? TBDDefaultCallout;

    /** PBENFIR[5]
     *  X1_LINK_RCV_UE: x1 link rcv ue
     */
    (PbenFir, bit(5)) ? TBDDefaultCallout;

    /** PBENFIR[6]
     *  X2_LINK_RCV_CE: x2 link rcv ce
     */
    (PbenFir, bit(6)) ? TBDDefaultCallout;

    /** PBENFIR[7]
     *  X2_LINK_RCV_DERR: x2 link rcv derr
     */
    (PbenFir, bit(7)) ? TBDDefaultCallout;

    /** PBENFIR[8]
     *  X2_LINK_RCV_UE: x2 link rcv ue
     */
    (PbenFir, bit(8)) ? TBDDefaultCallout;

    /** PBENFIR[9]
     *  X3_LINK_RCV_CE: x3 link rcv ce
     */
    (PbenFir, bit(9)) ? TBDDefaultCallout;

    /** PBENFIR[10]
     *  X3_LINK_RCV_DERR: x3 link rcv derr
     */
    (PbenFir, bit(10)) ? TBDDefaultCallout;

    /** PBENFIR[11]
     *  X3_LINK_RCV_UE: x3 link rcv ue
     */
    (PbenFir, bit(11)) ? TBDDefaultCallout;

    /** PBENFIR[12]
     *  X_LINK_SND_CE: x link rcv ce
     */
    (PbenFir, bit(12)) ? TBDDefaultCallout;

    /** PBENFIR[13]
     *  X_LINK_SND_SUE: x link rcv sue
     */
    (PbenFir, bit(13)) ? TBDDefaultCallout;

    /** PBENFIR[14]
     *  X_LINK_SND_UE: x link rcv ue
     */
    (PbenFir, bit(14)) ? TBDDefaultCallout;

    /** PBENFIR[15]
     *  X_LINK_CR_OVERFLOW: x link command/response/data buffer overflow
     */
    (PbenFir, bit(15)) ? TBDDefaultCallout;

    /** PBENFIR[16]
     *  X0_LINK_FMR_ERR: x0 link framer error
     */
    (PbenFir, bit(16)) ? TBDDefaultCallout;

    /** PBENFIR[17]
     *  X1_LINK_FMR_ERR: x1 link framer error
     */
    (PbenFir, bit(17)) ? TBDDefaultCallout;

    /** PBENFIR[18]
     *  X2_LINK_FMR_ERR: x2 link framer error
     */
    (PbenFir, bit(18)) ? TBDDefaultCallout;

    /** PBENFIR[19]
     *  X3_LINK_FMR_ERR: x3 link framer error
     */
    (PbenFir, bit(19)) ? TBDDefaultCallout;

    /** PBENFIR[20]
     *  X_LINK_PSR_ERR: x link parser error
     */
    (PbenFir, bit(20)) ? TBDDefaultCallout;

    /** PBENFIR[36]
     *  FIR_SCOM_ERR: pben iox fir_scom_err
     */
    (PbenFir, bit(36)) ? TBDDefaultCallout;
};

################################################################################
# XBUS Chiplet IOXFIR_1
################################################################################

rule IoxFir_1
{
    CHECK_STOP:  IOXFIR_1 & ~IOXFIR_1_MASK & ~IOXFIR_1_ACT0 & ~IOXFIR_1_ACT1;
    RECOVERABLE: IOXFIR_1 & ~IOXFIR_1_MASK & ~IOXFIR_1_ACT0 &  IOXFIR_1_ACT1;
};

group gIoxFir_1 filter singlebit
{
    /** IOXFIR_1[0]
     *  FIR_RX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IoxFir_1, bit(0)) ? TBDDefaultCallout;

    /** IOXFIR_1[1]
     *  FIR_TX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IoxFir_1, bit(1)) ? TBDDefaultCallout;

    /** IOXFIR_1[2]
     *  FIR_GCR_HANG_ERROR
     */
    (IoxFir_1, bit(2)) ? TBDDefaultCallout;

    /** IOXFIR_1[3|4|5|6|7]
     *  Reserved
     */
    (IoxFir_1, bit(3|4|5|6|7)) ? defaultMaskedError;

    /** IOXFIR_1[8]
     *  FIR_RX_BUS0_TRAINING_ERROR
     */
    (IoxFir_1, bit(8)) ? TBDDefaultCallout;

    /** IOXFIR_1[9]
     *  FIR_RX_BUS0_SPARE_DEPLOYED
     */
    (IoxFir_1, bit(9)) ? TBDDefaultCallout;

    /** IOXFIR_1[10]
     *  FIR_RX_BUS0_MAX_SPARES_EXCEEDED
     */
    (IoxFir_1, bit(10)) ? TBDDefaultCallout;

    /** IOXFIR_1[11]
     *  FIR_RX_BUS0_RECAL_OR_DYN_REPAIR_ERROR
     */
    (IoxFir_1, bit(11)) ? TBDDefaultCallout;

    /** IOXFIR_1[12]
     *  FIR_RX_BUS0_TOO_MANY_BUS_ERRORS
     */
    (IoxFir_1, bit(12)) ? TBDDefaultCallout;

    /** IOXFIR_1[13|14|15]
     *  Reserved
     */
    (IoxFir_1, bit(13|14|15)) ? defaultMaskedError;

    /** IOXFIR_1[16]
     *  FIR_RX_BUS1_TRAINING_ERROR
     */
    (IoxFir_1, bit(16)) ? TBDDefaultCallout;

    /** IOXFIR_1[17]
     *  FIR_RX_BUS1_SPARE_DEPLOYED
     */
    (IoxFir_1, bit(17)) ? xbus1SpareDeployed;

    /** IOXFIR_1[18]
     *  FIR_RX_BUS1_MAX_SPARES_EXCEEDED
     */
    (IoxFir_1, bit(18)) ? xbus1MaxSparesExceeded;

    /** IOXFIR_1[19]
     *  FIR_RX_BUS1_RECAL_OR_DYN_REPAIR_ERROR
     */
    (IoxFir_1, bit(19)) ? TBDDefaultCallout;

    /** IOXFIR_1[20]
     *  FIR_RX_BUS1_TOO_MANY_BUS_ERRORS
     */
    (IoxFir_1, bit(20)) ? xbus1TooManyBusErrors;

    /** IOXFIR_1[21|22|23]
     *  Reserved
     */
    (IoxFir_1, bit(21|22|23)) ? defaultMaskedError;

    /** IOXFIR_1[24]
     *  FIR_RX_BUS2_TRAINING_ERROR
     */
    (IoxFir_1, bit(24)) ? TBDDefaultCallout;

    /** IOXFIR_1[25]
     *  FIR_RX_BUS2_SPARE_DEPLOYED
     */
    (IoxFir_1, bit(25)) ? TBDDefaultCallout;

    /** IOXFIR_1[26]
     *  FIR_RX_BUS2_MAX_SPARES_EXCEEDED
     */
    (IoxFir_1, bit(26)) ? TBDDefaultCallout;

    /** IOXFIR_1[27]
     *  FIR_RX_BUS2_RECAL_OR_DYN_REPAIR_ERROR
     */
    (IoxFir_1, bit(27)) ? TBDDefaultCallout;

    /** IOXFIR_1[28]
     *  FIR_RX_BUS2_TOO_MANY_BUS_ERRORS
     */
    (IoxFir_1, bit(28)) ? TBDDefaultCallout;

    /** IOXFIR_1[29|30|31]
     *  Reserved
     */
    (IoxFir_1, bit(29|30|31)) ? defaultMaskedError;

    /** IOXFIR_1[32]
     *  FIR_RX_BUS3_TRAINING_ERROR
     */
    (IoxFir_1, bit(32)) ? TBDDefaultCallout;

    /** IOXFIR_1[33]
     *  FIR_RX_BUS3_SPARE_DEPLOYED
     */
    (IoxFir_1, bit(33)) ? TBDDefaultCallout;

    /** IOXFIR_1[34]
     *  FIR_RX_BUS3_MAX_SPARES_EXCEEDED
     */
    (IoxFir_1, bit(34)) ? TBDDefaultCallout;

    /** IOXFIR_1[35]
     *  FIR_RX_BUS3_RECAL_OR_DYN_REPAIR_ERROR
     */
    (IoxFir_1, bit(35)) ? TBDDefaultCallout;

    /** IOXFIR_1[36]
     *  FIR_RX_BUS3_TOO_MANY_BUS_ERRORS
     */
    (IoxFir_1, bit(36)) ? TBDDefaultCallout;

    /** IOXFIR_1[37|38|39]
     *  Reserved
     */
    (IoxFir_1, bit(37|38|39)) ? defaultMaskedError;

    /** IOXFIR_1[40]
     *  FIR_RX_BUS4_TRAINING_ERROR
     */
    (IoxFir_1, bit(40)) ? TBDDefaultCallout;

    /** IOXFIR_1[41]
     *  FIR_RX_BUS4_SPARE_DEPLOYED
     */
    (IoxFir_1, bit(41)) ? TBDDefaultCallout;

    /** IOXFIR_1[42]
     *  FIR_RX_BUS4_MAX_SPARES_EXCEEDED
     */
    (IoxFir_1, bit(42)) ? TBDDefaultCallout;

    /** IOXFIR_1[43]
     *  FIR_RX_BUS4_RECAL_OR_DYN_REPAIR_ERROR
     */
    (IoxFir_1, bit(43)) ? TBDDefaultCallout;

    /** IOXFIR_1[44]
     *  FIR_RX_BUS4_TOO_MANY_BUS_ERRORS
     */
    (IoxFir_1, bit(44)) ? TBDDefaultCallout;

    /** IOXFIR_1[45|46|47]
     *  Reserved
     */
    (IoxFir_1, bit(45|46|47)) ? defaultMaskedError;

    /** IOXFIR_1[48]
     *  FIR_SCOMFIR_ERROR
     */
    (IoxFir_1, bit(48)) ? TBDDefaultCallout;

    /** IOXFIR_1[49]
     *  FIR_SCOMFIR_ERROR_CLONE
     */
    (IoxFir_1, bit(49)) ? TBDDefaultCallout;
};

################################################################################
# Actions specific to XBUS chiplet
################################################################################

actionclass xbus1SpareDeployed
{
    callout(procedure(PassiveFabric_OnNode_ENUM), MRU_LOW);
    funccall("xbus1SpareDeployed");
};

actionclass xbus1MaxSparesExceeded
{
    callout(procedure(PassiveFabric_OnNode_ENUM), MRU_LOW);
    funccall("xbus1SparesExceeded");
    threshold1;
};

actionclass xbus1TooManyBusErrors
{
    callout(procedure(PassiveFabric_OnNode_ENUM), MRU_LOW);
    funccall("xbus1TooManyErrors");
    threshold1;
};
