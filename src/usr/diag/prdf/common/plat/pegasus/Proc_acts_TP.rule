# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Proc_acts_TP.rule $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2012,2013
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG

################################################################################
# TP Chiplet Registers
################################################################################

rule TpChipletFir
{
  CHECK_STOP:
     (TP_CHIPLET_CS_FIR       & `1FFFF80000000000`)  & ~TP_CHIPLET_FIR_MASK;
  RECOVERABLE:
    ((TP_CHIPLET_RE_FIR >> 2) & `1FFFF80000000000`)  & ~TP_CHIPLET_FIR_MASK;
};

group gTpChipletFir filter singlebit
{
    /** TP_CHIPLET_FIR[3]
     *  Attention from TP_LFIR
     */
    (TpChipletFir, bit(3)) ? analyze(gTpLFir);

    /** TP_CHIPLET_FIR[4]
     *  Attention from OCCFIR
     */
    (TpChipletFir, bit(4)) ? analyze(gOccFir);

    /** TP_CHIPLET_FIR[5]
     *  Attention from MCIFIR (MCS 00 Venice only)
     */
    (TpChipletFir, bit(5)) ? analyzeMcs00;

    /** TP_CHIPLET_FIR[6]
     *  Attention from MCIFIR (MCS 01 Venice only)
     */
    (TpChipletFir, bit(6)) ? analyzeMcs01;

    /** TP_CHIPLET_FIR[7]
     *  Attention from MCIFIR (MCS 10 Venice only)
     */
    (TpChipletFir, bit(7)) ? analyzeMcs10;

    /** TP_CHIPLET_FIR[8]
     *  Attention from MCIFIR (MCS 11 Venice only)
     */
    (TpChipletFir, bit(8)) ? analyzeMcs11;

    /** TP_CHIPLET_FIR[9]
     *  Attention from MCIFIR (MCS 20)
     */
    (TpChipletFir, bit(9)) ? analyzeMcs20;

    /** TP_CHIPLET_FIR[10]
     *  Attention from MCIFIR (MCS 21)
     */
    (TpChipletFir, bit(10)) ? analyzeMcs21;

    /** TP_CHIPLET_FIR[11]
     *  Attention from MCIFIR (MCS 30)
     */
    (TpChipletFir, bit(11)) ? analyzeMcs30;

    /** TP_CHIPLET_FIR[12]
     *  Attention from MCIFIR (MCS 31)
     */
    (TpChipletFir, bit(12)) ? analyzeMcs31;

    /** TP_CHIPLET_FIR[13]
     *  Attention from IOMCFIR_0 (Venice only)
     */
    (TpChipletFir, bit(13)) ? defaultMaskedError;

    /** TP_CHIPLET_FIR[14]
     *  Attention from IOMCFIR_1
     */
    (TpChipletFir, bit(14)) ? analyze(gIomcFir_1);

    /** TP_CHIPLET_FIR[15]
     *  Attention from PBAMFIR
     */
    (TpChipletFir, bit(15)) ? analyze(gPbamFir);

    /** TP_CHIPLET_FIR[16|17|18|19]
     *  CS attention from MC 0-3
     */
    (TpChipletFir, bit(16|17|18|19)) ? defaultMaskedError;

    /** TP_CHIPLET_FIR[20]
     *  Attention from PMCFIR
     */
    (TpChipletFir, bit(20)) ? analyze(gPmcFir);
};

rule TpChipletSpa
{
    SPECIAL: TP_CHIPLET_SPA & ~TP_CHIPLET_SPA_MASK;
};

group gTpChipletSpa filter singlebit
{
    /** TP_CHIPLET_SPA[0]
     *  Attention from OCCFIR
     */
    (TpChipletSpa, bit(0)) ? analyze(gOccFir);

    /** TP_CHIPLET_SPA[1]
     *  Attention from MCIFIR_00 (Venice only)
     */
    (TpChipletSpa, bit(1)) ? analyzeMcs00;

    /** TP_CHIPLET_SPA[2]
     *  Attention from MCIFIR_01 (Venice only)
     */
    (TpChipletSpa, bit(2)) ? analyzeMcs01;

    /** TP_CHIPLET_SPA[3]
     *  Attention from MCIFIR_10 (Venice only)
     */
    (TpChipletSpa, bit(3)) ? analyzeMcs10;

    /** TP_CHIPLET_SPA[4]
     *  Attention from MCIFIR_11 (Venice only)
     */
    (TpChipletSpa, bit(4)) ? analyzeMcs11;

    /** TP_CHIPLET_SPA[5]
     *  Attention from MCIFIR_20
     */
    (TpChipletSpa, bit(5)) ? analyzeMcs20;

    /** TP_CHIPLET_SPA[6]
     *  Attention from MCIFIR_21
     */
    (TpChipletSpa, bit(6)) ? analyzeMcs21;

    /** TP_CHIPLET_SPA[7]
     *  Attention from MCIFIR_30
     */
    (TpChipletSpa, bit(7)) ? analyzeMcs30;

    /** TP_CHIPLET_SPA[8]
     *  Attention from MCIFIR_31
     */
    (TpChipletSpa, bit(8)) ? analyzeMcs31;
};

################################################################################
# TP Chiplet LFIR
################################################################################

rule TpLFir
{
  CHECK_STOP:  TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 & ~TP_LFIR_ACT1;
  RECOVERABLE: TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 &  TP_LFIR_ACT1;
};

group gTpLFir filter singlebit
{
    /** TP_LFIR[0]
     *  CFIR internal parity error
     */
    (TpLFir, bit(0)) ? SelfHighThr32PerDay;

    /** TP_LFIR[1]
     *  Local errors from GPIO (PCB error)
     */
    (TpLFir, bit(1)) ? defaultMaskedError;

    /** TP_LFIR[2]
     *  Local errors from CC (PCB error)
     */
    (TpLFir, bit(2)) ? defaultMaskedError;

    /** TP_LFIR[3]
     *  Local errors from CC (OPCG, parity, scan collision, ...)
     */
    (TpLFir, bit(3)) ? SelfHighThr32PerDay;

    /** TP_LFIR[4]
     *  Local errors from PSC (PCB error)
     */
    (TpLFir, bit(4)) ? defaultMaskedError;

    /** TP_LFIR[5]
     *  Local errors from PSC (parity error)
     */
    (TpLFir, bit(5)) ? defaultMaskedError;

    /** TP_LFIR[6]
     *  Local errors from Thermal (parity error)
     */
    (TpLFir, bit(6)) ? defaultMaskedError;

    /** TP_LFIR[7]
     *  Local errors from Thermal (PCB error)
     */
    (TpLFir, bit(7)) ? defaultMaskedError;

    /** TP_LFIR[8|9]
     *  Local errors from Thermal (Trip error)
     */
    (TpLFir, bit(8|9)) ? defaultMaskedError;

    /** TP_LFIR[10]
     *  Local errors from Trace Array ( error)
     */
    #FIXME RTC 23127 bit action suggests threshold 32per day but commnet on bit
    # 10 suggests threshold of 1
    (TpLFir, bit(10)) ? SelfHighThr32PerDay;

    /** TP_LFIR[11]
     *  Local errors from Trace Array ( error)
     */
    (TpLFir, bit(11)) ? SelfHighThr32PerDay;

    /** TP_LFIR[12|13]
     *  Local errors from I2CM
     */
    (TpLFir, bit(12|13)) ? defaultMaskedError;

    /** TP_LFIR[14]
     *  Local errors from PCB
     */
    #FIXME RTC 23127 Comments not clear
    (TpLFir, bit(14)) ? SelfHighThr32PerDay;

    /** TP_LFIR[15]
     *  Local errors from Trace Array ( error)
     */
    (TpLFir, bit(15)) ? defaultMaskedError;

    /** TP_LFIR[16]
     *  Local errors from TOD ( error) Error in backup topology
     */
    (TpLFir, bit(16)) ? defaultMaskedError;

    #FIXME RTC 23127 "First Instance" need clarification
    /** TP_LFIR[17]
     *  Local errors from TOD ( error)
     */
    (TpLFir, bit(17)) ? defaultMaskedError;

    /** TP_LFIR[18]
     *  Local errors from TOD ( error)
     */
    #FIXME RTC 23127 Shall be handled in TOD Activity
    (TpLFir, bit(18)) ? TBDDefaultCallout;

    /** TP_LFIR[19]
     *  Processor PLL error
     *
     *  These should never trigger directly themselves.
     *  Should be handled by global PRD PLL code.
     */
    (TpLFir, bit(19)) ? threshold32pday;

    /** TP_LFIR[20]
     *  Sbe indicated error_event0to4 enabled by mask bit 5 to 9
     */
    (TpLFir, bit(20)) ? defaultMaskedError;

    /** TP_LFIR[21]
     *  Sbe indicated error_event0to4 enabled by mask bit 10 to 14
     */
    (TpLFir, bit(21)) ? defaultMaskedError;

    /** TP_LFIR[22|23]
     *  local errors from I2CS
     */
    (TpLFir, bit(22|23)) ? defaultMaskedError;

    /** TP_LFIR[24]
     *  Local errors from OTP
     */
    (TpLFir, bit(24)) ? defaultMaskedError;

    /** TP_LFIR[25]
     *  local error from Ext trigger
     */
    (TpLFir, bit(25)) ? defaultMaskedError;

    /** TP_LFIR[26]
     *  Fast xstop fir error
     */
    (TpLFir, bit(26)) ? defaultMaskedError;

    /** TP_LFIR[27]
     *   PCB mcast grp error
     */
    (TpLFir, bit(27)) ? SelfHighThr1;

    /** TP_LFIR[28]
     *  PCB Parity error
     */
    (TpLFir, bit(28)) ? defaultMaskedError;

    /** TP_LFIR[29|30]
     *  EECB lpc fir error
     */
    (TpLFir, bit(29|30)) ? defaultMaskedError;

    /** TP_LFIR[31|32]
     *  EECB i2c fir error
     */
    (TpLFir, bit(31|32)) ? defaultMaskedError;

    /** TP_LFIR[33|34]
     *  Local errors from PIBMEM
     */
    (TpLFir, bit(33|34)) ? defaultMaskedError;

    /** TP_LFIR[35]
     *  OTP correctable error
     */
    (TpLFir, bit(35)) ? threshold32pday;

    /** TP_LFIR[36|37|38|39]
     *  Unused error
     */
    (TpLFir, bit(36|37|38|39)) ? defaultMaskedError;

    /** TP_LFIR[40]
     *  Malfunction alert
     */
    (TpLFir, bit(40)) ? defaultMaskedError;

};

################################################################################
# TP Chiplet OCCFIR
################################################################################

rule OccFir
{
    CHECK_STOP:  OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 & ~OCCFIR_ACT1;
    RECOVERABLE: OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 &  OCCFIR_ACT1;
    SPECIAL:     OCCFIR & ~OCCFIR_MASK &  OCCFIR_ACT0 & ~OCCFIR_ACT1;
};

#based on spreadsheet p8dd1_mss_FFDC_51.xls
group gOccFir filter singlebit
{
    /** OCCFIR[0]
     *  OCC_SCOM_OCCFIR_OCC_FW0
     */
    (OccFir, bit(0)) ? defaultMaskedError;

    /** OCCFIR[1]
     *  OCC_SCOM_OCCFIR_OCC_FW1
     */
    (OccFir, bit(1)) ? defaultMaskedError;

    /** OCCFIR[2]
     *  OCC_SCOM_OCCFIR_OCC_FW2
     */
    (OccFir, bit(2)) ? defaultMaskedError;

    /** OCCFIR[3]
     *  OCC_SCOM_OCCFIR_OCC_FW3
     */
    (OccFir, bit(3)) ? defaultMaskedError;

    /** OCCFIR[4]
     *  OCC_SCOM_OCCFIR_PMC_PORE_SW_MALF
     */
    #RTC 23127 ? found in RAS spread sheet.Action need to be updated.
    (OccFir, bit(4)) ? TBDDefaultCallout;

    /** OCCFIR[5]
     *  OCC_SCOM_OCCFIR_PMC_OCC_HB_MALF
     */
    (OccFir, bit(5)) ? defaultMaskedError;

    /** OCCFIR[6]
     *  OCC_SCOM_OCCFIR_PORE_GPE0_FATAL_ERR
     */
    (OccFir, bit(6)) ? defaultMaskedError;

    /** OCCFIR[7]
     *  OCC_SCOM_OCCFIR_PORE_GPE1_FATAL_ERR
     */
    (OccFir, bit(7)) ? defaultMaskedError;

    /** OCCFIR[8]
     *  OCC_SCOM_OCCFIR_OCB_ERROR
     */
    (OccFir, bit(8)) ? defaultMaskedError;

    /** OCCFIR[9]
     *  OCC_SCOM_OCCFIR_SRT_UE
     */
    (OccFir, bit(9)) ? calloutConnectedOccThr1;

    /** OCCFIR[10]
     *  OCC_SCOM_OCCFIR_SRT_CE
     */
    (OccFir, bit(10)) ? defaultMaskedError;

    /** OCCFIR[11]
     *  OCC_SCOM_OCCFIR_SRT_READ_ERROR
     */
    (OccFir, bit(11)) ? calloutConnectedOccThr1;

    /** OCCFIR[12]
     *  OCC_SCOM_OCCFIR_SRT_WRITE_ERROR
     */
    (OccFir, bit(12)) ? calloutConnectedOccThr1;

    /** OCCFIR[13]
     *  OCC_SCOM_OCCFIR_SRT_DATAOUT_PERR
     */
    (OccFir, bit(13)) ? calloutConnectedOccThr1;

    /** OCCFIR[14]
     *  OCC_SCOM_OCCFIR_SRT_OCI_WRITE_DATA_PARITY
     */
    (OccFir, bit(14)) ? calloutConnectedOccThr1;

    /** OCCFIR[15]
     *  OCC_SCOM_OCCFIR_SRT_OCI_BE_PARITY_ER
     */
    (OccFir, bit(15)) ? calloutConnectedOccThr1;

    /** OCCFIR[16]
     *  OCC_SCOM_OCCFIR_SRT_OCI_ADDR_PARITY_ERR
     */
    (OccFir, bit(16)) ? calloutConnectedOccThr1;

    /** OCCFIR[17]
     *  OCC_SCOM_OCCFIR_PORE_SW_ERROR_ERR
     */
    (OccFir, bit(17)) ? defaultMaskedError;

    /** OCCFIR[18]
     *OCC_SCOM_OCCFIR_PORE_GPE0_ERROR_ERR
     */
    (OccFir, bit(18)) ? defaultMaskedError;

    /** OCCFIR[19]
     *  OCC_SCOM_OCCFIR_PORE_GPE1_ERROR_ERR
     */
    (OccFir, bit(19)) ? defaultMaskedError;

    /** OCCFIR[20]
     *  OCC_SCOM_OCCFIR_EXTERNAL_TRAP
     */
    (OccFir, bit(20)) ? defaultMaskedError;

    /** OCCFIR[21]
     *  OCC_SCOM_OCCFIR_PPC405_CORE_RESET
     */
    (OccFir, bit(21)) ? defaultMaskedError;

    /** OCCFIR[22]
     *  OCC_SCOM_OCCFIR_PPC405_CHIP_RESET
     */
    (OccFir, bit(22)) ? defaultMaskedError;

    /** OCCFIR[23]
     *  OCC_SCOM_OCCFIR_PPC405_SYSTEM_RESET
     */
    (OccFir, bit(23)) ? defaultMaskedError;

    /** OCCFIR[24]
     *OCC_SCOM_OCCFIR_PPC405_DBGMSRWE
     */
    (OccFir, bit(24)) ? defaultMaskedError;

    /** OCCFIR[25]
     *  OCC_SCOM_OCCFIR_PPC405_DBGSTOPACK
     */
    (OccFir, bit(25)) ? defaultMaskedError;

    /** OCCFIR[26]
     *  OCC_SCOM_OCCFIR_OCB_DB_OCI_TIMEOUT
     */
    (OccFir, bit(26)) ? calloutConnectedOccThr1;

    /** OCCFIR[27]
     *  OCC_SCOM_OCCFIR_OCB_DB_OCI_READ_DATA_PARITY
     */
    (OccFir, bit(27)) ? calloutConnectedOccThr1;

    /** OCCFIR[28]
     *  OCC_SCOM_OCCFIR_OCB_DB_OCI_SLAVE_ERROR
     */
    (OccFir, bit(28)) ? calloutConnectedOccThr1;

    /** OCCFIR[29]
     *  OCC_SCOM_OCCFIR_OCB_PIB_ADDR_PARITY_ERR
     */
    (OccFir, bit(29)) ? calloutConnectedOccThr1;

    /** OCCFIR[30]
     *  OCC_SCOM_OCCFIR_OCB_DB_PIB_DATA_PARITY_ERR
     */
    (OccFir, bit(30)) ? calloutConnectedOccThr1;

    /** OCCFIR[31]
     *  OCC_SCOM_OCCFIR_OCB_IDC0_ERROR
     */
    (OccFir, bit(31)) ? calloutConnectedOccThr1;

    /** OCCFIR[32]
     *  OCC_SCOM_OCCFIR_OCB_IDC1_ERROR
     */
    (OccFir, bit(32)) ? calloutConnectedOccThr1;

    /** OCCFIR[33]
     *  OCC_SCOM_OCCFIR_OCB_IDC2_ERROR
     */
    (OccFir, bit(33)) ? calloutConnectedOccThr1;

    /** OCCFIR[34]
     *  OCC_SCOM_OCCFIR_OCB_IDC3_ERROR
     */
    (OccFir, bit(34)) ? calloutConnectedOccThr1;

    /** OCCFIR[35]
     *  OCC_SCOM_OCCFIR_SRT_FSM_ERR
     */
    (OccFir, bit(35)) ? calloutConnectedOccThr1;

    /** OCCFIR[36]
     *  OCC_SCOM_OCCFIR_JTAGACC_ERR
     */
    (OccFir, bit(36)) ? defaultMaskedError;

    /** OCCFIR[37]
     *  OCC_SCOM_OCCFIR_OCB_DW_ERR
     */
    (OccFir, bit(37)) ? defaultMaskedError;

    /** OCCFIR[38]
     *  OCC_SCOM_OCCFIR_C405_ECC_UE
     */
    (OccFir, bit(38)) ? calloutConnectedOccThr1;

    /** OCCFIR[39]
     *  OCC_SCOM_OCCFIR_C405_ECC_CE
     */
    (OccFir, bit(39)) ? defaultMaskedError;

    /** OCCFIR[40]
     *  OCC_SCOM_OCCFIR_C405_OCI_MACHINECHECK
     */
        (OccFir, bit(40)) ? defaultMaskedError;

    /** OCCFIR[41]
     *  OCC_SCOM_OCCFIR_SRAM_SPARE_DIRECT_ERROR0
     */
    #FIXME RTC 23127 action for bit 41,42,43,44 are undecided.
    (OccFir, bit(41)) ? TBDDefaultCallout;

    /** OCCFIR[42]
     *  OCC_SCOM_OCCFIR_SRAM_SPARE_DIRECT_ERROR1
     */
    (OccFir, bit(42)) ? TBDDefaultCallout;

    /** OCCFIR[43]
     *  OCC_SCOM_OCCFIR_SRAM_SPARE_DIRECT_ERROR2
     */
    (OccFir, bit(43)) ? TBDDefaultCallout;

    /** OCCFIR[44]
     *  OCC_SCOM_OCCFIR_SRAM_SPARE_DIRECT_ERROR3
     */
    (OccFir, bit(44)) ? TBDDefaultCallout;

    /** OCCFIR[45]
     *  OCC_SCOM_OCCFIR_SLW_OCISLV_ERR
     */
    (OccFir, bit(45)) ? calloutConnectedOccThr1;

    /** OCCFIR[46]
     *  OCC_SCOM_OCCFIR_GPE_OCISLV_ERR
     */
    (OccFir, bit(46)) ? calloutConnectedOccThr1;

    /** OCCFIR[47]
     *  OCC_SCOM_OCCFIR_OCB_OCISLV_ERR
     */
    (OccFir, bit(47)) ? calloutConnectedOccThr1;
    #FIXME RTC23127 actions for bit 48,49 are undecided.
    /** OCCFIR[48]
     *  OCC_SCOM_OCCFIR_C405ICU_M_TIMEOUT
     */
    (OccFir, bit(48)) ? TBDDefaultCallout;

    /** OCCFIR[49]
     *  OCC_SCOM_OCCFIR_C405DCU_M_TIMEOUT
     */
    (OccFir, bit(49)) ? TBDDefaultCallout;

    /** OCCFIR[50|51|52|53|54|55|56|57|58|59|60|61]
     *  OCC_SCOM_OCCLFIR_SPARE_FIR
     */
    (OccFir, bit(50|51|52|53|54|55|56|57|58|59|60|61)) ? defaultMaskedError;

    /** OCCFIR[62|63]
     *  OCC_SCOM_OCCFIR_FIR_PARITY_ERR_DUP
     */
    (OccFir, bit(62|63)) ? defaultMaskedError;
};

################################################################################
# TP Chiplet PBAMFIR
################################################################################

rule PbamFir
{
    CHECK_STOP:  PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 & ~PBAMFIR_ACT1;
    RECOVERABLE: PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 &  PBAMFIR_ACT1;
};

group gPbamFir filter singlebit
{
    /** PBAMFIR[0]
     *  INVALID_TRANSFER_SIZE
     */
    (PbamFir, bit(0)) ? SelfHighThr1;

    /** PBAMFIR[1]
     *  INVALID_COMMAND
     */
    (PbamFir, bit(1)) ? SelfHighThr1;

    /** PBAMFIR[2]
     *  INVALID_ADDRESS_ALIGNMENT
     */
    (PbamFir, bit(2)) ? SelfHighThr1;

    /** PBAMFIR[3]
     *  OPB_ERROR
     */
    (PbamFir, bit(3)) ? SelfHighThr1;

    /** PBAMFIR[4]
     *  OPB_TIMEOUT
     */
    (PbamFir, bit(4)) ? SelfHighThr1;

    /** PBAMFIR[5]
     *  OPB_MASTER_HANG_TIMEOUT
     */
    (PbamFir, bit(5)) ? SelfHighThr1;

    /** PBAMFIR[6]
     *  CMD_BUFFER_PAR_ERR
     */
    (PbamFir, bit(6)) ? SelfHighThr1;

    /** PBAMFIR[7]
     *  DAT_BUFFER_PAR_ERR
     */
    (PbamFir, bit(7)) ? SelfHighThr1;

    /** PBAMFIR[8]
     *  RETURNQ_ERROR
     */
    (PbamFir, bit(8)) ? defaultMaskedError;

    /** PBAMFIR[9]
     *  RESERVED
     */
    (PbamFir, bit(9)) ? defaultMaskedError;

    /** PBAMFIR[10|11]
     *  FIR_PARITY_ERR
     */
    (PbamFir, bit(10|11)) ? defaultMaskedError;

};

################################################################################
# TP Chiplet PMCFIR
################################################################################

rule PmcFir
{
    CHECK_STOP:  PMCFIR & ~PMCFIR_MASK & ~PMCFIR_ACT0 & ~PMCFIR_ACT1;
    RECOVERABLE: PMCFIR & ~PMCFIR_MASK & ~PMCFIR_ACT0 &  PMCFIR_ACT1;
};

group gPmcFir filter singlebit
{
    /** PMCFIR[0]
     *  LFIR_PSTATE_OCI_MASTER_RDERR
     */
    (PmcFir, bit(0)) ? SelfHighThr1;

    /** PMCFIR[1]
     *  LFIR_PSTATE_OCI_MASTER_RDDATA_PARITY_ERR
     */
    (PmcFir, bit(1)) ? SelfHighThr1;

    /** PMCFIR[2]
     *  LFIR_PSTATE_GPST_CHECKBYTE_ERR
     */
    (PmcFir, bit(2)) ? SelfHighThr1;

    /** PMCFIR[3]
     *  LFIR_PSTATE_GACK_TO_ERR
     */
    (PmcFir, bit(3)) ? SelfHighThr1;

    /** PMCFIR[4]
     *  LFIR_PSTATE_PIB_MASTER_NONOFFLINE_ERR
     */
    (PmcFir, bit(4)) ? SelfHighThr1;

    /** PMCFIR[5]
     *  LFIR_PSTATE_PIB_MASTER_OFFLINE_ERR
     */
    (PmcFir, bit(5)) ? SelfHighThr1;

    /** PMCFIR[6]
     *  LFIR_PSTATE_OCI_MASTER_TO_ERR
     */
    (PmcFir, bit(6)) ? SelfHighThr1;

    /** PMCFIR[7]
     *  LFIR_PSTATE_INTERCHIP_UE_ERR
     */
    (PmcFir, bit(7)) ? SelfHighThr1;

    /** PMCFIR[8]
     *  LFIR_PSTATE_INTERCHIP_ERRORFRAME_ERR
     */
    (PmcFir, bit(8)) ? SelfHighThr1;

    /** PMCFIR[9]
     *  LFIR_PSTATE_MS_FSM_ERR
     */
    (PmcFir, bit(9)) ? SelfHighThr1;

    /** PMCFIR[10]
     *  LFIR_MS_COMP_PARITY_ERR
     */
    (PmcFir, bit(10)) ? defaultMaskedError;

    /** PMCFIR[11:17]
     *  LFIR_IDLE
     */
    (PmcFir, bit(11|12|13|14|15|16|17)) ? defaultMaskedError;

    /** PMCFIR[18]
     *  LFIR_INT_COMP_PARITY_ERR
     */
    (PmcFir, bit(18)) ? defaultMaskedError;

    /** PMCFIR[19]
     *  LFIR_PMC_OCC_HEARTBEAT_TIMEOUT
     */
    (PmcFir, bit(19)) ? defaultMaskedError;

    /** PMCFIR[20:25]
     *  LFIR_SPIVID
     */
    (PmcFir, bit(20|21|22|23|24|25)) ? defaultMaskedError;

    /** PMCFIR[26:32]
     *  LFIR_O2S
     */
    (PmcFir, bit(26|27|28|29|30|31|32)) ? defaultMaskedError;

    /** PMCFIR[33:24]
     *  LFIR_O2P
     */
    (PmcFir, bit(33|34)) ? defaultMaskedError;

    /** PMCFIR[35]
     *  LFIR_OCI_SLAVE_ERR
     */
    (PmcFir, bit(35)) ? defaultMaskedError;

    /** PMCFIR[36]
     *  LFIR_IF_COMP_PARITY_ERROR
     */
    (PmcFir, bit(36)) ? defaultMaskedError;

    /** PMCFIR[37:46]
     *  SPARE
     */
    (PmcFir, bit(37|38|39|40|41|42|43|44|45|46)) ? defaultMaskedError;

    /** PMCFIR[47|48]
     *  FIR_PARITY_ERR
     */
    (PmcFir, bit(47|48)) ? defaultMaskedError;
};

################################################################################
# Actions specific to TP chiplet
################################################################################

/** Analyze connected MCS 00 */
actionclass analyzeMcs00
{
    analyze(connected(TYPE_MCS, 0));
    funccall("MaskMCS00IfCentaurCheckstop");
};

/** Analyze connected MCS 01 */
actionclass analyzeMcs01
{
    analyze(connected(TYPE_MCS, 1));
    funccall("MaskMCS01IfCentaurCheckstop");
};

/** Analyze connected MCS 10 */
actionclass analyzeMcs10
{
    analyze(connected(TYPE_MCS, 2));
    funccall("MaskMCS10IfCentaurCheckstop");
};

/** Analyze connected MCS 11 */
actionclass analyzeMcs11
{
    analyze(connected(TYPE_MCS, 3));
    funccall("MaskMCS11IfCentaurCheckstop");
};

/** Analyze connected MCS 20 */
actionclass analyzeMcs20
{
    analyze(connected(TYPE_MCS, 4));
    funccall("MaskMCS20IfCentaurCheckstop");
};

/** Analyze connected MCS 21 */
actionclass analyzeMcs21
{
    analyze(connected(TYPE_MCS, 5));
    funccall("MaskMCS21IfCentaurCheckstop");
};

/** Analyze connected MCS 30 */
actionclass analyzeMcs30
{
    analyze(connected(TYPE_MCS, 6));
    funccall("MaskMCS30IfCentaurCheckstop");
};

/** Analyze connected MCS 31 */
actionclass analyzeMcs31
{
    analyze(connected(TYPE_MCS, 7));
    funccall("MaskMCS31IfCentaurCheckstop");
};

/** Callout the connected OCC */
actionclass calloutConnectedOccThr1
{
   threshold1;
   callout ( connected(TYPE_OCC, 0), MRU_MED );
};
