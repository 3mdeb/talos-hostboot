# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Mcs.rule $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2012,2013
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG

################################################################################
#
# Scope:
#   Registers and actions for the following chiplets:
#       Note that only addresses for MC0/MCS0 will be used.
#
# Chiplet  Register Addresses       Description
# =======  =======================  ============================================
#   MCS    0x02011800 - 0x0201187F  MC0/MCS0
#   MCS    0x02011880 - 0x020118FF  MC0/MCS1
#   MCS    0x02011900 - 0x0201197F  MC1/MCS0
#   MCS    0x02011980 - 0x020119FF  MC1/MCS1
#   MCS    0x02011A00 - 0x02011A3E  DMI0 - DMI3
#   MCS    0x02011C00 - 0x02011C7F  MC2/MCS0
#   MCS    0x02011C80 - 0x02011CFF  MC2/MCS1
#   MCS    0x02011D00 - 0x02011D7F  MC3/MCS0
#   MCS    0x02011D80 - 0x02011DFF  MC3/MCS1
#   MCS    0x02011E00 - 0x02011E3E  DMI4 - DMI7
#
################################################################################

chip Mcs
{
    name        "Power8 MCS Chiplet";
    targettype  TYPE_MCS;
    sigoff      0x8000;
# FIXME May need to update dump type
    dump        DUMP_CONTENT_HW;
    scomlen     64;

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # PB Chiplet MCIFIR
    ############################################################################

    register MCIFIR
    {
        name        "MC0.MCS0.RIGHT.MCI.SCOMFIR.MCIFIRQ";
        scomaddr    0x02011840;
        reset       (&, 0x02011841);
        mask        (|, 0x02011845);
        capture     group default;
        capture     group FirRegs;
    };

    register MCIFIR_AND
    {
        name        "MC0.MCS0.RIGHT.MCI.SCOMFIR.MCIFIRQ AND";
        scomaddr    0x02011841;
        capture     group never;
        access      write_only;
    };

    register MCIFIR_MASK
    {
        name        "MC0.MCS0.RIGHT.MCI.SCOMFIR.MCIFIRMASK";
        scomaddr    0x02011843;
        capture     group default;
        capture     group FirRegs;
    };

    register MCIFIR_ACT0
    {
        name        "MC0.MCS0.RIGHT.MCI.SCOMFIR.MCIFIRACT0";
        scomaddr    0x02011846;
        capture     type secondary;
        capture     group default;
        capture     group FirRegs;
        capture     req nonzero("MCIFIR");
    };

    register MCIFIR_ACT1
    {
        name        "MC0.MCS0.RIGHT.MCI.SCOMFIR.MCIFIRACT1";
        scomaddr    0x02011847;
        capture     type secondary;
        capture     group default;
        capture     group FirRegs;
        capture     req nonzero("MCIFIR");
    };

    ############################################################################
    # Error Report Registers
    ############################################################################

    register MCERPT0
    {
        name        "MC0.MCS0.LEFT.LEFT.MCERPT0";
        scomaddr    0x0201181E;
        capture     group default;
        capture     group CerrRegs;
    };

    register MCIERPT0
    {
        name        "MC0.MCS0.RIGHT.MCI.MCIERPT0";
        scomaddr    0x0201184E;
        capture     group default;
        capture     group CerrRegs;
    };

};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# PB Chiplet MCIFIR
################################################################################
# MCIFIR updated based on p8dd1_mss_FFDC_37_ reviewd.xls
###############################################################################
rule MciFir
{
    CHECK_STOP:  MCIFIR & ~MCIFIR_MASK & ~MCIFIR_ACT0 & ~MCIFIR_ACT1;
    RECOVERABLE: MCIFIR & ~MCIFIR_MASK & ~MCIFIR_ACT0 &  MCIFIR_ACT1;
    SPECIAL:     MCIFIR & ~MCIFIR_MASK &  MCIFIR_ACT0 & ~MCIFIR_ACT1;

    # All of the Centaur CS (channel fail) bits set as recoverable.
    UNIT_CS:     MCIFIR & ~MCIFIR_MASK & ~MCIFIR_ACT0 &  MCIFIR_ACT1;
};

group gMciFir attntype CHECK_STOP, RECOVERABLE, SPECIAL, UNIT_CS
      filter priority( 0, 1, 6, 8, 9, 12, 22, 23, 40 ) # Centaur CS FIR bits
{
    /** MCIFIR[0]
     *  MCIFIRQ_REPLAY_TIMEOUT
     */
    (MciFir, bit(0)) ? calloutDmiBusTh1;

    /** MCIFIR[1]
     *  MCIFIRQ_CHANNEL_FAIL
     */
    (MciFir, bit(1)) ? defaultMaskedError;

    /** MCIFIR[2]
     *  MCIFIRQ_CRC_ERROR
     */
    (MciFir, bit(2)) ? defaultMaskedError;

    /** MCIFIR[3]
     *  MCIFIRQ_FRAME_NOACK
     */
    (MciFir, bit(3)) ? defaultMaskedError;

    /** MCIFIR[4]
     *  MCIFIRQ_SEQID_OUT_OF_ORDER
     */
    (MciFir, bit(4)) ? calloutDmiBusAndLvl2Th1;

    /** MCIFIR[5]
     *  MCIFIRQ_REPLAY_BUFFER_ECC_CE
     */
    (MciFir, bit(5)) ? SelfHighThr5PerHour;

    /** MCIFIR[6]
     *  MCIFIRQ_REPLAY_BUFFER_ECC_UE
     */
    (MciFir, bit(6)) ? SelfHighThr1 ;

    /** MCIFIR[7]
     *  MCIFIRQ_MCI_CHINIT_STATE_MACHINE_TIMEOUT
     */
    (MciFir, bit(7)) ? defaultMaskedError;

    /** MCIFIR[8]
     *  MCIFIRQ_MCI_INTERNAL_CONTROL_PARITY_ERROR
     */
    (MciFir, bit(8)) ? SelfHighThr1;

    /** MCIFIR[9]
     *  MCIFIRQ_MCI_DATA_FLOW_PARITY_ERROR
     */
    (MciFir, bit(9)) ? SelfHighThr1;

    /** MCIFIR[10]
     *  MCIFIRQ_CRC_PERFORMANCE_DEGRADATION
     */
    (MciFir, bit(10)) ? analyzeSpareBitAndThr;

    /** MCIFIR[11]
     *  MCIFIRQ_CHANNEL_INTERLOCK_FAIL
     */
    (MciFir, bit(11)) ? defaultMaskedError;

    /** MCIFIR[12]
     *  MCIFIRQ_CENTAUR_CHECKSTOP
     */
    # NOTE: When set, this bit will trigger MCIFIR[31] (channel checkstop).
    #       This bit will be set as a recoverable attention, so that PRD will
    #       be called to analyze the recoverable attention in the P8 and
    #       change then attention type to UNIT_CS because bit 31 is on. Then PRD
    #       will analyze the Centaur for the root case of the unit checkstop.
    # NOTE: This bit will be masked at runtime.
    (MciFir, bit(12)) ? analyzeConnectedCentaur;

    /** MCIFIR[13]
     *  MCIFIRQ_CENTAUR_TRACESTOP
     */
    (MciFir, bit(13)) ? defaultMaskedError;

    /** MCIFIR[14]
     *  MCIFIRQ_FPGA_INTERRUPT
     */
    (MciFir, bit(14)) ? defaultMaskedError;

    /** MCIFIR[15]
     *  MCIFIRQ_CENTAUR_RECOVERABLE_ERROR
     */
    # NOTE: This bit will be set to host_attn during hostboot and masked at
    #       runtime.
    (MciFir, bit(15)) ? defaultMaskedError;

    /** MCIFIR[16]
     *  MCIFIRQ_CENTAUR_SPECIAL_ATTENTION
     */
    # NOTE: This bit will be set to host_attn during hostboot and masked at
    #       runtime.
    (MciFir, bit(16)) ? defaultMaskedError;

    /** MCIFIR[17]
     *  MCIFIRQ_CENTAUR_MAINTENANCE_COMPLETE
     */
    # NOTE: This bit will be set to host_attn during hostboot and masked at
    #       runtime.
    (MciFir, bit(17)) ? defaultMaskedError;

    /** MCIFIR[18]
     *  MCIFIRQ_CENTAUR_INBAND_PIB_ERROR
     */
    (MciFir, bit(18)) ? defaultMaskedError;

    /** MCIFIR[19]
     *  FRTL Conter Overflow
     */
    (MciFir, bit(19)) ? defaultMaskedError;

    /** MCIFIR[20]
     *  SCOM Register parity Error
     */
    (MciFir, bit(20)) ? SelfHighThr1;

    /** MCIFIR[21]
     *  SCOM Register parity Error
     */
    (MciFir, bit(21)) ? defaultMaskedError;

    /** MCIFIR[22]
     *  SCOM Register parity Error
     */
    (MciFir, bit(22)) ? calloutConnCenTh1;

    /** MCIFIR[23]
     *  SCOM Register parity Error
     */
    (MciFir, bit(23)) ? calloutDmiBusTh1;

    /** MCIFIR[24]
     *  MCIFIRQ_MCS_RECOVERABLE_ERROR
     */
    (MciFir, bit(24)) ? SelfHighThr1;

    /** MCIFIR[25]
     *  MCIFIRQ_MCS_INTERNAL_NONRECOVERABLE_ERROR
     */
    (MciFir, bit(25)) ? SelfHighThr1;

    /** MCIFIR[26]
     *  MCIFIRQ_POWERBUS_PROTOCOL_ERROR
     */
    (MciFir, bit(26)) ? callout2ndLvlMedThr1;

    /** MCIFIR[27]
     *  MCIFIRQ_MCS_COMMAND_LIST_TIMEOUT_DUE_TO_POWERBUS
     */
    (MciFir, bit(27)) ? callout2ndLvlMedThr1;

    /** MCIFIR[28]
     *  MCIFIRQ_MULTIPLE_RCMD_OR_CRESP_ACTIVE
     */
    (MciFir, bit(28)) ? SelfLowLevel2MedThr1;

    /** MCIFIR[29]
     *  MCIFIRQ_INBAND_BAR_HIT_WITH_INCORRECT_TTYPE
     */
    (MciFir, bit(29)) ? SelfLowLevel2MedThr1;

    /** MCIFIR[30]
     *  MCIFIRQ_MULTIPLE_BAR_HIT
     */
    (MciFir, bit(30)) ? SelfLowLevel2MedThr1;

    /** MCIFIR[31]
     *  MCIFIRQ_CHANNEL_FAIL_SIGNAL_ACTIVE
     */
    # NOTE: PRD checks this bit anytime it is called to analyze the MCS. It is
    #       intended to indicate that another bit in this FIR signaled a channel
    #       failure/checkstop. It should always be masked.
    (MciFir, bit(31)) ? defaultMaskedError;

    /** MCIFIR[32]
     *  MCIFIRQ_MIRROR_ACTION_OCCURRED
     */
    # FIXME RTC 23127 TBD if this is needed as part of mirror error handling
    (MciFir, bit(32)) ? defaultMaskedError;

    /** MCIFIR[33]
     *  MCIFIRQ_NONFOREIGN_ACCESS_TO_FOREIGN_BAR
     */
    (MciFir, bit(33)) ? callout2ndLvlMedThr1;

    /** MCIFIR[34]
     *  MCIFIRQ_CENTAUR_SYNC_COMMAND_DETECTED
     */
    (MciFir, bit(34)) ? defaultMaskedError;

    /** MCIFIR[35]
     *  MCIFIRQ_POWERBUS_WRITE_DATA_BUFFER_CE
     */
    (MciFir, bit(35)) ? calloutProcHighThr5PerHr;

    /** MCIFIR[36]
     *  MCIFIRQ_POWERBUS_WRITE_DATA_BUFFER_UE
     */
    (MciFir, bit(36)) ? calloutParentProcHighThr1;

    /** MCIFIR[37]
     *  MCIFIRQ_POWERBUS_WRITE_DATA_BUFFER_SUE
     */
    (MciFir, bit(37)) ? defaultMaskedError;

    /** MCIFIR[38]
     *  MCIFIRQ_HA_ILLEGAL_CONSUMER_ACCESS_ERROR
     */
    (MciFir, bit(38)) ? callout2ndLvlMedThr1;

    /** MCIFIR[39]
     *  MCIFIRQ_HA_ILLEGAL_PRODUCER_ACCESS_ERROR
     */
    (MciFir, bit(39)) ? callout2ndLvlMedThr1;

    /** MCIFIR[40]
     *  CHANNEL TIMEOUT ERROR
     */
    # FIXME RTC 23127 No decision on MRU  as yet
    (MciFir, bit(40)) ? defaultMaskedError;

    /** MCIFIR[41]
     *  CENTAUR FAULT LINE
     */
    (MciFir, bit(41)) ? defaultMaskedError;

    /** MCIFIR[42]
     *  MCS WAT
     */
    (MciFir, bit(42)) ? defaultMaskedError;

    /** MCIFIR[43]
     *  INVALID ADDRESS
     */
    (MciFir, bit(43)) ? defaultMaskedError;

    /** MCIFIR[44|45|46]
     *  Reserved
     */
    (MciFir, bit(44|45|46)) ? defaultMaskedError;

    /** MCIFIR[47]
     *  MCS WRITE DATAFLOW SUE
     */
    (MciFir, bit(47)) ? defaultMaskedError;

    /** MCIFIR[48]
     *  MCIFIRQ_INTERNAL_SCOM_ERROR
     */
    (MciFir, bit(48)) ? defaultMaskedError;

    /** MCIFIR[49]
     *  MCIFIRQ_INTERNAL_SCOM_ERROR_CLONE
     */
    (MciFir, bit(49)) ? defaultMaskedError;
};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the common action set.
.include "CommonActions.rule"

/** Analyze the connected Centaur */
actionclass analyzeConnectedCentaur { analyze(connected(TYPE_MEMBUF)); };

actionclass calloutProcHighThr5PerHr
{
    callout(connected(TYPE_PROC),MRU_HIGH);
    threshold5phour;
};

/** Callout the connected Centaur, threshold 1 */
actionclass calloutConnCenTh1
{
    callout(connected(TYPE_MEMBUF), MRU_MED);
    threshold1;
};

/** Callout the DMI bus (MEDA) */
actionclass calloutDmiBus
{
    calloutSelfMedA;
    callout(connected(TYPE_MEMBUF), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus (MEDA), threshold 1 */
actionclass calloutDmiBusTh1
{
    calloutDmiBus;
    threshold1;
};

/** Callout the DMI bus (MEDA) and 2nd Level Support (LOW), threshold 1 */
actionclass calloutDmiBusAndLvl2Th1
{
   calloutDmiBusTh1;
   callout2ndLvlLow;
};

actionclass CalloutDmiBusAndThr2pd
{
    calloutDmiBus;
    threshold2pday;
};

actionclass analyzeSpareBitAndThr
{
    try( funccall("checkSpareBit"), CalloutDmiBusAndThr2pd );
};
