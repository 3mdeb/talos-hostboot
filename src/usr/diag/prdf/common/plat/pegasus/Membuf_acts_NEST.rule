# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Membuf_acts_NEST.rule $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2012,2013
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG

################################################################################
# NEST Chiplet Registers
################################################################################

rule NestChipletFir
{
  CHECK_STOP:
     (NEST_CHIPLET_CS_FIR       & `17fe000000000000`) & ~NEST_CHIPLET_FIR_MASK;
  UNIT_CS:
     (NEST_CHIPLET_CS_FIR       & `17fe000000000000`) & ~NEST_CHIPLET_FIR_MASK;
  RECOVERABLE:
    ((NEST_CHIPLET_RE_FIR >> 2) & `17fc000000000000`) & ~NEST_CHIPLET_FIR_MASK;
};

group gNestChipletFir filter singlebit
{
    /** NEST_CHIPLET_FIR[3]
     *  Attention from LFIR
     */
    (NestChipletFir, bit(3)) ? analyze(gNestLFir);

    /** NEST_CHIPLET_FIR[5]
     *  Attention from DMIFIR
     */
    (NestChipletFir, bit(5)) ? analyze(gDmiFir);

    /** NEST_CHIPLET_FIR[6]
     *  Attention from MBIFIR
     */
    (NestChipletFir, bit(6)) ? analyze(gMbiFir);

    /** NEST_CHIPLET_FIR[7]
     *  Attention from MBSFIR
     */
    (NestChipletFir, bit(7)) ? analyze(gMbsFir);

    /** NEST_CHIPLET_FIR[8|9]
     *  Attention from MCBISTFIRs
     */
    (NestChipletFir, bit(8|9)) ? analyze(gMcbistFir);

    /** NEST_CHIPLET_FIR[10|11]
     *  Attention from MBSECCFIRs
     */
    (NestChipletFir, bit(10|11)) ? analyze(gMbsEccFir);

    /** NEST_CHIPLET_FIR[12]
     *  Attention from NESTFBISTFIR
     */
    (NestChipletFir, bit(12))? defaultMaskedError;

    /** NEST_CHIPLET_FIR[13]
     *  Attention from SCACFIR
     */
    (NestChipletFir, bit(13)) ? analyze(gScacFir);

    /** NEST_CHIPLET_FIR[14]
     *  Attention from MBS secure FIR
     */
    (NestChipletFir, bit(14))? analyze(gMbsSecureFir); # Checkstop only
};

################################################################################
# NEST Chiplet LFIR
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule NestLFir
{
  CHECK_STOP:  NEST_LFIR & ~NEST_LFIR_MASK & ~NEST_LFIR_ACT0 & ~NEST_LFIR_ACT1;
  UNIT_CS:     NEST_LFIR & ~NEST_LFIR_MASK & ~NEST_LFIR_ACT0 & ~NEST_LFIR_ACT1;
  RECOVERABLE: NEST_LFIR & ~NEST_LFIR_MASK & ~NEST_LFIR_ACT0 &  NEST_LFIR_ACT1;
};

group gNestLFir filter singlebit
{
    /** NEST_LFIR[0]
     *  CFIR internal parity error
     */
    #TODO via RTC 23125
    # bit is not defined in RAS spreadsheet
    (NestLFir, bit(0)) ? TBDDefaultCallout;

    /** NEST_LFIR[1]
     *  Local errors from GPIO (PCB error)
     */
    (NestLFir, bit(1)) ? defaultMaskedError;

    /** NEST_LFIR[2]
     *  Local errors from CC (PCB error)
     */
    (NestLFir, bit(2)) ? defaultMaskedError;

    /** NEST_LFIR[3]
     *  Local errors from CC (OPCG, parity, scan collision, ...)
     */
    (NestLFir, bit(3)) ? SelfMedThr1;

    /** NEST_LFIR[4]
     *  Local errors from PSC (PCB error)
     */
    (NestLFir, bit(4)) ? defaultMaskedError;

    /** NEST_LFIR[5]
     *  Local errors from PSC (parity error)
     */
    (NestLFir, bit(5)) ? defaultMaskedError;

    #TODO via RTC 23125
    # bit is defined in RAS spreadsheet but some question are present there.
    /** NEST_LFIR[6]
     *  Local errors from Thermal (parity error)
     */
    (NestLFir, bit(6)) ? SelfMedThr1;

    #TODO via RTC 23125
    # bit is defined in RAS spreadsheet but some question are present there.
    /** NEST_LFIR[7]
     *  Local errors from Thermal (PCB error)
     */
    (NestLFir, bit(7)) ? SelfMedThr1;

    /** NEST_LFIR[8:10]
     *  Local errors from Thermal (Trip error)
     */
    (NestLFir, bit(8|9|10)) ? defaultMaskedError;

    /** NEST_LFIR[11:12]
     *  Local errors from Trace Array ( error)
     */
    (NestLFir, bit(11|12)) ? defaultMaskedError;

    /** NEST_LFIR[40]
     *  Malfunction alert
     */
    (NestLFir, bit(40)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet DMIFIR
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule DmiFir
{
    CHECK_STOP:  DMIFIR & ~DMIFIR_MASK & ~DMIFIR_ACT0 & ~DMIFIR_ACT1;
    UNIT_CS:     DMIFIR & ~DMIFIR_MASK & ~DMIFIR_ACT0 & ~DMIFIR_ACT1;
    RECOVERABLE: DMIFIR & ~DMIFIR_MASK & ~DMIFIR_ACT0 &  DMIFIR_ACT1;
};

group gDmiFir filter singlebit
{
    /** DMIFIR[0]
     *  FIR_RX_INVALID_STATE_OR_PARITY_ERROR
     */
    (DmiFir, bit(0)) ? defaultMaskedError;

    /** DMIFIR[1]
     *  FIR_TX_INVALID_STATE_OR_PARITY_ERROR
     */
    (DmiFir, bit(1)) ? defaultMaskedError;

    /** DMIFIR[2]
     *  FIR_GCR_HANG_ERROR
     */
    (DmiFir, bit(2)) ? SelfHighThr1;

    /** DMIFIR[3:7]
     *  Reserved
     */
    (DmiFir, bit(3|4|5|6|7)) ? defaultMaskedError;

    /** DMIFIR[8]
     *  Training Error
     */
    (DmiFir, bit(8)) ? defaultMaskedError;

    /** DMIFIR[9]
     *  Spare Deployed
     */
    (DmiFir, bit(9)) ? spareDeployed;

    /** DMIFIR[10]
     *  Max Spares Exceeded
     */
    (DmiFir, bit(10)) ? maxSparesExceeded;

    /** DMIFIR[11]
     *  Recalibration or Dynamic Repair Error
     */
    (DmiFir, bit(11)) ? calloutDmiBusTh1;

    /** DMIFIR[12]
     *  Too Many Bus Errors
     */
    (DmiFir, bit(12)) ? defaultMaskedError;

    /** DMIFIR[13:15]
     *  Reserved
     */
    (DmiFir, bit(13|14|15)) ? defaultMaskedError;

    /** DMIFIR[16:23]
     *  FIR_RX_BUS1 unused
     */
    (DmiFir, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** DMIFIR[24:31]
     *  FIR_RX_BUS2 unused
     */
    (DmiFir, bit(24|25|26|27|28|29|30|31)) ? defaultMaskedError;

    /** DMIFIR[32:39]
     *  FIR_RX_BUS3 unused
     */
    (DmiFir, bit(32|33|34|35|36|37|38|39)) ? defaultMaskedError;

    /** DMIFIR[40:47]
     *  FIR_RX_BUS4 unused
     */
    (DmiFir, bit(40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** DMIFIR[48]
     *  FIR_SCOMFIR_ERROR
     */
    (DmiFir, bit(48)) ? defaultMaskedError;

    /** DMIFIR[49]
     *  FIR_SCOMFIR_ERROR_CLONE
     */
    (DmiFir, bit(49)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet ScacFir
################################################################################

rule ScacFir
{
    CHECK_STOP:  SCACFIR & ~SCACFIR_MASK & ~SCACFIR_ACT0 & ~SCACFIR_ACT1;
    UNIT_CS:     SCACFIR & ~SCACFIR_MASK & ~SCACFIR_ACT0 & ~SCACFIR_ACT1;
    RECOVERABLE: SCACFIR & ~SCACFIR_MASK & ~SCACFIR_ACT0 &  SCACFIR_ACT1;
};

group gScacFir filter singlebit
{
    /** SCACFIR[0]
     *  SCAC_LFIR_I2CMINVADDR
     */
    (ScacFir, bit(0)) ? TBDDefaultCallout;

    /** SCACFIR[1]
     *  SCAC_LFIR_I2CMINVWRITE
     */
    (ScacFir, bit(1)) ? TBDDefaultCallout;

    /** SCACFIR[2]
     *  SCAC_LFIR_I2CMINVREAD
     */
    (ScacFir, bit(2)) ? TBDDefaultCallout;

    /** SCACFIR[3]
     *  SCAC_LFIR_I2CMAPAR
     */
    (ScacFir, bit(3)) ? TBDDefaultCallout;

    /** SCACFIR[4]
     *  SCAC_LFIR_I2CMPAR
     */
    (ScacFir, bit(4)) ? TBDDefaultCallout;

    /** SCACFIR[5]
     *  SCAC_LFIR_I2CMLBPAR
     */
    (ScacFir, bit(5)) ? TBDDefaultCallout;

    /** SCACFIR[10]
     *  SCAC_LFIR_I2CMINVCMD
     */
    (ScacFir, bit(10)) ? TBDDefaultCallout;

    /** SCACFIR[11]
     *  SCAC_LFIR_I2CMPERR
     */
    (ScacFir, bit(11)) ? TBDDefaultCallout;

    /** SCACFIR[12]
     *  SCAC_LFIR_I2CMOVERRUN
     */
    (ScacFir, bit(12)) ? TBDDefaultCallout;

    /** SCACFIR[13]
     *  SCAC_LFIR_I2CMACCESS
     */
    (ScacFir, bit(13)) ? TBDDefaultCallout;

    /** SCACFIR[14]
     *  SCAC_LFIR_I2CMARB
     */
    (ScacFir, bit(14)) ? TBDDefaultCallout;

    /** SCACFIR[15]
     *  SCAC_LFIR_I2CMNACK
     */
    (ScacFir, bit(15)) ? TBDDefaultCallout;

    /** SCACFIR[16]
     *  SCAC_LFIR_I2CMSTOP
     */
    (ScacFir, bit(16)) ? TBDDefaultCallout;

    /** SCACFIR[17]
     *  SCAC_LFIR_LOCALPIB1
     */
    (ScacFir, bit(17)) ? TBDDefaultCallout;

    /** SCACFIR[18]
     *  SCAC_LFIR_LOCALPIB2
     */
    (ScacFir, bit(18)) ? TBDDefaultCallout;

    /** SCACFIR[19]
     *  SCAC_LFIR_LOCALPIB3
     */
    (ScacFir, bit(19)) ? TBDDefaultCallout;

    /** SCACFIR[20]
     *  SCAC_LFIR_LOCALPIB4
     */
    (ScacFir, bit(20)) ? TBDDefaultCallout;

    /** SCACFIR[21]
     *  SCAC_LFIR_LOCALPIB5
     */
    (ScacFir, bit(21)) ? TBDDefaultCallout;

    /** SCACFIR[22]
     *  SCAC_LFIR_LOCALPIB6
     */
    (ScacFir, bit(22)) ? TBDDefaultCallout;

    /** SCACFIR[23]
     *  SCAC_LFIR_LOCALPIB7
     */
    (ScacFir, bit(23)) ? TBDDefaultCallout;

    /** SCACFIR[24]
     *  SCAC_LFIR_STALLERROR
     */
    (ScacFir, bit(24)) ? TBDDefaultCallout;

    /** SCACFIR[25]
     *  SCAC_LFIR_REGPARERR
     */
    (ScacFir, bit(25)) ? TBDDefaultCallout;

    /** SCACFIR[26]
     *  SCAC_LFIR_REGPARERRX
     */
    (ScacFir, bit(26)) ? TBDDefaultCallout;

    /** SCACFIR[32]
     *  SCAC_LFIR_SMERR
     */
    (ScacFir, bit(32)) ? TBDDefaultCallout;

    /** SCACFIR[33]
     *  SCAC_LFIR_REGACCERR
     */
    (ScacFir, bit(33)) ? TBDDefaultCallout;

    /** SCACFIR[34]
     *  SCAC_LFIR_RESETERR
     */
    (ScacFir, bit(34)) ? TBDDefaultCallout;

    /** SCACFIR[35]
     *  SCAC_LFIR_INTERNAL_SCOM_ERROR
     */
    (ScacFir, bit(35)) ? TBDDefaultCallout;

    /** SCACFIR[36]
     *  SCAC_LFIR_INTERNAL_SCOM_ERROR_CLONE
     */
    (ScacFir, bit(36)) ? TBDDefaultCallout;
};

################################################################################
#  NEST Chiplet MBIFIR
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule MbiFir
{
    CHECK_STOP:  MBIFIR & ~MBIFIR_MASK & ~MBIFIR_ACT0 & ~MBIFIR_ACT1;
    UNIT_CS:     MBIFIR & ~MBIFIR_MASK & ~MBIFIR_ACT0 & ~MBIFIR_ACT1;
    RECOVERABLE: MBIFIR & ~MBIFIR_MASK & ~MBIFIR_ACT0 &  MBIFIR_ACT1;
};

group gMbiFir filter singlebit
{
    /** MBIFIR[0]
     *  MBIFIRQ_REPLAY_TIMEOUT
     */
    (MbiFir, bit(0)) ? calloutDmiBusTh1;

    /** MBIFIR[1]
     *  MBIFIRQ_CHANNEL_FAIL
     */
    (MbiFir, bit(1)) ? defaultMaskedError;

    /** MBIFIR[2]
     *  MBIFIRQ_CRC_ERROR
     */
    (MbiFir, bit(2)) ? defaultMaskedError;

    /** MBIFIR[3]
     *  MBIFIRQ_FRAME_NOACK
     */
    (MbiFir, bit(3)) ? defaultMaskedError;

    /** MBIFIR[4]
     *  MBIFIRQ_SEQID_OUT_OF_ORDER
     */
    (MbiFir, bit(4)) ? calloutDmiBusLvl2Th1;

    /** MBIFIR[5]
     *  MBIFIRQ_REPLAY_BUFFER_ECC_CE
     */
    (MbiFir, bit(5)) ? SelfMedThr5PerHour;

    /** MBIFIR[6]
     *  MBIFIRQ_REPLAY_BUFFER_ECC_UE
     */
    (MbiFir, bit(6)) ? SelfMedThr1;

    /** MBIFIR[7]
     *  MBIFIRQ_MBI_STATE_MACHINE_TIMEOUT
     */
    (MbiFir, bit(7)) ? defaultMaskedError;

    /** MBIFIR[8]
     *  MBIFIRQ_MBI_INTERNAL_CONTROL_PARITY_ERROR
     */
    (MbiFir, bit(8)) ? SelfMedThr1;

    /** MBIFIR[9]
     *  MBIFIRQ_MBI_DATA_FLOW_PARITY_ERROR
     */
    (MbiFir, bit(9)) ? SelfMedThr1;

    /** MBIFIR[10]
     *  MBIFIRQ_CRC_PERFORMANCE_DEGRADATION
     */
    (MbiFir, bit(10)) ? analyzeSpareBitAndThr;

    /** MBIFIR[11]
     *  MBIFIRQ_HOST_MC_GLOBAL_CHECKSTOP
     */
    (MbiFir, bit(11)) ? defaultMaskedError;

    /** MBIFIR[12]
     *  MBIFIRQ_HOST_MC_TRACESTOP
     */
    (MbiFir, bit(12)) ? defaultMaskedError;

    /** MBIFIR[13]
     *  MBIFIRQ_CHANNEL_INTERLOCK_FAIL
     */
    (MbiFir, bit(13)) ? defaultMaskedError;

    /** MBIFIR[14]
     *  MBIFIRQ_HOST_MC_LOCAL_CHECKSTOP
     */
    (MbiFir, bit(14)) ? defaultMaskedError;

    /** MBIFIR[15]
     *  MBIFIRQ_FRTL_CONTER_OVERFLOW
     */
    (MbiFir, bit(15)) ? defaultMaskedError;

    /** MBIFIR[16]
     *  MBIFIRQ_SCOM_REGISTER_PARITY_ERROR
     */
    (MbiFir, bit(16)) ? SelfMedThr1;

    /** MBIFIR[17]
     *  MBIFIRQ_IO_FAULT: IO to MBI
     */
    (MbiFir, bit(17)) ? defaultMaskedError;

    /** MBIFIR[18]
     *  MBIFIRQ_MULTIPLE_REPLAY
     */
    (MbiFir, bit(18)) ? defaultMaskedError;

    /** MBIFIR[19]
     *  MBIFIRQ_MBICFG_PARITY_SCOM_ERROR
     */
    (MbiFir, bit(19)) ? SelfMedThr1;

    /** MBIFIR[20]
     *  MBIFIRQ_BUFFER_OVERRUN_ERROR
     */
    (MbiFir, bit(20)) ? calloutDmiBusTh1;

    /** MBIFIR[21:24]
     *  Reserved
     */
    (MbiFir, bit(21|22|23|24)) ? defaultMaskedError;

    /** MBIFIR[25]
     *  MBIFIRQ_INTERNAL_SCOM_ERROR_CLONE
     */
    (MbiFir, bit(25)) ? defaultMaskedError;

    /** MBIFIR[26]
     *  MBIFIRQ_INTERNAL_SCOM_ERROR_CLONE_COPY
     */
    (MbiFir, bit(26)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet MBSFIR
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls
rule MbsFir
{
    CHECK_STOP:  MBSFIR & ~MBSFIR_MASK & ~MBSFIR_ACT0 & ~MBSFIR_ACT1;
    UNIT_CS:     MBSFIR & ~MBSFIR_MASK & ~MBSFIR_ACT0 & ~MBSFIR_ACT1;
    RECOVERABLE: MBSFIR & ~MBSFIR_MASK & ~MBSFIR_ACT0 &  MBSFIR_ACT1;
};

group gMbsFir filter singlebit
{
    /** MBSFIR[0]
     *  MBS_FIR_REG_HOST_PROTOCOL_ERROR
     */
    (MbsFir, bit(0)) ? calloutDmiBusTh1;

    /** MBSFIR[1]
     *  MBS_FIR_REG_INT_PROTOCOL_ERROR
     */
    (MbsFir, bit(1)) ? SelfMedThr1;

    /** MBSFIR[2]
     *  MBS_FIR_REG_INVALID_ADDRESS_ERROR
     */
    (MbsFir, bit(2)) ? callout2ndLvlMed;

    /** MBSFIR[3]
     *  MBS_FIR_REG_EXTERNAL_TIMEOUT
     */
    (MbsFir, bit(3)) ? CalloutMcsHighAndThr1;

    /** MBSFIR[4]
     *  MBS_FIR_REG_INTERNAL_TIMEOUT
     */
    (MbsFir, bit(4)) ? SelfMedThr1;

    /** MBSFIR[5]
     *  MBS_FIR_REG_INT_BUFFER_CE
     */
    (MbsFir, bit(5)) ? SelfMedThr32PerDay;

    /** MBSFIR[6]
     *  MBS_FIR_REG_INT_BUFFER_UE
     */
    (MbsFir, bit(6)) ? SelfMedThr1;

    /** MBSFIR[7]
     *  MBS_FIR_REG_INT_BUFFER_SUE
     */
    (MbsFir, bit(7)) ? defaultMaskedError;

    /** MBSFIR[8]
     *  MBS_FIR_REG_INT_PARITY_ERROR
     */
    (MbsFir, bit(8)) ? SelfMedThr1;

    /** MBSFIR[9]
     *  MBS_FIR_REG_CACHE_SRW_CE
     */
    #TODO via RTC 22872 ( L4 Line Delete )
    (MbsFir, bit(9)) ? TBDDefaultCallout;

    /** MBSFIR[10]
     *  MBS_FIR_REG_CACHE_SRW_UE
     */
    (MbsFir, bit(10)) ? SelfMedThr1;

    /** MBSFIR[11]
     *  MBS_FIR_REG_CACHE_SRW_SUE
     */
    (MbsFir, bit(11)) ? defaultMaskedError;

    /** MBSFIR[12]
     *  MBS_FIR_REG_CACHE_CO_CE
     */
    #TODO via RTC 22872 ( L4 Line Delete )
    (MbsFir, bit(12)) ? TBDDefaultCallout;

    /** MBSFIR[13]
     *  MBS_FIR_REG_CACHE_CO_UE
     */
    (MbsFir, bit(13)) ? SelfMedThr1;

    /** MBSFIR[14]
     *  MBS_FIR_REG_CACHE_CO_SUE
     */
    (MbsFir, bit(14)) ? defaultMaskedError;

    /** MBSFIR[15]
     *  MBS_FIR_REG_DIR_CE
     */
    (MbsFir, bit(15)) ? SelfMedThr32PerDay;

    /** MBSFIR[16]
     *  MBS_FIR_REG_DIR_UE
     */
    (MbsFir, bit(16)) ? SelfMedThr1;

    /** MBSFIR[17]
     *  MBS_FIR_REG_DIR_MEMBER_DELETED
     */
    (MbsFir, bit(17)) ? defaultMaskedError;

    /** MBSFIR[18]
     *  MBS_FIR_REG_DIR_ALL_MEMBERS_DELETED
     */
    (MbsFir, bit(18)) ? SelfMedThr1;

    /** MBSFIR[19]
     *  MBS_FIR_REG_LRU_ERROR
     */
    (MbsFir, bit(19)) ? SelfMedThr32PerDay;

    /** MBSFIR[20]
     *  MBS_FIR_REG_EDRAM_ERROR
     */
    (MbsFir, bit(20)) ? SelfMedThr1;

    /** MBSFIR[21]
     *  MBS_FIR_REG_EMERGENCY_THROTTLE_SET
     */
    (MbsFir, bit(21)) ? defaultMaskedError;

    /** MBSFIR[22]
     *  MBS_FIR_REG_HOST_INBAND_READ_ERROR
     */
    (MbsFir, bit(22)) ? defaultMaskedError;

    /** MBSFIR[23]
     *  MBS_FIR_REG_HOST_INBAND_WRITE_ERROR
     */
    (MbsFir, bit(23)) ? defaultMaskedError;

    /** MBSFIR[24]
     *  MBS_FIR_REG_OCC_INBAND_READ_ERROR
     */
    (MbsFir, bit(24)) ? defaultMaskedError;

    /** MBSFIR[25]
     *  MBS_FIR_REG_OCC_INBAND_WRITE_ERROR
     */
    (MbsFir, bit(25)) ? defaultMaskedError;

    /** MBSFIR[26]
     *  MBS_FIR_REG_SRB_BUFFER_CE
     */
    (MbsFir, bit(26)) ? SelfMedThr32PerDay;

    /** MBSFIR[27]
     *  MBS_FIR_REG_SRB_BUFFER_UE
     */
    (MbsFir, bit(27)) ? SelfMedThr1;

    /** MBSFIR[28]
     *  MBS_FIR_REG_SRB_BUFFER_SUE
     */
    (MbsFir, bit(28)) ? defaultMaskedError;

    /** MBSFIR[29]
     *  MBS_FIR_REG_INTERNAL_SCOM_ERROR
     */
    (MbsFir, bit(29)) ? defaultMaskedError;

    /** MBSFIR[30]
     *  MBS_FIR_REG_INTERNAL_SCOM_ERROR_COPY
     */
    (MbsFir, bit(30)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet MBSECCFIRs
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule Mba0_MbsEccFir
{
  CHECK_STOP:   MBA0_MBSECCFIR      & ~MBA0_MBSECCFIR_MASK &
               ~MBA0_MBSECCFIR_ACT0 & ~MBA0_MBSECCFIR_ACT1;
  UNIT_CS:      MBA0_MBSECCFIR      & ~MBA0_MBSECCFIR_MASK &
               ~MBA0_MBSECCFIR_ACT0 & ~MBA0_MBSECCFIR_ACT1;
  RECOVERABLE:  MBA0_MBSECCFIR      & ~MBA0_MBSECCFIR_MASK &
               ~MBA0_MBSECCFIR_ACT0 &  MBA0_MBSECCFIR_ACT1;
};

rule Mba1_MbsEccFir
{
  CHECK_STOP:   MBA1_MBSECCFIR      & ~MBA1_MBSECCFIR_MASK &
               ~MBA1_MBSECCFIR_ACT0 & ~MBA1_MBSECCFIR_ACT1;
  UNIT_CS:      MBA1_MBSECCFIR      & ~MBA1_MBSECCFIR_MASK &
               ~MBA1_MBSECCFIR_ACT0 & ~MBA1_MBSECCFIR_ACT1;
  RECOVERABLE:  MBA1_MBSECCFIR      & ~MBA1_MBSECCFIR_MASK &
               ~MBA1_MBSECCFIR_ACT0 &  MBA1_MBSECCFIR_ACT1;
};

group gMbsEccFir filter singlebit
{
    /** MBA0_MBSECCFIR[0:7]
     *  Memory MPE
     */
    (Mba0_MbsEccFir, bit(0|1|2|3|4|5|6|7)) ? analyzeFetchMpe0;

    /** MBA1_MBSECCFIR[0:7]
     *  Memory MPE
     */
    (Mba1_MbsEccFir, bit(0|1|2|3|4|5|6|7)) ? analyzeFetchMpe1;

    /** MBA0_MBSECCFIR[8:15]
     *  Reserved
     */
    (Mba0_MbsEccFir, bit(8|9|10|11|12|13|14|15)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[8:15]
     *  Reserved
     */
    (Mba1_MbsEccFir, bit(8|9|10|11|12|13|14|15)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[16]
     *  Memory NCE
     */
    (Mba0_MbsEccFir, bit(16)) ? analyzeFetchNce0;

    /** MBA1_MBSECCFIR[16]
     *  Memory NCE
     */
    (Mba1_MbsEccFir, bit(16)) ? analyzeFetchNce1;

    /** MBA0_MBSECCFIR[17]
     *  Memory RCE
     */
    (Mba0_MbsEccFir, bit(17)) ? analyzeFetchRce0;

    /** MBA1_MBSECCFIR[17]
     *  Memory RCE
     */
    (Mba1_MbsEccFir, bit(17)) ? analyzeFetchRce1;

    /** MBA0_MBSECCFIR[18]
     *  Memory SUE
     */
    (Mba0_MbsEccFir, bit(18)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[18]
     *  Memory SUE
     */
    (Mba1_MbsEccFir, bit(18)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[19]
     *  Memory UE
     */
    (Mba0_MbsEccFir, bit(19)) ? analyzeFetchUe0;

    /** MBA1_MBSECCFIR[19]
     *  Memory UE
     */
    (Mba1_MbsEccFir, bit(19)) ? analyzeFetchUe1;

    /** MBA0_MBSECCFIR[20:27]
     *  MBECCFIR_MAINT_MPE_RANK_0_7
     */
    (Mba0_MbsEccFir, bit(20|21|22|23|24|25|26|27)) ? analyzeMaintMpe0;

    /** MBA1_MBSECCFIR[20:27]
     *  MBECCFIR_MAINT_MPE_RANK_0_7
     */
    (Mba1_MbsEccFir, bit(20|21|22|23|24|25|26|27)) ? analyzeMaintMpe1;

    /** MBA0_MBSECCFIR[28:35]
     *  Reserved
     */
    (Mba0_MbsEccFir, bit(28|29|30|31|32|33|34|35)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[28:35]
     *  Reserved
     */
    (Mba1_MbsEccFir, bit(28|29|30|31|32|33|34|35)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[36]
     *  MBECCFIR_MAINTENANCE_NCE
     */
    (Mba0_MbsEccFir, bit(36)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[36]
     *  MBECCFIR_MAINTENANCE_NCE
     */
    (Mba1_MbsEccFir, bit(36)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[37]
     *  MBECCFIR_MAINTENANCE_SCE
     */
    (Mba0_MbsEccFir, bit(37)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[37]
     *  MBECCFIR_MAINTENANCE_SCE
     */
    (Mba1_MbsEccFir, bit(37)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[38]
     *  MBECCFIR_MAINTENANCE_MCE
     */
    (Mba0_MbsEccFir, bit(38)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[38]
     *  MBECCFIR_MAINTENANCE_MCE
     */
    (Mba1_MbsEccFir, bit(38)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[39]
     *  MBECCFIR_MAINTENANCE_RCE
     */
    (Mba0_MbsEccFir, bit(39)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[39]
     *  MBECCFIR_MAINTENANCE_RCE
     */
    (Mba1_MbsEccFir, bit(39)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[40]
     *  MBECCFIR_MAINTENANCE_SUE
     */
    (Mba0_MbsEccFir, bit(40)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[40]
     *  MBECCFIR_MAINTENANCE_SUE
     */
    (Mba1_MbsEccFir, bit(40)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[41]
     *  MBECCFIR_MAINTENANCE_UE
     */
    (Mba0_MbsEccFir, bit(41)) ? analyzeMaintUe0;

    /** MBA1_MBSECCFIR[41]
     *  MBECCFIR_MAINTENANCE_UE
     */
    (Mba1_MbsEccFir, bit(41)) ? analyzeMaintUe1;

    /** MBA0_MBSECCFIR[42]
     *  MBECCFIR_MPE_DURING_USE_MAINTENANCE_MARK_MODE
     */
    (Mba0_MbsEccFir, bit(42)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[42]
     *  MBECCFIR_MPE_DURING_USE_MAINTENANCE_MARK_MODE
     */
    (Mba1_MbsEccFir, bit(42)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[43]
     *  MBECCFIR_PREFETCH_MEMORY_UE
     */
    #TODO via RTC 47289 ( CE/UE isolation )
    (Mba0_MbsEccFir, bit(43)) ? TBDDefaultCallout;

    /** MBA1_MBSECCFIR[43]
     *  MBECCFIR_PREFETCH_MEMORY_UE
     */
    #TODO via RTC 47289 ( CE/UE isolation )
    (Mba1_MbsEccFir, bit(43)) ? TBDDefaultCallout;

    /** MBA0_MBSECCFIR[44]
     *  MBECCFIR_MEMORY_RCD_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(44)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[44]
     *  MBECCFIR_MEMORY_RCD_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(44)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[45]
     *  MBECCFIR_MAINTENANCE_RCD_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(45)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[45]
     *  MBECCFIR_MAINTENANCE_RCD_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(45)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[46]
     *  MBECCFIR_RECOVERABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(46)) ? SelfMedThr1;

    /** MBA1_MBSECCFIR[46]
     *  MBECCFIR_RECOVERABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(46)) ? SelfMedThr1;

    /** MBA0_MBSECCFIR[47]
     *  MBECCFIR_UNRECOVERABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(47)) ? SelfMedThr1;

    /** MBA1_MBSECCFIR[47]
     *  MBECCFIR_UNRECOVERABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(47)) ? SelfMedThr1;

    /** MBA0_MBSECCFIR[48]
     *  MBECCFIR_MASKABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(48)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[48]
     *  MBECCFIR_MASKABLE_CONFIGURATION_REGISTER_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(48)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[49]
     *  MBECCFIR_ECC_DATAPATH_PARITY_ERROR
     */
    (Mba0_MbsEccFir, bit(49)) ? SelfMedThr1;

    /** MBA1_MBSECCFIR[49]
     *  MBECCFIR_ECC_DATAPATH_PARITY_ERROR
     */
    (Mba1_MbsEccFir, bit(49)) ? SelfMedThr1;

    /** MBA0_MBSECCFIR[50]
     *  MBECCFIR_INTERNAL_SCOM_ERROR
     */
    (Mba0_MbsEccFir, bit(50)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[50]
     *  MBECCFIR_INTERNAL_SCOM_ERROR
     */
    (Mba1_MbsEccFir, bit(50)) ? defaultMaskedError;

    /** MBA0_MBSECCFIR[51]
     *  MBECCFIR_INTERNAL_SCOM_ERROR_COPY
     */
    (Mba0_MbsEccFir, bit(51)) ? defaultMaskedError;

    /** MBA1_MBSECCFIR[51]
     *  MBECCFIR_INTERNAL_SCOM_ERROR_COPY
     */
    (Mba1_MbsEccFir, bit(51)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet MCBISTFIRs
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule Mba0_McbistFir
{
  CHECK_STOP:   MBA0_MCBISTFIR      & ~MBA0_MCBISTFIR_MASK &
               ~MBA0_MCBISTFIR_ACT0 & ~MBA0_MCBISTFIR_ACT1;
  UNIT_CS:      MBA0_MCBISTFIR      & ~MBA0_MCBISTFIR_MASK &
               ~MBA0_MCBISTFIR_ACT0 & ~MBA0_MCBISTFIR_ACT1;
  RECOVERABLE:  MBA0_MCBISTFIR      & ~MBA0_MCBISTFIR_MASK &
               ~MBA0_MCBISTFIR_ACT0 &  MBA0_MCBISTFIR_ACT1;
};

rule Mba1_McbistFir
{
  CHECK_STOP:   MBA1_MCBISTFIR      & ~MBA1_MCBISTFIR_MASK &
               ~MBA1_MCBISTFIR_ACT0 & ~MBA1_MCBISTFIR_ACT1;
  UNIT_CS:      MBA1_MCBISTFIR      & ~MBA1_MCBISTFIR_MASK &
               ~MBA1_MCBISTFIR_ACT0 & ~MBA1_MCBISTFIR_ACT1;
  RECOVERABLE:  MBA1_MCBISTFIR      & ~MBA1_MCBISTFIR_MASK &
               ~MBA1_MCBISTFIR_ACT0 &  MBA1_MCBISTFIR_ACT1;
};

group gMcbistFir filter singlebit
{
    /** MBA0_MCBISTFIR[0]
     *  MBSFIRQ_SCOM_PAR_ERRORS
     */
    (Mba0_McbistFir, bit(0)) ? SelfMedThr1;

    /** MBA1_MCBISTFIR[0]
     *  MBSFIRQ_SCOM_PAR_ERRORS
     */
    (Mba1_McbistFir, bit(0)) ? SelfMedThr1;

    /** MBA0_MCBISTFIR[1]
     *  MBSFIRQ_MBX_PAR_ERRORS
     */
    (Mba0_McbistFir, bit(1)) ? calloutSelfMed;

    /** MBA1_MCBISTFIR[1]
     *  MBSFIRQ_MBX_PAR_ERRORS
     */
    (Mba1_McbistFir, bit(1)) ? calloutSelfMed;

    /** MBA0_MCBISTFIR[2:14]
     *  Reserved
     */
    (Mba0_McbistFir, bit(2|3|4|5|6|7|8|9|10|11|12|13|14)) ? defaultMaskedError;

    /** MBA1_MCBISTFIR[2:14]
     *  Reserved
     */
    (Mba1_McbistFir, bit(2|3|4|5|6|7|8|9|10|11|12|13|14)) ? defaultMaskedError;

    /** MBA0_MCBISTFIR[15]
     *  MBSFIRQ_INTERNAL_SCOM_ERROR
     */
    (Mba0_McbistFir, bit(15)) ? defaultMaskedError;

    /** MBA1_MCBISTFIR[15]
     *  MBSFIRQ_INTERNAL_SCOM_ERROR
     */
    (Mba1_McbistFir, bit(15)) ? defaultMaskedError;

    /** MBA0_MCBISTFIR[16]
     *  MBSFIRQ_INTERNAL_SCOM_ERROR_CLONE
     */
    (Mba0_McbistFir, bit(16)) ? defaultMaskedError;

    /** MBA1_MCBISTFIR[16]
     *  MBSFIRQ_INTERNAL_SCOM_ERROR_CLONE
     */
    (Mba1_McbistFir, bit(16)) ? defaultMaskedError;
};

################################################################################
#  NEST Chiplet MBSSECUREFIR
################################################################################

rule MbsSecureFir
{
  # NOTE: This secure FIR will only report checkstop attentions.
  CHECK_STOP: MBSSECUREFIR;
  UNIT_CS:    MBSSECUREFIR;
};

group gMbsSecureFir filter singlebit
{
    /** MBSSECUREFIR[0]
     *  MBSSIRQ_INVALID_MBSXCR_ACCESS
     */
    (MbsSecureFir, bit(0)) ? TBDDefaultCallout;

    /** MBSSECUREFIR[1]
     *  MBSSIRQ_INVALID_MBAXCR01_ACCESS
     */
    (MbsSecureFir, bit(1)) ? TBDDefaultCallout;

    /** MBSSECUREFIR[2]
     *  MBSSIRQ_INVALID_MBAXCR23_ACCESS
     */
    (MbsSecureFir, bit(2)) ? TBDDefaultCallout;

    /** MBSSECUREFIR[3]
     *  MBSSIRQ_INVALID_MBAXCRMS_ACCRESS
     */
    (MbsSecureFir, bit(3)) ? TBDDefaultCallout;

    /** MBSSECUREFIR[5]
     *  MBSSIRQ_INVALID_SIR_MASK_OR_ACTION_REGISTER_ACCESS
     */
    (MbsSecureFir, bit(5)) ? TBDDefaultCallout;
};

################################################################################
# Actions specific to NEST chiplet
################################################################################

/** Callout the DMI bus */
actionclass calloutDmiBus
{
    calloutSelfMedA;
    callout(connected(TYPE_MCS), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus, threshold 1 */
actionclass calloutDmiBusTh1 { calloutDmiBus; threshold1; };

/** Callout the DMI bus, threshold 2 per day */
actionclass calloutDmiBusTh2pday { calloutDmiBus; threshold2pday; };

/** Callout the DMI bus and 2nd Level (LOW), threshold 1 */
actionclass calloutDmiBusLvl2Th1 { calloutDmiBusTh1; callout2ndLvlLow; };

actionclass CalloutMcsHighAndThr1
{
    callout(connected(TYPE_MCS),MRU_HIGH);
    threshold1;
};

actionclass analyzeSpareBitAndThr
{
    try( funccall("checkSpareBit"), calloutDmiBusTh2pday );
};

/** Lane Repair: spare deployed */
actionclass spareDeployed
{ calloutDmiBus; funccall("spareDeployed"); };

/** Lane Repair: max spares exceeded */
actionclass maxSparesExceeded
{ calloutDmiBusTh1; funccall("maxSparesExceeded"); };

/** Analyze a fetch MPE on MBA0 */
actionclass analyzeFetchMpe0 { funccall("AnalyzeFetchMpe0"); };

/** Analyze a fetch MPE on MBA1 */
actionclass analyzeFetchMpe1 { funccall("AnalyzeFetchMpe1"); };

/** Analyze a fetch NCE on MBA0 */
actionclass analyzeFetchNce0 { funccall("AnalyzeFetchNce0"); threshold32pday; };

/** Analyze a fetch NCE on MBA1 */
actionclass analyzeFetchNce1 { funccall("AnalyzeFetchNce1"); threshold32pday; };

# TODO: RTC 23125 The RAS spreadsheet action is RCE is: "Threshold per rank 8/24
#       make a callout of DIMM pair". Needs discussion.

/** Analyze a fetch RCE on MBA0 */
actionclass analyzeFetchRce0 { funccall("AnalyzeFetchRce0"); threshold32pday; };

/** Analyze a fetch RCE on MBA1 */
actionclass analyzeFetchRce1 { funccall("AnalyzeFetchRce1"); threshold32pday; };

/** Analyze a fetch UE on MBA0 */
actionclass analyzeFetchUe0 { funccall("AnalyzeFetchUe0"); threshold1; };

/** Analyze a fetch UE on MBA1 */
actionclass analyzeFetchUe1 { funccall("AnalyzeFetchUe1"); threshold1; };

/** Analyze a maintenance MPE on MBA0 */
actionclass analyzeMaintMpe0 { funccall("AnalyzeMaintMpe0"); };

/** Analyze a maintenance MPE on MBA1 */
actionclass analyzeMaintMpe1 { funccall("AnalyzeMaintMpe1"); };

/** Analyze a maintenance UE on MBA0 */
actionclass analyzeMaintUe0 { funccall("AnalyzeMaintUe0"); threshold1; };

/** Analyze a maintenance UE on MBA1 */
actionclass analyzeMaintUe1 { funccall("AnalyzeMaintUe1"); threshold1; };

