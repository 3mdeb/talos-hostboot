#This file was generated by /gsa/rchgsa-h1/02/missyc/sandboxes/hostboot/src/simu/fsp/buildIndScom.pl for scomdef: p8_910520.scomdef

#The following actions are used for Indirect SCOMs

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x08010C3F]
  WATCH=[REG(0x08010C3F)]
  CAUSE: TARGET=[REG(0x08010C3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x08010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x08010C3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x08010C3F(CONTENTSOF{INDSCOM_0x08010C3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x08010C3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x08010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x08010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x08010C3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x08010C3F(CONTENTSOF{INDSCOM_0x08010C3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x08010C3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x08010C3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x08010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x02011E3F]
  WATCH=[REG(0x02011E3F)]
  CAUSE: TARGET=[REG(0x02011E3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x02011E3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011E3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x02011E3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011E3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x02011E3F(CONTENTSOF{INDSCOM_0x02011E3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x02011E3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x02011E3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x02011E3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011E3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x02011E3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x02011E3F(CONTENTSOF{INDSCOM_0x02011E3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x02011E3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x02011E3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x02011E3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0901183F]
  WATCH=[REG(0x0901183F)]
  CAUSE: TARGET=[REG(0x0901183F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0901183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0901183F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901183F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0901183F(CONTENTSOF{INDSCOM_0x0901183F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0901183F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0901183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0901183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0901183F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0901183F(CONTENTSOF{INDSCOM_0x0901183F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0901183F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0901183F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0901183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0401143F]
  WATCH=[REG(0x0401143F)]
  CAUSE: TARGET=[REG(0x0401143F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0401143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0401143F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401143F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0401143F(CONTENTSOF{INDSCOM_0x0401143F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0401143F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0401143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0401143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0401143F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0401143F(CONTENTSOF{INDSCOM_0x0401143F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0401143F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0401143F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0401143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0901143F]
  WATCH=[REG(0x0901143F)]
  CAUSE: TARGET=[REG(0x0901143F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0901143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0901143F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901143F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0901143F(CONTENTSOF{INDSCOM_0x0901143F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0901143F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0901143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0901143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0901143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0901143F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0901143F(CONTENTSOF{INDSCOM_0x0901143F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0901143F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0901143F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0901143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x04011C3F]
  WATCH=[REG(0x04011C3F)]
  CAUSE: TARGET=[REG(0x04011C3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x04011C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x04011C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x04011C3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x04011C3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x04011C3F(CONTENTSOF{INDSCOM_0x04011C3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x04011C3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x04011C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x04011C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x04011C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x04011C3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x04011C3F(CONTENTSOF{INDSCOM_0x04011C3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x04011C3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x04011C3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x04011C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x02011A3F]
  WATCH=[REG(0x02011A3F)]
  CAUSE: TARGET=[REG(0x02011A3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x02011A3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011A3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x02011A3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011A3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x02011A3F(CONTENTSOF{INDSCOM_0x02011A3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x02011A3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x02011A3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x02011A3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x02011A3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x02011A3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x02011A3F(CONTENTSOF{INDSCOM_0x02011A3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x02011A3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x02011A3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x02011A3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0401183F]
  WATCH=[REG(0x0401183F)]
  CAUSE: TARGET=[REG(0x0401183F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0401183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0401183F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401183F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0401183F(CONTENTSOF{INDSCOM_0x0401183F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0401183F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0401183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0401183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0401183F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0401183F(CONTENTSOF{INDSCOM_0x0401183F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0401183F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0401183F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0401183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0401103F]
  WATCH=[REG(0x0401103F)]
  CAUSE: TARGET=[REG(0x0401103F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0401103F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401103F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0401103F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401103F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0401103F(CONTENTSOF{INDSCOM_0x0401103F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0401103F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0401103F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0401103F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0401103F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0401103F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0401103F(CONTENTSOF{INDSCOM_0x0401103F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0401103F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0401103F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0401103F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x09011C3F]
  WATCH=[REG(0x09011C3F)]
  CAUSE: TARGET=[REG(0x09011C3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x09011C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x09011C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x09011C3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x09011C3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x09011C3F(CONTENTSOF{INDSCOM_0x09011C3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x09011C3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x09011C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x09011C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x09011C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x09011C3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x09011C3F(CONTENTSOF{INDSCOM_0x09011C3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x09011C3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x09011C3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x09011C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

