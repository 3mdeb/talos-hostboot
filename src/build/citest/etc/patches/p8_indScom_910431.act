#This file was generated by /gsa/rchgsa-h1/02/missyc/sandboxes/hostboot/src/simu/fsp/buildIndScom.pl for scomdef: p8_910431.scomdef

#The following actions are used for Indirect SCOMs

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x020140BF]
  WATCH=[REG(0x020140BF)]
  CAUSE: TARGET=[REG(0x020140BF)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x020140BF(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020140BF)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x020140BF(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020140BF)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x020140BF(CONTENTSOF{INDSCOM_0x020140BF(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x020140BF(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x020140BF)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x020140BF(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020140BF)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x020140BF(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x020140BF(CONTENTSOF{INDSCOM_0x020140BF(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x020140BF)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x020140BF(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x020140BF)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0301187F]
  WATCH=[REG(0x0301187F)]
  CAUSE: TARGET=[REG(0x0301187F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0301187F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301187F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0301187F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301187F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0301187F(CONTENTSOF{INDSCOM_0x0301187F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0301187F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0301187F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0301187F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301187F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0301187F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0301187F(CONTENTSOF{INDSCOM_0x0301187F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0301187F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0301187F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0301187F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x08010C3F]
  WATCH=[REG(0x08010C3F)]
  CAUSE: TARGET=[REG(0x08010C3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x08010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x08010C3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x08010C3F(CONTENTSOF{INDSCOM_0x08010C3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x08010C3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x08010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x08010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x08010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x08010C3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x08010C3F(CONTENTSOF{INDSCOM_0x08010C3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x08010C3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x08010C3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x08010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x03010C3F]
  WATCH=[REG(0x03010C3F)]
  CAUSE: TARGET=[REG(0x03010C3F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x03010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x03010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x03010C3F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x03010C3F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x03010C3F(CONTENTSOF{INDSCOM_0x03010C3F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x03010C3F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x03010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x03010C3F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x03010C3F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x03010C3F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x03010C3F(CONTENTSOF{INDSCOM_0x03010C3F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x03010C3F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x03010C3F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x03010C3F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0301103F]
  WATCH=[REG(0x0301103F)]
  CAUSE: TARGET=[REG(0x0301103F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0301103F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301103F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0301103F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301103F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0301103F(CONTENTSOF{INDSCOM_0x0301103F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0301103F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0301103F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0301103F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301103F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0301103F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0301103F(CONTENTSOF{INDSCOM_0x0301103F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0301103F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0301103F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0301103F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0301143F]
  WATCH=[REG(0x0301143F)]
  CAUSE: TARGET=[REG(0x0301143F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0301143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0301143F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301143F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0301143F(CONTENTSOF{INDSCOM_0x0301143F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0301143F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0301143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0301143F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301143F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0301143F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0301143F(CONTENTSOF{INDSCOM_0x0301143F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0301143F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0301143F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0301143F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x0301183F]
  WATCH=[REG(0x0301183F)]
  CAUSE: TARGET=[REG(0x0301183F)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x0301183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x0301183F(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301183F)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x0301183F(CONTENTSOF{INDSCOM_0x0301183F(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x0301183F(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x0301183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x0301183F(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x0301183F)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x0301183F(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x0301183F(CONTENTSOF{INDSCOM_0x0301183F(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x0301183F)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x0301183F(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x0301183F)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

CAUSE_EFFECT {
  LABEL=[Indirect Scom Action for 0x020120BF]
  WATCH=[REG(0x020120BF)]
  CAUSE: TARGET=[REG(0x020120BF)] OP=[BIT,OFF] BIT=[0] #Write
  #bits 12-31 contain the indirect address.
  EFFECT: TARGET=[INDSCOM_0x020120BF(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020120BF)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #bits 48-63 contain the indirect SCOM data
  EFFECT: TARGET=[INDSCOM_0x020120BF(0xFF0000DD)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020120BF)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #write 48-63 6010420 to the IND REG
  EFFECT: TARGET=[INDSCOM_0x020120BF(CONTENTSOF{INDSCOM_0x020120BF(0xFF0000AA)})] OP=[EQUALTO,BUFSTRING] DATA=[INDSCOM_0x020120BF(0xFF0000DD]
  #Turn on bits 32 and 38 to show successful write
   EFFECT: TARGET=[REG(0x020120BF)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 82000000]
  
  ## Read => if Bit 0 = 1 in SCOM reg, it's a read request
  #bits 12-31 contain the indirect address
  ELSE: TARGET=[INDSCOM_0x020120BF(0xFF0000AA)] OP=[EQUALTO,BUF,MASK] DATA=[REG(0x020120BF)] MASK=[LITERAL(64,000FFFFF 00000000)]
  #Move bits 48-63 from IND SCOM reg to 0xFF0000DD scratch reg (for debug)
  ELSE: TARGET=[INDSCOM_0x020120BF(0xFF0000DD)]  OP=[EQUALTO,BUFSTRING,MASK]  DATA=[INDSCOM_0x020120BF(CONTENTSOF{INDSCOM_0x020120BF(0xFF0000AA)})] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Move bits 48-63 from 0xFF0000DD scratch reg to SCOM Reg
  ELSE: TARGET=[REG(0x020120BF)] OP=[EQUALTO,BUF,MASK] DATA=[INDSCOM_0x020120BF(0xFF0000DD)] MASK=[LITERAL(64,00000000 0000FFFF)]
  #Turn on bits 32, 38, 39 to show successful read
  ELSE: TARGET=[REG(0x020120BF)] OP=[OR,ON,BUF] DATA=[LITERAL(64,00000000 83000000]
}

