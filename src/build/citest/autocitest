#!/bin/bash
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/build/citest/autocitest $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2011,2012
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG
################################################################################
##  Simics automation using autosim
##  2011-05-23  mww modified to run hostboot in simics
##  2011-06-02  mww check in first working version.
##                  Profuse thanks to Patrick Williams for getting this going
##                  on the Jenkins server!!
##
##  Usage:
##       autocitest [--quiet] <backing_build> <sandbox_name> <hbi_image>
################################################################################
function    waitkb()
{

    ##  wait for kbhit to continue
    ## echo "Hit any key to continue"
    ## read kb
    echo "."
}

function   usage()
{

    echo    "usage:"
    echo    "$0 [--quiet]  backing_tree_dir  sandbox_name  path_to_hbicore_test_img    "
}


function    stopsim()
{
    # Stop simics
    echo "Stopping simics"
    autosim $NOWIN $VERBOSE --stopsim
    if [ $? -ne 0 ] ; then
        echo "WARNING: Unable to stop simics cleanly"
    fi
}


function    stopserver()
{
    # Stop simics server
    echo "Stopping simics server"
    autosim $NOWIN $VERBOSE --stopserver
    if [ $? -ne 0 ] ; then
        echo "WARNING: Unable to stop simics server cleanly"
    fi
}


function    runtraceHB()
{

    echo    "Collect traceHB info..."
    `pwd`
    
    #autosim $NOWIN --simcmd   "run-python-file ${SBXHOME}/src/build/simics/hb-simdebug.py"
    #if [ $? -ne 0 ] ; then
    #    echo "ERROR 3: Unable to run $?"
    #    stopsim
    #    stopserver
    #    exit 1
    #fi
    
    autosim $NOWIN --simcmd   "hb-trace" --timeout 300
    if [ $? -ne 0 ] ; then
        echo "ERROR 4 : Unable to run $?"
        stopsim
        stopserver
        exit 1
    fi
    
}


##  verbose is the default.
VERBOSE=" --verbose"
if [ "$1" = "--quiet" ] ; then
        VERBOSE=""
        shift
fi

##
##  set up
##
DRIVER="$1"                     ##  backing tree
export bb=$DRIVER               ##  simulate a workon
TEST_SANDBOX="$2"               ##  test sandbox
HBICORE_TEST="$3"               ##  path to hbicore_test.img

export SHELL="/bin/bash"        ##  Needed to fool workon to launch a bash 
                                ##  shell, which autosim expects.
NOWIN="--nowin"                 ##  remote execution does not have a display

MACHINE=${MACHINE:-$DEFAULT_MACHINE}
export MACHINE
HBOT_SIMICS_SETUP="/gsa/ausgsa/home/a/n/andrewg/web/public/hostboot/simics/hbot_simics_setup.pl"

##  jenkins creates a new workspace for every compile.
##     cxxtest-start.sh will verify this and then export WORKSPACE_DIR for us.
SBXHOME=$WORKSPACE_DIR

##  autosim, mksb, workon, etc should look in $SANDBOXRC for the location of the sandbox.
##  this is more effective than using -rc option (autosim has no option for this anyway)
SANDBOXRC="$SBXHOME/hbsandboxrc"


if [ "$DRIVER" = "" ] ; then
        echo "ERROR: you must specify a driver (backing tree) to run the tests with"
        usage
        exit 1
fi

if [ "$TEST_SANDBOX" = "" ] ; then
        echo "ERROR: must specify a TEST_SANDBOX="
        usage
        exit 1
fi

if [ ! -f "${SBXHOME}/${HBICORE_TEST}" ] ; then
        echo "ERROR: you must specify a valid hbicore_test.bin file."
        usage
        exit 1
fi

##  Find the .syms file for the image.  Remove extension, add .syms.
HBICORE_TEST_SYMS="${HBICORE_TEST%%.*}.syms"

HBICORE_TEST_EXTENDED="${HBICORE_TEST%%.*}_extended.bin"

CPFILES="${SBXHOME}/src/build/tools/hbDistribute"


## let's get set up
cd $SBXHOME

echo    "$0"
echo    "VERBOSE                    = $VERBOSE"
echo    "NOWIN                      = $NOWIN"
echo    "BACKING_TREE               = $DRIVER"
echo    "TEST_SANDBOX               = $TEST_SANDBOX"
echo    "HBICORE_TEST               = $HBICORE_TEST"
echo    "HBICORE_TEST_EXTENDED      = $HBICORE_TEST_EXTENDED"
echo    "HBICORE_TEST_SYMS          = $HBICORE_TEST_SYMS"
echo    "SANDBOXRC                  = $SANDBOXRC"
echo    "SBXHOME                    = $SBXHOME"
echo    "current directory is " `pwd`

waitkb


timestamp=`date +'%H:%M:%S'`
echo "$timestamp Starting autosample test..."


# Set up the test sandbox backed to the specified build
##  Assumption here is that we will always run inside the workspace created by 
##  jenkins, so we always create a new sandbox
##

echo "Setting up sandbox environment..."

##  mksb fills the log with "please type backing tree file" if it can't find
##  the -back file.   We wish to avoid this.
if [ ! -d "$DRIVER" ] ; then
        echo "cannot access the backing tree $DRIVER , aborting"
        exit 1
fi

##  set $SANDBOXRC to the local one, this should cause this to make and run 
##  in a new sandbox at the base workspace dir.
export SANDBOXRC
export SANDBOXROOT=$SBXHOME
export SANDBOXNAME=$TEST_SANDBOX
export SANDBOXBASE=$SANDBOXROOT/$SANDBOXNAME

if [ ! -d "$SBXHOME/$TEST_SANDBOX" ] ; then
        echo "run mksb to create the sandbox "
        mksb  -rc $SANDBOXRC -dir $SBXHOME -back $DRIVER -sb $TEST_SANDBOX -m ppc
        if [ $? -ne 0 ] ; then
            echo "ERROR: mksb failed: $?"
            exit 1
        fi
else
        echo "$SBXHOME/$TEST_SANDBOX already exists, " `ls -la`
        `usrsbinfo -s`
        chkdrv=`usrsbinfo -s | grep " $TEST_SANDBOX "| awk '{ print $2 }'`
        if [ "$chkdrv" != "$DRIVER" ] ; then
                resb $DRIVER -sb $TEST_SANDBOX
        fi
fi


waitkb

# Run set up in current shell
echo    "run autosimsetup.."
. autosimsetup

waitkb

# Start the simics server
echo "Starting simics server in sandbox $TEST_SANDBOX on machine $MACHINE"
autosim $NOWIN $VERBOSE --startserver --wp --sandbox $TEST_SANDBOX --machine $MACHINE
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to start simics server $?"
        exit 1
fi

waitkb

##  under normal circumstances $sb would be set by start_simics
export sb=$SBXHOME/$TEST_SANDBOX/src
echo "sandbox dir = $sb"

echo "Running workarounds (presimsetup)."
if [ -f ${SBXHOME}/src/build/citest/etc/workarounds.presimsetup ] ; then
    ${SBXHOME}/src/build/citest/etc/workarounds.presimsetup 
fi

echo "** Set up simics directories **"
echo "start_simics -no_start -machine $MACHINE  -batch_mode " > $sb/my_simics_env_setup

# Do a workon and immediately execute the above commands
chmod 775 $sb/my_simics_env_setup
workon -sb $TEST_SANDBOX -mppc -c ./my_simics_env_setup

echo "** Executing workarounds (postsimsetup) **"
if [ -f ${SBXHOME}/src/build/citest/etc/workarounds.postsimsetup ] ; then
    ${SBXHOME}/src/build/citest/etc/workarounds.postsimsetup
fi

echo "** Create img directory for hbicore.bin **"
mkdir -p $sb/../img


waitkb


echo "Copy .syms, bin, hbotStringfile, etc to base sandbox dir."
echo "$sb"
$CPFILES --test
if [ $? -ne 0 ] ; then
    echo "ERROR: $CPFILES failed: $?"
    exit 1
fi

waitkb


# Start simics and wait for it to reach standby
echo "Starting simics"
#autosim $VERBOSE --startsim --chkpt standby <<< chkpt not working yet
autosim $NOWIN $VERBOSE --startsim
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to start simics $?"
        stopserver      ##  kill the server again.
        exit 1
fi


waitkb


##  $$TODO Need to wait here for hostboot to finish
##  for now just sleep for 20 seconds
## sleep 20


waitkb

##  grep for totaltests, etc.  These will appear in the hbicore_test.syms file and
## look like the following:
##      V,000292b8,00000000,00000008,CxxTest::totaltests
##      V,000292c0,00000000,00000008,CxxTest::tracecalls
##      V,000292c8,00000000,00000008,CxxTest::warnings
##      V,000292d0,00000000,00000008,CxxTest::failedtests

##      V,00017888,00000000,00004000,kernel_printk_buffer


##  grep for the globals
echo "find totaltests, etc in ${SBXHOME}/${HBICORE_TEST_SYMS}"
printk_buffer_addr=`grep "kernel_printk_buffer" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
printk_buffer_size=`grep "kernel_printk_buffer" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[4]}'`
totaltests_addr=`grep "CxxTest::g_TotalTests" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
failedtests_addr=`grep "CxxTest::g_FailedTests" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
warnings_addr=`grep "CxxTest::g_Warnings" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
tracecalls_addr=`grep "CxxTest::g_TraceCalls" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
mods_started_addr=`grep "CxxTest::g_ModulesStarted" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`
mods_completed_addr=`grep "CxxTest::g_ModulesCompleted" \
        ${SBXHOME}/${HBICORE_TEST_SYMS} | awk '{split($0,a,","); print a[2]}'`

#Adjust addresses for HRMOR
HRMOR=`autosim $NOWIN --simcmd   "python \"getHRMOR()\""| tr -d '\n\r'`

temp=$(($HRMOR + 0x$printk_buffer_addr))
printk_buffer_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$totaltests_addr))
totaltests_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$failedtests_addr))
failedtests_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$warnings_addr))
warnings_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$tracecalls_addr))
tracecalls_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$mods_started_addr))
mods_started_addr=`echo "obase=16; $temp" | bc`

temp=$(($HRMOR + 0x$mods_completed_addr))
mods_completed_addr=`echo "obase=16; $temp" | bc`
     
##  note, don't use $VERBOSE here or you get all sorts of extra junk in the output file.
echo "Wait for unit test completion."
declare -i timeout=0
modsstarted=0
modscompleted=0
loopcount=0
while [ $(($modsstarted)) -lt 1 -o $(($modsstarted)) -ne $(($modscompleted)) ]; do
    sleep 5
    ((loopcount++))     # increment loopcount
        autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$mods_completed_addr 0x08"     1> $SBXHOME/modscompleted.log  2> /dev/null
    modscompleted=`cat $SBXHOME/modscompleted.log | xargs echo -n`
    autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$mods_started_addr 0x08"     1> $SBXHOME/modsstarted.log  2> /dev/null
    modsstarted=`cat $SBXHOME/modsstarted.log | xargs echo -n`

    echo "ModulesStarted:ModulesCompleted  => $modsstarted:$modscompleted"
    
    if [ "$loopcount" -gt 60 ];   then
        echo    "ERROR: timed out after 5 minutes"
        autosim $NOWIN --simcmd   "hb-Ps"
        timeout=$(($modsstarted - $modscompleted))
        break
    fi
done


echo "====> dump totaltests..."
autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$totaltests_addr 0x08"     1> $SBXHOME/totaltests.log  2> /dev/null
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to run $?"
        stopsim
        stopserver
        exit 1
fi
totaltests=`cat $SBXHOME/totaltests.log | xargs echo -n`


echo "====> dump failedtests..."
autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$failedtests_addr 0x08"     1> $SBXHOME/failedtests.log  2> /dev/null
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to run $?"
        stopsim
        stopserver
        exit 1
fi
failedtests=`cat $SBXHOME/failedtests.log | xargs echo -n`


echo "====> dump warnings..."
autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$warnings_addr 0x08"     1> $SBXHOME/warnings.log  2> /dev/null
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to run $?"
        stopsim
        stopserver
        exit 1
fi
warnings=`cat $SBXHOME/warnings.log | xargs echo -n`


echo "====> dump tracecalls..."
autosim $NOWIN --simcmd   "(system_cmp0.phys_mem).read 0x$tracecalls_addr 0x08"     1> $SBXHOME/tracecalls.log  2> /dev/null
if [ $? -ne 0 ] ; then
        echo "ERROR: Unable to run $?"
        stopsim
        stopserver
        exit 1
fi
tracecalls=`cat $SBXHOME/tracecalls.log | xargs echo -n`


echo "====> dump printk buffer..."
autosim $NOWIN --simcmd "(system_cmp0.phys_mem)->map[0][1]->image.save ${SBXHOME}/testprintk.log 0x$printk_buffer_addr 0x$printk_buffer_size"  1> /dev/null 2> /dev/null
if [ $? -ne 0 ] ; then
echo "ERROR: Unable to run $?"
       stopsim
       stopserver
       exit 1
fi

##  run CamVan's python script to dump out the trace logs
echo "====> dump trace buffer(s)..."
runtraceHB  1> $SBXHOME/traceHB.log  2> /dev/null
if [ $? -ne 0 ] ; then
    echo "ERROR: Unable to run $?"
    stopsim
    stopserver
    exit 1
fi

echo "====> dump L3..."
autosim $NOWIN --simcmd   "hb-dump"
if [ $? -ne 0 ] ; then
    echo "ERROR 4 : Unable to run $?"
    stopsim
    stopserver
    exit 1
fi

########################################################
##  done.  Stop the simulation
########################################################
stopsim


## now stop the server.
stopserver


##  print out ending.
timestamp=`date +'%H:%M:%S'`

echo    "----------------- Printk Buffer -------------------"
cat $SBXHOME/testprintk.log
shutdown_code="$(grep --text 'Shutdown Requested' $SBXHOME/testprintk.log | awk -F '= 0x' '{ print $2 }')"


echo    "----------------- traceHB Buffer -------------------"
cat $SBXHOME/traceHB.log

initfail=0
echo "Shutdown Code = $shutdown_code"
if [ "${shutdown_code}" != "0000000001230000" ]
then
 echo "**ERROR : System did not initialize and/or shutdown properly**"
 initfail=1
fi

echo
echo    "==================================================="
if [ $timeout = 0 ] ; then
    echo    "$timestamp Finished autocitest with no Cxx errors."
else
    echo    "$timestamp Failed autocitest, modules timed out."
    echo    "    failed modules:  $timeout"
fi
echo    "    total tests:     $totaltests"
echo    "    failed tests:    $failedtests"
echo    "    warnings:        $warnings"
echo    "    trace calls:     $tracecalls"
echo    "==================================================="
echo

if [ 0 !=  $timeout ] ; then
    echo "Modules started:   $modsstarted"
    echo "Modules completed: $modscompleted"
    exit 1
fi
if [ 0 !=  $(($failedtests)) ] ; then
    echo "$failedtests testcases failed."
    exit 1
fi
if [ 0 != $(($warnings)) ] ; then
    echo "$warnings testcase warnings found."
    exit 1
fi
if [ 0 != $(($initfail)) ] ; then
    echo "Initialization Failure"
    exit 1
fi

exit 0




