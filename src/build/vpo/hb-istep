#!/usr/bin/perl
#  IBM_PROLOG_BEGIN_TAG
#  This is an automatically generated prolog.
#
#  $Source: src/build/vpo/hb-istep $
#
#  IBM CONFIDENTIAL
#
#  COPYRIGHT International Business Machines Corp. 2011
#
#  p1
#
#  Object Code Only (OCO) source materials
#  Licensed Internal Code Source Materials
#  IBM HostBoot Licensed Internal Code
#
#  The source code for this program is not published or other-
#  wise divested of its trade secrets, irrespective of what has
#  been deposited with the U.S. Copyright Office.
#
#  Origin: 30
#
#  IBM_PROLOG_END
#
# Purpose:  This perl script works in concert with do_p8vbu_script_hbi_* to 
#           implement isteps on AWAN.
#
# Description:
#           The do.. script will run first to set up the AWAN environment, 
#           then call hb_istep  twice:
#           1) hb_istep --istepmode
#               called after loading but before starting HostBoot
#               this will check to see if the user has set istep mode, if so
#               it will write the Istep_mode signature to L3 memory to put 
#               HostBoot mode into single-step mode.
#           2) hb_istep --command
#               Periodically call RunClocks() to step through HostBoot.
#               Checks for status from previous Isteps, and reports status.
#            
# Comments:
#               
#
# Author: Mark Wenning
#

#------------------------------------------------------------------------------
# Specify perl modules to use
#------------------------------------------------------------------------------
use strict;
use warnings;
use POSIX;
use Getopt::Long;
use File::Basename;
use lib dirname (__FILE__);

## 64-bit input
##  argh, not compatable with GetOpt!! use bigint;
no  warnings    'portable';

#   read/write cachelines to L3
use VBU_Cacheline;

#------------------------------------------------------------------------------
# Forward Declaration
#------------------------------------------------------------------------------
sub main;
sub printUsage;
sub get_istep_list;
sub print_istep_list;
sub find_in_inlist;
sub parse_command;
sub setMode;
sub resume_istep;
sub getShutDownStatus;

#------------------------------------------------------------------------------
#   Constants
#------------------------------------------------------------------------------
my  $CORE       =   "-c3";


##  @todo   extract these from splesscommon.H
use constant    ISTEP_MODE_ON_SIGNATURE     =>  "4057b0074057b007";
use constant    ISTEP_MODE_OFF_SIGNATURE    =>  "700b7504700b7504";

use constant    SPLESS_SINGLE_ISTEP_CMD     =>  0x00;
use constant    SPLESS_RESUME_ISTEP_CMD     =>  0x01;
use constant    SPLESS_CLEAR_TRACE_CMD      =>  0x02;

use constant    MAX_ISTEPS                  =>  25;
use constant    MAX_SUBSTEPS                =>  25;


#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------
my  $opt_debug          =   0;
my  $opt_istepmode      =   0;
my  $opt_normalmode     =   0;
my  $opt_command        =   "";
my  $opt_list           =   0;
my  $opt_help           =   0;
my  $opt_resume         =   0;          ## resume istep from break point
my  $opt_clear_trace    =   0;          ##  submit command 01    
my  $opt_cmdfile        =   0;          ## batchmode, later   
my  $opt_setup          =   "";         ##  run Jim's script to start up the model         

my  @inList;
$inList[MAX_ISTEPS][MAX_SUBSTEPS]   =   ();
##  initialize inList to "undefined"
for( my $i = 0; $i <    MAX_ISTEPS; $i++)
{
    for(my $j = 0; $j < MAX_SUBSTEPS; $j++)
    {
        undef( $inList[$i][$j] );
    }
}    

##  initialize the sequence number - 6 bit field, { 0 - 63 }
my  $g_SeqNum   =   int(rand(64)); 


#==============================================================================
# MAIN
#==============================================================================
##  get any environment variables

## Assume that all the tools, files, etc are in the same directory that 
##  we are in.


my  $pgmDir  =   `dirname $0`;
chomp( $pgmDir );

my $hbToolsDir = $ENV{'HB_TOOLS'};
if ( ! defined( $hbToolsDir) || ( $hbToolsDir eq "" ) )
{
    $hbToolsDir = $pgmDir;         ##  Set to tool directory
}     

my $hbDir = $ENV{'HB_IMGDIR'};
if ( ! defined( $hbDir) || ( $hbDir eq "" ) )
{
    $hbDir = $pgmDir;               ##  Set to tool directory
}     

my $vbuToolsDir = $ENV{'HB_VBUTOOLS'};
if (defined ($vbuToolsDir))
{
    unless ($vbuToolsDir ne "")
    {
        $vbuToolsDir = "/gsa/ausgsa/projects/h/hostboot/vbutools/dev";
    }
}


my $CSVfile     =   "$hbDir/isteplist.csv";
my $hbSymsFile  =   "$hbDir/hbicore.syms";                #Use hbicore.syms
    
## print   $#ARGV;       
if ( $#ARGV < 0 )
{
    printUsage();
    exit    0 ;
}   
#------------------------------------------------------------------------------
# Parse optional input arguments
#------------------------------------------------------------------------------
GetOptions( "help|?"        =>  \$opt_help,
            "istepmode"     =>  \$opt_istepmode,
            "normalmode"    =>  \$opt_normalmode,
            "list"          =>  \$opt_list,
            "command=s"     =>  \$opt_command,
            "resume"        =>  \$opt_resume,
            "clear-trace"   =>  \$opt_clear_trace, 
            "cmdfile"       =>  \$opt_cmdfile,           
            "setup=s"       =>  \$opt_setup,

            "debug"         =>  \$opt_debug,
          );  
          
          
          
##----------------------------------------------------------------------------- 
##  check for access to the files we need.
##-----------------------------------------------------------------------------
if ( ! -e "$hbSymsFile" )  { die "Can't find symbols file $hbSymsFile\n";   }
if ( ! -e "$CSVfile" )  { die "Can't find isteplist file $hbSymsFile\n";   }   

##
##  find the istep mode, command, and status registers in the syms file
##
my $istepmodereg = `grep "SPLESS::g_SPLess_IStepMode_Reg" $hbSymsFile | awk -F"," '{print \$2}'`;
chomp   $istepmodereg;

my  $commandreg = `grep "SPLESS::g_SPLess_Command_Reg" $hbSymsFile | awk -F"," '{print \$2}'`;
chomp   $commandreg;

my $statusreg = `grep "SPLESS::g_SPLess_Status_Reg" $hbSymsFile | awk -F"," '{print \$2}'` ;
chomp   $statusreg;

my $shutdownflag = `grep "CpuManager::cv_shutdown_requested" $hbSymsFile | awk -F"," '{print \$2}'` ;
chomp   $shutdownflag;

my $shutdownsts = `grep "CpuManager::cv_shutdown_status" $hbSymsFile | awk -F"," '{print \$2}'` ;
chomp   $shutdownsts;


##-----------------------------------------------------------------------------
##  Start processing options
##-----------------------------------------------------------------------------          
if  ( $opt_debug )
{
    print   STDERR  "\n-----    DEBUG:  ----------------------------------- \n";
    print   STDERR  "help               =   $opt_help\n";
    print   STDERR  "istepmode          =   $opt_istepmode\n";
    print   STDERR  "normalmode         =   $opt_normalmode\n"; 
    print   STDERR  "list               =   $opt_list\n";   
    print   STDERR  "command            =   $opt_command\n";
    print   STDERR  "cmdfile            =   $opt_cmdfile\n";
    print   STDERR  "setup              =   $opt_setup\n";
    print   STDERR  "clear-trace        =   $opt_clear_trace\n";
    print   STDERR  "debug              =   $opt_debug\n";
    
    print   STDERR  "pgmDir             =   $pgmDir\n";
    print   STDERR  "hbDir              =   $hbDir\n"; 
    print   STDERR  "hbSymsFile         =   $hbSymsFile\n";   
    print   STDERR  "istepmodereg       =   $istepmodereg\n";
    print   STDERR  "commandreg         =   $commandreg\n";
    print   STDERR  "statusreg          =   $statusreg\n";
    print   STDERR  "shutdownflag reg   =   $shutdownflag\n";
    print   STDERR  "shutdownsts  reg   =   $shutdownsts\n";
    
    VBU_Cacheline::SetFlags( 1, 0 ); 
}

if  ( $opt_help )
{
    printUsage();
    exit;
}

##
##  run the main loop.  Yes, I did this on purpose.  
##  Idea is (later) to pass this an array / hash of options and use 
##  GetOptionsFromArray() to parse them.
##  That way I can either pass it @ARGV or an array processed from the cmdfile 
##
main();         



#==============================================================================
# SUBROUTINES
#==============================================================================
sub main()
{
    print   STDOUT  "\n";

    ##  fetch the ISTEP csv list
    get_istep_list();       

    if ( $opt_list )
    {
        print_istep_list();
        exit;
    }


    ## VPO cannot be running when we start.
    my  $qstr   =   VBU_Cacheline::P8_Ins_Query();
    if ( $qstr  ne "STOPPED" )
    {
        print STDOUT "Setting P8 Instructions to STOPPED.\n";
        VBU_Cacheline::P8_Ins_Stop();
        VBU_Cacheline::P8_Flush_L2();
    }
    
    ( my $flag, my $sts ) = getShutDownStatus();
    if ( $flag )
    {
        print   STDOUT  "Sorry, HostBoot has already shut down with status $sts, cannot run isteps.\n";
        exit;
    }

    ##
    ## Process resume
    ##
    if ( $opt_resume )
    {
        resume_istep();
        ## exit; ??
    }

    ##
    ##  process --Istep Mode command
    ##      IStepModeStr    = "cpu0_0_0_3->scratch=0x4057b007_4057b007"
    ##      NormalModeStr   = "cpu0_0_0_3->scratch=0x700b7504_700b7504"
    ##
    if ( $opt_istepmode ==  1   )
    {
        my $result = VBU_Cacheline::CLread( $istepmodereg );
        if ( $opt_debug )   { print STDERR __LINE__, "-- Entry:   IStep Mode Reg = $result";  }
        if  ( $result =~ /^.*ISTEP_MODE_OFF_SIGNATURE/ )
        {
            print STDOUT "Sorry, HostBoot has already started in automatic mode.  Please restart and then try again.\n";
            exit;
        }     

        print STDOUT  "ENable istepmode\n";
        setMode( "istep" );
    }

    if  ( $opt_normalmode ==  1 )
    {
        print STDOUT  "DISable istepmode\n";
        setMode( "normal" );
    }

    if ( $opt_clear_trace )
    {
        print   STDOUT  "Clear Trace Buffers\n";
        clear_trace();
    }

    ##
    ##  Process other commands
    ##
    if ( $opt_command ne "" )
    {
        if ( $opt_debug ) {   print   STDERR  "== __LINE__ process command \"$opt_command\" \n"; }
        parse_command( $opt_command ); 
    }
        
}   ##  end main


#------------------------------------------------------------------------------
# Print command line help
#------------------------------------------------------------------------------
sub printUsage()
{
    print STDOUT "\nUsage: hb-istep   [--help]\n";
    print STDOUT "    [--istepmode]             (enable istep mode)\n" ;
    print STDOUT "    [--normalmode]            (disable istep mode)\n" ;
    print STDOUT "    [--command sN]            (run istep N)\n" ;
    print STDOUT "    [--command sN..M]         (run isteps N through M)\n" ;
    print STDOUT "    [--command <foo>]         (run named istep \"foo\")\n" ;
    print STDOUT "    [--command <foo>..<bar>]  (run named isteps \"foo\" through \"bar\")\n" ;
    print STDOUT "    [--resume]                (resume an istep that is at a break point)\n" ;
    print STDOUT "\n" ;
    print STDOUT "  [--clear-trace]             (clear trace buffers before starting)\n";    
##    print STDOUT "  [--cmdfile]                 (get commands from a batchfile)\n";
##    print STDOUT "  [--setup]                   (bring up AWAN and wait for further commands)\n";
##    print STDOUT "\n" ;

}

##
##  Increment the sequence number, rolling over at 64
##
sub bumpSeqNum()
{

    $g_SeqNum++;            
    
    $g_SeqNum   %=  64;
    
    return  $g_SeqNum;
}

##
##  read in file with csv istep list and store in inList
##
sub get_istep_list()
{
    my $istep, my $substep, my $name ;
   
    open( FH, "< $CSVfile") or die "can't open $CSVfile : $!";

    while( <FH> )
    {
        chomp;

        ( $istep, $substep, $name) =   split( ",", $_ ); 
        chomp $name;
        ## print STDERR    "$_, $istep, $substep, $name\n" ;
         
        if ( defined($name) && ( $name ne "" ) )
        {
            $inList[$istep][$substep]    =   $name;
        } 
    }         
    
    close( FH );     
}

##
##  print the istep list to the screen.
##
sub print_istep_list( )
{
    my  $hdrflag    =   1;

    ##  print   STDOUT  "IStep\tSubStep\tName\n";
    print   STDOUT  " IStep Name\n";    
    print   STDOUT  "---------------------------------------------------\n";
    
    for(my $i = 0; $i < MAX_ISTEPS; $i++)
    {
        for(my $j = 0; $j < MAX_SUBSTEPS; $j++)
        {

            ## print "==$i.$j $inList[$i][$j] \n";
            if ( defined( $inList[$i][$j] ) )
            {
                if ( $hdrflag )  
                { 
                    printf  STDOUT  " -- IStep $i --  \n"; 
                    $hdrflag = 0;
                }
                ## printf  STDOUT  "%d\t%d\t%s\n", $i, $j, $inList[$i][$j] ; 
                printf  STDOUT  " %s\n", $inList[$i][$j] ; 
            }  
        }   ## end for $j
        $hdrflag=1;
    }   ##  end for $i     
}


##
##  
##
sub find_in_inList( $ ) 
{
    my  ( $substepname )    =   @_;
    
    for(my $i = 0; $i < MAX_ISTEPS; $i++)
    {
        for(my $j = 0; $j < MAX_SUBSTEPS; $j++)
        {
            ## if ( defined($inList[$i][$j]) ) {   print ".$inList[$i][$j]?$substepname. \n";   }
            
            if ( defined($inList[$i][$j]) && ($inList[$i][$j] eq $substepname ) )
            {
                ## print "== $i $j $inList[$i][$j] \n";
                return  ($i, $j, 1 );
            }  
        }
    }     

    return ( MAX_ISTEPS, MAX_SUBSTEPS, 0 )  
} 

##
##  Check if HostBoot has already run and shutdown.  
sub getShutDownStatus()
{

    my $flag    =   VBU_Cacheline::CLread( $shutdownflag );
    my $status  =   VBU_Cacheline::CLread( $shutdownsts );
    
    if ( $opt_debug )   
    {   
        print   STDERR "Shutdown Flag   =   $flag\n";
        print   STDERR "Shutdown Status =   $status\n";       
    }

    return ( $flag, $status );
}

##
##  keep trying to get status until seqnum syncs up 
##
sub getSyncStatus( )
{
    # set # of retries
    ## @todo revisit
    my  $count  =   1000;
    my  $result =   0; 
    my  $seqnum =   0;  
    my  $running =  0;
    
    ##  get response.  sendCmd() should have bumped g_SeqNum, so we will sit
    ##  here for a reasonable amount of time waiting for the correct sequence
    ##  number to come back.  
    while(1)
    {


    
        ##  advance HostBoot code by a certain # of cycles, then check the 
        ##  sequence number to see if it has changed.  rinse and repeat.
        ##  Note:  RunClocks will start instructions 
        VBU_Cacheline::RunClocks();
        system ("$hbToolsDir/hb-ContTrace --mute > /dev/null");
        system ("cat hb-ContTrace.output >> tracMERG");

        ##  Stop instructions, flush L2
        VBU_Cacheline::P8_Ins_Stop();
        VBU_Cacheline::P8_Flush_L2();

        
        ##  dump printk similar to the Jim McGuire's script
        ##  NOPE, CRASHES AWAN dumpPrintk();

        ## check for system crash
        my ( $flag, $status )  =   getShutDownStatus();
        if ( $flag )
        {
            print   STDOUT  "HostBoot has shut down with status $status";
            return -1;
        }

        $result      = VBU_Cacheline::CLread( $statusreg );

        $seqnum      =   ( ( $result & 0x3f00000000000000 ) >> 56 );
        $running     =   ( ( $result & 0x8000000000000000 ) >> 63 );
        ## if (    ( $running == 0 )
        ##     && ( $seqnum == $g_SeqNum )
        if  ( $seqnum == $g_SeqNum )
        {
            return $result;
        }
        
        if ($opt_debug)   
            {   printf  STDERR __LINE__,  "===== getSyncStatus:  count=%d, result=0x%lx\n", $count, $result  } 
        
        if ( $count <= 0 )
        {
            print STDOUT    "TIMEOUT waiting for seqnum=$g_SeqNum\n";
            return -1;
        }
        
        $count--;
    }   ##  endwhile    
          
} 

##
##  Run an istep
##
sub runIStep( $$ )
{
    my  ( $istep, $substep)  = @_;
    my  $byte0, my $command;
    my  $cmd;
    my  $result;
    
    
    ##  bump the seqnum
    bumpSeqNum();
    
    printf   STDOUT  "run  %d.%d %s:\n", $istep, $substep, $inList[$istep][$substep];
    
    $byte0   =   0x80 + $g_SeqNum;      ## gobit + seqnum
    $command =   SPLESS_SINGLE_ISTEP_CMD;
    $cmd = sprintf( "0x%2.2x%2.2x%2.2x%2.2x00000000", $byte0, $command, $istep, $substep );
    VBU_Cacheline::CLwrite( $commandreg, $cmd );
    
    $result  =   getSyncStatus();
    
    ## if result is -1 we have a timeout
    if ( $result == -1 )
    {
        print   "-----------------------------------------------------------------\n";
    }
    else
    {
        my $taskStatus  =   ( ( $result & 0x00ff000000000000 ) >> 48 );
        my $stsIStep    =   ( ( $result & 0x0000ff0000000000 ) >> 40 );
        my $stsSubstep  =   ( ( $result & 0x000000ff00000000 ) >> 32 );
        my $istepStatus =   ( ( $result & 0x00000000ffffffff )  );

        print   STDOUT "-----------------------------------------------------------------\n";
        ## printf STDOUT "Istep %d.%d Status: 0x%x\n", $stsIStep, $stsSubstep, $istepStatus ; 
        if ( $taskStatus != 0 )
        {
            if ( $taskStatus == 11 )
            {
                printf STDOUT "At breakpoint 0x%x\n", $istepStatus;
            }
            else
            {
                printf STDOUT "Istep %d.%d FAILED to launch, task status is %d\n",
                       $stsIStep, $stsSubstep, $taskStatus ;
            }
        }
        else
        {            
            printf STDOUT "Istep %d.%d returned Status: 0x%x", $stsIStep, $stsSubstep, $istepStatus ;
            if ( $istepStatus == 0xa )
            {
                printf STDOUT   ": not implemented yet.\n";
            }
            else
            {
                printf STDOUT   "\n";
            }
        }
           
        print STDOUT "-------------------------------------------------------------- $g_SeqNum\n";
    }     
}   
    
##    
##  run command = "sN"
##    
sub sCommand( $ )
{
    my  ( $scommand )   =   @_;
    
    my  $i   =   $scommand;
    my  $j   =   0;
    
    #   execute all the substeps in the IStep
    for( $j=0; $j<$#inList; $j++ )
    {
        ## print   "-----------------" 
        ##print STDOUT  "run IStep %d %s  ...\n", $i, $inList[$i][$j] );
        ##print   "-----------------" 
        if ( defined( $inList[$i][$j] ) )
        {
            runIStep( $i, $j );
        }
    }
}
     
##
##  parse --command [command] option and execute it.
##
sub parse_command( $ )
{
    my  ( $command ) =   @_;
    my  @execlist;
    my  $istepM, my $substepM, my $foundit, my $istepN, my $substepN;
    my  $M, my $N, my $scommand;
    my  @ss_list;
    
    ## check to see if we have an 's' command (string starts with 's' and a number) 
    chomp( $command);   
    if ( $command =~ m/^s+[0-9].*/ )
    {
        ## run "s" command
        if ($opt_debug) {   print STDERR __LINE__, "===== s command : ", $command, ":\n";   } 
        substr( $command, 0, 1, "" );
 
        if ( isdigit( $command ) )
        {
            # command = "sN"
            if ($opt_debug) {   print STDERR __LINE__, "===== single IStep: ", $command, "\n";  }
            sCommand( $command ); 
        }
        else
        {
            #   list of substeps = "sM..N"
            ( $M, $N )  =   split( /\.\./, $command );
            
            if ($opt_debug) {   print STDERR "===== multiple ISteps: ", $M, "-", $N, "\n";    } 
            for ( my $x=$M; $x<$N+1; $x++ )
            {
                sCommand( $x );
            }          
        }                   
    }
    else
    {  
        ## <substep name>, or <substep name>..<substep name>
        @ss_list    =   split( /\.\./, $command );        
        
        if ($opt_debug) {   print STDERR __LINE__, "===== named commands : ", @ss_list, "\n";    } 
            
        ( $istepM, $substepM, $foundit) = find_in_inList( $ss_list[0] );
        $istepN      =   $istepM;
        $substepN    =   $substepM;
        if ( ! $foundit )
        {
            print STDOUT "Invalid substep ", $ss_list[0], "\n" ;
            return -1;
        }
        
            
        if ( $#ss_list > 0 )
        {    
            ( $istepN, $substepN, $foundit) = find_in_inList( $ss_list[1] );
            if ( ! $foundit )
            {
                print STDOUT "Invalid substep %s", $ss_list[1], "\n" ;
                return -1;
            }
        }
        
        ## print "got it, running isteps:\n";
        for( my $x=$istepM; $x<$istepN+1; $x++ )
        {
            for( my $y=$substepM; $y<$substepN+1; $y++ )
            {
                ## print STDOUT "run $x $y $inList[$x][$y]\n";
                if ( defined( $inList[$x][$y] ) )
                {
                    runIStep( $x, $y );
                }
            }
        }
        
    }   
}

##
##  write to scratch reg 3 to set istep or normal mode, check return status 
##       
sub setMode( $ )
{
    my  ( $cmd )    =   @_;
    
    my  $count      =   1000;
    my  $expected   =   0;
    my  $readybit   =   0;
    my  $result     =   0;
   

    if ( $cmd eq "istep" )
    {
        VBU_Cacheline::CLwrite( $istepmodereg, "0x4057b0074057b007" );
        $expected    =   1;    
    }
    elsif   ( $cmd eq "normal" )
    {
        VBU_Cacheline::CLwrite( $istepmodereg, "0x700b7504700b7504" );
        $expected    =   0;
    }
    else
    {      
        print "invalid setMode command: %s\n", $cmd ;
        return  -1;
    }        
    
    if ( $opt_debug )   
    {
        ##  readback and display 
        $result = VBU_Cacheline::CLread( $istepmodereg );
        printf STDERR __LINE__,   "=====  istepmodereg readback:  0x%lx\n", $result ;
    }
 

    ##  Loop, advancing clock, and wait for readybit
    ##  @todo   revisit
    while(1)
    {
        ##  advance HostBoot code by a certain # of cycles, then check the 
        ##  sequence number to see if it has changed.  rinse and repeat.
        VBU_Cacheline::RunClocks();
        system ("$hbToolsDir/hb-ContTrace --mute > /dev/null");
        system ("cat hb-ContTrace.output >> tracMERG");

        ##  Stop instructions, flush L2
         VBU_Cacheline::P8_Ins_Stop();
         VBU_Cacheline::P8_Flush_L2();



        ## check for system crash
        my ( $flag, $status )  =   getShutDownStatus();
        if ( $flag )
        {
            print   STDOUT  "HostBoot has shut down with status $status";
            return -1;
        }
        
        $result = VBU_Cacheline::CLread( $statusreg );
        
        $readybit    =   ( ( $result & 0x4000000000000000 ) >> 62 );
        
        if ($opt_debug)   
            { printf  STDERR __LINE__,  "===== setMode:  count=%d, result=0x%lx, readybit=0x%x\n", $count, $result, $readybit  } 

        if ( $readybit == $expected )
        {
            print STDOUT "Set $cmd Mode success.\n" ;
            return 0;
        }
            
        if ( $count <= 0 )
        {
            print STDOUT "TIMEOUT waiting for readybit, status=0x%x\n", $result ;
            return -1;
        }
           
        $count--;
    } 
}


sub resume_istep()
{
    my $byte0;
    my $command;
    my $cmd;
    my $result;

    bumpSeqNum();       ## bump

    printf STDOUT "resume from breakpoint\n";

    $byte0 = 0x80 + $g_SeqNum;      ## gobit + seqnum
    $command = SPLESS_RESUME_ISTEP_CMD;
    $cmd = sprintf( "0x%2.2x%2.2x000000000000", $byte0, $command );
    VBU_Cacheline::CLwrite( $commandreg, $cmd );

    ## dgxx
    while(1)
    {
        $result = getSyncStatus();

        ## if result is -1 we have a timeout
        last if ( $result == -1 );

        my $taskStatus  =   ( ( $result & 0x00ff000000000000 ) >> 48 );
        my $stsIStep    =   ( ( $result & 0x0000ff0000000000 ) >> 40 );
        my $stsSubstep  =   ( ( $result & 0x000000ff00000000 ) >> 32 );
        my $istepStatus =   ( ( $result & 0x00000000ffffffff )  );
        my $running     =   ( ( $result & 0x8000000000000000 ) >> 63 );

        print   STDOUT "-----------------------------------------------------------------\n";

        ## At this point the status is:
        ##  1) hostboot code was not at a breakpoint - resume ignored (result == 12)
        ##  2) hostboot resumed from breakpoint, but has not reached the end of
        ##     the istep. (running flag on, result is 0)
        ##  3) hostboot resumed, but is at a new breakpoint
        ##  4) hostboot resumed and is at the end of the istep
        ##     (running flag off, result is rc from istep

        if ( $taskStatus != 0 )
        {
            if ( $taskStatus == 11 )  # HB at new break point
            {
                printf STDOUT "At breakpoint 0x%x\n", $istepStatus;
                last;
            }
            elsif ( $taskStatus == 12 )  # HB not at a break point
            {
                printf STDOUT "resume istep ignored, task status is %d\n", $taskStatus ;
                last;
            }
            else
            {
                printf STDOUT "Istep %d.%d returned Status: 0x%x\n",
                      $stsIStep, $stsSubstep, $istepStatus ;
                last;
            }
        }
        else
        {
            if( $running == 0 )
            {
                printf STDOUT "Istep %d.%d returned Status: 0x%x\n",
                    $stsIStep, $stsSubstep, $istepStatus ;
                last;
            }
                        
            ## continue to wait for istep to complete
        }

    }
    print STDOUT "-----------------------------------------------------------------\n";

}

sub clear_trace( )
{
    my  $byte0, my $command;
    my  $cmd;
    my  $result;
    
    
    ##  bump the seqnum
    bumpSeqNum();
    
    $byte0   =   0x80 + $g_SeqNum;      ## gobit + seqnum
    $command =   SPLESS_CLEAR_TRACE_CMD;
    $cmd = sprintf( "0x%2.2x%2.2x%2.2x%2.2x00000000", $byte0, $command, 0, 0 );
    VBU_Cacheline::CLwrite( $commandreg, $cmd );
    
    $result  =   getSyncStatus();
    
    ## if result is -1 we have a timeout
    if ( $result == -1 )
    {
        print   "-----------------------------------------------------------------\n";
    }
    else
    {
        print STDOUT "---------------------------------------------------------------\n";
        print STDOUT "Trace Buffers Cleared.\n"  ;
    }
    
    print STDOUT "---------------------------------------------------------------\n";
}   



__END__

