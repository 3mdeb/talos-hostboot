#!/usr/bin/perl
#  IBM_PROLOG_BEGIN_TAG
#  This is an automatically generated prolog.
#
#  $Source: src/build/tools/gensyms $
#
#  IBM CONFIDENTIAL
#
#  COPYRIGHT International Business Machines Corp. 2011
#
#  p1
#
#  Object Code Only (OCO) source materials
#  Licensed Internal Code Source Materials
#  IBM HostBoot Licensed Internal Code
#
#  The source code for this program is not published or other-
#  wise divested of its trade secrets, irrespective of what has
#  been deposited with the U.S. Copyright Office.
#
#  Origin: 30
#
#  IBM_PROLOG_END

use strict;

use IO::Seekable;

my $littleendian = (unpack("L", pack("N", 0xabcd1234)) != 0xabcd1234);

sub add_image_subdir
{
    my $image = shift;
    if (!($image =~ m/\/img/)) { $image = "./img/".$image };
    return $image;
}

my $image_offset = $ENV{"HAL_IMAGE_OFFSET"};
if (not $image_offset) { $image_offset = "0x0"; };
$image_offset = hex $image_offset;

my $image;
my $extimage;
my $extoffset;
my $all_modules = 0;
my @modules = ();

if ($#ARGV <= 1)
{
    die "gensyms <image> <extimage> <extoffset> [modules]\n";
}

if ($#ARGV == 2)
{
    $all_modules = 1;
}
else
{
    @modules = @ARGV[3..$#ARGV];
}

my $extoffset = hex $ARGV[2];

$image = add_image_subdir($ARGV[0]);
open IMAGE, "< $image";
binmode(IMAGE);
$extimage = add_image_subdir($ARGV[1]);
open EXTIMAGE, "< $extimage";
binmode(EXTIMAGE);

my %module_offsets = ();
open MODINFO, "< $image.modinfo";

while (my $modline = <MODINFO>)
{
    chomp $modline;
    my @splitline = split /,/, $modline;
    $module_offsets{@splitline[0]} = (hex @splitline[1]) + $image_offset;
    if ($all_modules)
    {
	push @modules, @splitline[0];
    }
}

my @output = ();
foreach my $module (@modules)
{
    open OBJDUMP, ("ppc64-mcp6-objdump --syms -C ".add_image_subdir($module)."|");
    while (my $line = <OBJDUMP>)
    {
	if (($line =~ m/\*ABS\*/) || ($line =~ m/\*UND\*/))
	{
	    next;
	}
	if ("d" eq substr($line, 22, 1))
	{
	    next;
	}
	if (!($line =~ m/^[0-9a-f]{16}/))
	{
	    next;
	}

	$line =~ s/[\s]*$//;
	
	my $address = (hex substr($line, 0, 16)) + $module_offsets{$module};
	my $is_function = ("F" eq substr($line, 23, 1));
        my $size = (hex substr($line, 32, 16));
	my $name = substr($line, 48);
	my $code_loc = 0;
	if ($is_function)
	{
            if (($address - $image_offset) > $extoffset)
            {
                seek EXTIMAGE,
                     ($address - ($image_offset + $extoffset)), SEEK_SET;
                read EXTIMAGE, $code_loc, 8;
            }
            else
            {
                seek IMAGE, ($address - $image_offset), SEEK_SET;
                read IMAGE, $code_loc, 8;
            }
            if ($littleendian)
            {
                $code_loc = unpack("Q", reverse($code_loc)) + $image_offset;
            }
            else
            {
                $code_loc = unpack("Q", $code_loc) + $image_offset;
            }

            my $tmp = $code_loc; $code_loc = $address; $address = $tmp;
	}
	my $outstring = "";
	$outstring = sprintf "%s,%08x,%08x,%08x,%s\n", ($is_function?"F":"V"),$address,$code_loc,$size,$name;

	push @output, $outstring;
    }
    close OBJDUMP;
}

close IMAGE;
close EXTIMAGE;

foreach my $outstring (sort { substr($a,2) cmp substr($b,2) } @output)
{
    print $outstring;
}
