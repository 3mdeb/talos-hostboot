#  Joe's initfile reference page:
#  https://w3-connections.ibm.com/wikis/home?lang=en-us#!/wiki/W9dc674bd1c19_432e_9f66_0e8b6ce7195f/page/P9%20Initfile%20Strategy%20%26%20Execution
#  http://ausxgsatm2.austin.ibm.com/gsa/home/j/m/jmcgill/web/public/p8/initfiles/mba_def.initfile

#--******************************************************************************
#-- IMPORTANT SUPPORT NOTES AS OF 3/28/2017
#--******************************************************************************
# Here we assume WL = ATTR_EFF_DRAM_CWL (which is true if no Additive Latency / Posted CAS).
#      So no support for Posted CAS / Additive latency
# Only supports Burst Length 8 (CODE AND LOGIC STATEMENT)
#      Initfile is hardcoded assuming BL=8 and BL/2=4
#      Attribute does exist for Burst length. However, Nimbus logic does NOT support any other burst lengths
#           If other burst lengths are to be supported, a logic change would be required
# Only supports RDIMM with RDIMM and LRDIMM with LRDIMM, no mixing (CODE AND LOGIC STATEMENT)
#      Logic would have to support different wr data delays to differen DIMMs. It does NOT.
#
#--******************************************************************************
#-- FUTURE ENHANCEMENTS
#--******************************************************************************
# ATTR_EFF_TCCD_S attribute (hardcoded to 4 for now)


#--******************************************************************************
#-- REFERENCES FOR FILE (note: exact paths may move)
#--******************************************************************************
# Files used to check what target type attributes are 
#      ekb/chips/p9/procedures/xml/attribute_info/*.xml
#      Example:
#           <id>ATTR_EFF_NUM_RANKS_PER_DIMM</id>
#           <targetType>TARGET_TYPE_MCS</targetType>
# File used to see if attribute is 1D or 2D array
#      ekb/output/gen/attribute_ids.H
#      Example:
#           typedef uint8_t ATTR_EFF_DIMM_TYPE_Type[2][2];
# File for finding correct spydef name
#      1st find the spydef file this ekb build is looking at by finding SPYDEF_FILE_LOCATION in file below
#           ekb/tools/ifCompiler/scan_procedures.mk
#      2nd open *.spydef in that dir and search for spy names
#           /afs/awd/projects/eclipz/lab/p9/vbu_models/n10_e9067_tp058_ec163uXXa_soa_sq_u190_01/edc/*.spydef
#      (File comes from actually building a vbu file and looking at the spydef)
#      Example:
#           idial MCP.PORT1.SRQ.PC.MBAREF0Q_CFG_TRFC {
# Wrapper file calling this
#      ekb/chips/p9/procedures/hwp/memory/p9_mss_scominit.C
# Output file generated
#      ekb/chips/p9/procedures/hwp/initfiles/p9_mca_scom.C
#
# COMMON DEBUG
#      -debug5.16.i6.d
#      If complaining unsupported attribute, try commenting out of attribute in attribute file
#      If complaining memory fault, maybe wrong integer length in attribute file


#--******************************************************************************
#-- Required keywords/variables
#--******************************************************************************

SyntaxVersion = 3

target_type 0 TARGET_TYPE_MCA;
target_type 1 TARGET_TYPE_MCBIST;
target_type 2 TARGET_TYPE_MCS;
target_type 3 TARGET_TYPE_SYSTEM;
target_type 4 TARGET_TYPE_PROC_CHIP;


define MCBIST = TGT1; # If referencing Attr from mcbist, add "MCBIST." in front
define MCS = TGT2; # If referencing Attr from mcs, add "MCS." in front
define SYS = TGT3; # If referencing Attr from system, add "SYS." in front
define PROC = TGT4; # If referencing Attr from chip, add "PROC." in front

define def_IS_HW  = SYS.ATTR_IS_SIMULATION == 0;
define def_IS_SIM = SYS.ATTR_IS_SIMULATION == 1;

#--******************************************************************************
#-- Systems Config
#--******************************************************************************

#--******************************************************************************
#-- Effective Attributes
#--******************************************************************************

# PORT INDEX FOR ACCESSING PROPER ENTRY IN ARRAY
define def_POSITION       =   ATTR_CHIP_UNIT_POS;
define def_PORT_INDEX     =   def_POSITION % 2;

# define frequency range for potential support of sync mode
define def_MSS_FREQ_EQ_1866     =   (                                  (MCBIST.ATTR_MSS_FREQ<1867));
define def_MSS_FREQ_EQ_2133     =   ((MCBIST.ATTR_MSS_FREQ>=1867)  &&  (MCBIST.ATTR_MSS_FREQ<2134));
define def_MSS_FREQ_EQ_2400     =   ((MCBIST.ATTR_MSS_FREQ>=2134)  &&  (MCBIST.ATTR_MSS_FREQ<2401));
define def_MSS_FREQ_EQ_2666     =   ((MCBIST.ATTR_MSS_FREQ>=2666)                                 );

define def_MEM_TYPE_1866_13   =   def_MSS_FREQ_EQ_1866    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 13 );
define def_MEM_TYPE_1866_14   =   def_MSS_FREQ_EQ_1866    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 14 );
define def_MEM_TYPE_2133_15   =   def_MSS_FREQ_EQ_2133    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 15 );
define def_MEM_TYPE_2133_16   =   def_MSS_FREQ_EQ_2133    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 16 );
define def_MEM_TYPE_2400_16   =   def_MSS_FREQ_EQ_2400    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 16 );
define def_MEM_TYPE_2400_17   =   def_MSS_FREQ_EQ_2400    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 17 );
define def_MEM_TYPE_2400_18   =   def_MSS_FREQ_EQ_2400    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 18 );
define def_MEM_TYPE_2666_18   =   def_MSS_FREQ_EQ_2666    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 18 );
define def_MEM_TYPE_2666_19   =   def_MSS_FREQ_EQ_2666    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 19 );
define def_MEM_TYPE_2666_20   =   def_MSS_FREQ_EQ_2666    &&  ( MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] == 20 );

define def_NUM_RANKS            = (   MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][0]
                                    + MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][1] );

# We don't have a div 0 problem here as we don't run this if we don't have DIMM so the number of ranks won't be 0.
define def_REFRESH_INTERVAL     =   ((MCS.ATTR_EFF_DRAM_TREFI[def_PORT_INDEX])/(8*def_NUM_RANKS));

define def_RANK_SWITCH_TCK      =   4 + ((MCBIST.ATTR_MSS_FREQ-1866)/267);         # 1866: 4  2133: 5  2400: 6  2666: 7
define def_BUS_TURNAROUND_TCK   =   4 + ((MCBIST.ATTR_MSS_FREQ-1866)/267);         # 1866: 4  2133: 5  2400: 6  2666: 7

# Funky ... If the attribute is 0, then the value of the == operation will be 1 which bitwise-or'd with 0 gives us 1. If the attribute is != 0, then the
# value of the == operation will be 0 which when bitwise-or'd with the attribute will give us the attribute value. Love, Prachi, Jenny, Shelton and Brian.
define def_SLOT0_DENOMINATOR    = (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0] == 0x0) | MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0];
define def_SLOT1_DENOMINATOR    = (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][1] == 0x0) | MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][1];

define def_SLOT0_DRAM_STACK_HEIGHT = (   MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][0]
                                         / def_SLOT0_DENOMINATOR );
define def_SLOT1_DRAM_STACK_HEIGHT = (   MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][1]
                                         / def_SLOT1_DENOMINATOR );

# Epsilon Related
#    There is a 4 window variance of actual wait for each setting x
#       (Because implemented with a 4 cycle free running timebase)
#       The Window: 4x-3 <= Actual wait <= 4x
#    The attribute ATTR_PROC_EPS_READ_CYCLES_T# represents min wait required
#    Entire window of possible actual waits must be > required wait
#       Working this out in a table
#          EPS NEEDED | SETTING | RESULTANT WAIT
#              5      |    2    |   5 -  8      
#              6      |    3    |   9 - 12      
#              7      |    3    |   9 - 12      
#              8      |    3    |   9 - 12      
#              9      |    3    |   9 - 12      
#             10      |    4    |  13 - 16      
#       Resulting formula: setting = ( required + 6 ) / 4

define def_MC_EPSILON_CFG_T0 = ( SYS.ATTR_PROC_EPS_READ_CYCLES_T0 + 6 ) / 4;
define def_MC_EPSILON_CFG_T1 = ( SYS.ATTR_PROC_EPS_READ_CYCLES_T1 + 6 ) / 4;
define def_MC_EPSILON_CFG_T2 = ( SYS.ATTR_PROC_EPS_READ_CYCLES_T2 + 6 ) / 4;

#--******************************************************************************
#-- Dial Assignments
#--******************************************************************************

#   TMR0 SCOM REGISTER   #
# DRAM TIMING PARAMETERS #

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RRDM_DLY [when=S] {      # BL/2+rank_switch
  spyv;
  4 + def_RANK_SWITCH_TCK;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RRSMSR_DLY [when=S] {    # tccd_s
  spyv;
  4;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RRSMDR_DLY [when=S] {    # tccd_s
  spyv;
  4;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RROP_DLY [when=S] {      # tccd_l
  spyv;
  MCS.ATTR_EFF_DRAM_TCCD_L[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WWDM_DLY [when=S] {      # BL/2+rank_switch
  spyv;
  4 + def_RANK_SWITCH_TCK;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WWSMSR_DLY [when=S] {    # tccd_s
  spyv;
  4;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WWSMDR_DLY [when=S] {    # tccd_s
  spyv;
  4;
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WWOP_DLY [when=S] {      # tccd_l
  spyv;
  MCS.ATTR_EFF_DRAM_TCCD_L[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RWDM_DLY [when=S] {      # (RL+BL/2+turn_around)-WL
  spyv;
  MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] + 4 + def_BUS_TURNAROUND_TCK - MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RWSMSR_DLY [when=S] {    # (RL+BL/2+turn_around)-WL
  spyv;
  MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] + 4 + def_BUS_TURNAROUND_TCK - MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_RWSMDR_DLY [when=S] {    # (RL+BL/2+turn_around)-WL
  spyv;
  MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] + 4 + def_BUS_TURNAROUND_TCK - MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WRDM_DLY [when=S] {      # (WL+BL/2+turn_around)-RL
  spyv;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 4 + def_BUS_TURNAROUND_TCK - MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WRSMSR_DLY [when=S] {    # WL+BL/2+(Twtr_s/clock period)
  spyv;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 4 + MCS.ATTR_EFF_DRAM_TWTR_S[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR0Q_WRSMDR_DLY [when=S] {    # WL+BL/2+Twtr_s
  spyv;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 4 + MCS.ATTR_EFF_DRAM_TWTR_S[def_PORT_INDEX];
}


#   TMR1 SCOM REGISTER   #
# DRAM TIMING PARAMETERS #

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_RRSBG_DLY [when=S] {     # tCCDL
  spyv;
  MCS.ATTR_EFF_DRAM_TCCD_L[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_WRSBG_DLY [when=S] {     # WL+BL/2+Twtr_l
  spyv;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 4 + MCS.ATTR_EFF_DRAM_TWTR_L[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_TFAW [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TFAW[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_TRCD [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRCD[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_TRP [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRP[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_TRAS [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRAS[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_WR2PRE [when=S] {        # CWL+BL/2+Twr
  spyv;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 4 + MCS.ATTR_EFF_DRAM_TWR[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_RD2PRE [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRTP[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_TRRD [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRRD_S[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_TRRD_SBG [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRRD_L[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_TMR1Q_CFG_ACT_TO_DIFF_RANK_DLY [when=S] {
  spyv, expr;
  8,                                 (def_MSS_FREQ_EQ_1866==1);
  9,                                 (def_MSS_FREQ_EQ_2133==1);
  10,                                (def_MSS_FREQ_EQ_2400==1);
  11,                                (def_MSS_FREQ_EQ_2666==1);
}


#   DSM0 SCOM REGISTER   #
# DRAM TIMING PARAMETERS #

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_RDTAG_DLY [when=S] {         # ATTR_EFF_DIMM_TYPE:  CDIMM = 0 RDIMM = 1 UDIMM = 2 LRDIMM = 3
  spyv, expr;

  # rdtag_dly + 3 + rdptrdly > PHY DELAY + CL 
  # rdtag_dly > PHY DELAY + CL - 3 - rdptrdly
  #     PHY DELAY = 12 for 1866 and 2133, 13 for 2400 and 2666, +1 for LRDIMM
  #     rdptrdly = 1
  # 4/20/2017 during performance test, experimentally found can run at -1 value

  17,                                def_IS_SIM;

  7  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_1866==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==1) && def_IS_HW; # RDIMM
  7  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2133==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==1) && def_IS_HW; # RDIMM
  8  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2400==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==1) && def_IS_HW; # RDIMM
  8  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2666==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==1) && def_IS_HW; # RDIMM

  8  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_1866==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==3) && def_IS_HW; # LRDIMM
  8  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2133==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==3) && def_IS_HW; # LRDIMM
  9  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2400==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==3) && def_IS_HW; # LRDIMM
  9  + MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX], (def_MSS_FREQ_EQ_2666==1) && (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==3) && def_IS_HW; # LRDIMM

}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_WRDATA_DLY [when=S] {
  spyv, expr;
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + MCS.ATTR_MSS_VPD_MR_DPHY_WLO[def_PORT_INDEX] - 8,     (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]==1); #     RDIMM
  MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + MCS.ATTR_MSS_VPD_MR_DPHY_WLO[def_PORT_INDEX] - 9,     (MCS.ATTR_EFF_DIMM_TYPE[def_PORT_INDEX][0]!=1); # not RDIMM
}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_WRDONE_DLY [when=S] {
  spyv;
  24;
}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_RODT_START_DLY [when=S] {
  spyv;
  # CL - CWL
  MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] - MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_RODT_END_DLY [when=S] {
  spyv;
  # CL - CWL + BL/2 + 1
  MCS.ATTR_EFF_DRAM_CL[def_PORT_INDEX] - MCS.ATTR_EFF_DRAM_CWL[def_PORT_INDEX] + 5;
}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_WODT_START_DLY [when=S] {
  spyv;
   0;
}

ispy  MCP.PORT0.SRQ.MBA_DSM0Q_CFG_WODT_END_DLY [when=S] {
  spyv;
   5;
}

#  FARB0 SCOM REGISTER   #

espy  MCP.PORT0.SRQ.MBA_FARB0Q_CFG_PARITY_AFTER_CMD [when=S] {
  spyv;
  ON;
}

#  REF0 SCOM REGISTER    #

#gdial std_size 4gbx4 (8GB rank)

ispy  MCP.PORT0.SRQ.PC.MBAREF0Q_CFG_REFRESH_INTERVAL [when=S] {
  spyv;
  def_REFRESH_INTERVAL;
}

ispy  MCP.PORT0.SRQ.PC.MBAREF0Q_CFG_TRFC [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRFC[def_PORT_INDEX];
}

ispy  MCP.PORT0.SRQ.PC.MBAREF0Q_CFG_REFR_TSV_STACK [when=S] {
  spyv;
  MCS.ATTR_EFF_DRAM_TRFC_DLR[def_PORT_INDEX];
}


#  RPC0 SCOM REGISTER    #

ispy  MCP.PORT0.SRQ.PC.MBARPC0Q_CFG_PUP_PDN [when=S] {         # tCKE
  spyv, expr;
  5,                                 (def_MSS_FREQ_EQ_1866==1);
  6,                                 (def_MSS_FREQ_EQ_2133==1);
  6,                                 (def_MSS_FREQ_EQ_2400==1);
  7,                                 (def_MSS_FREQ_EQ_2666==1);
}

ispy  MCP.PORT0.SRQ.PC.MBARPC0Q_CFG_PDN_PUP [when=S] {         # tPD
  spyv, expr;
  5,                                 (def_MSS_FREQ_EQ_1866==1);
  6,                                 (def_MSS_FREQ_EQ_2133==1);
  6,                                 (def_MSS_FREQ_EQ_2400==1);
  7,                                 (def_MSS_FREQ_EQ_2666==1);
}

ispy  MCP.PORT0.SRQ.PC.MBARPC0Q_CFG_PUP_AVAIL [when=S] {       # tXP
  spyv, expr;
  6,                                 (def_MSS_FREQ_EQ_1866==1);
  7,                                 (def_MSS_FREQ_EQ_2133==1);
  8,                                 (def_MSS_FREQ_EQ_2400==1);
  9,                                 (def_MSS_FREQ_EQ_2666==1);
}

#  STR0 SCOM REGISTER    #

ispy  MCP.PORT0.SRQ.PC.MBASTR0Q_CFG_TCKSRE [when=S] {
  spyv, expr;
  10,                                (def_MSS_FREQ_EQ_1866==1);
  11,                                (def_MSS_FREQ_EQ_2133==1);
  12,                                (def_MSS_FREQ_EQ_2400==1);
  14,                                (def_MSS_FREQ_EQ_2666==1);
}

ispy  MCP.PORT0.SRQ.PC.MBASTR0Q_CFG_TCKSRX [when=S] {
  spyv, expr;
  10,                                (def_MSS_FREQ_EQ_1866==1);
  11,                                (def_MSS_FREQ_EQ_2133==1);
  12,                                (def_MSS_FREQ_EQ_2400==1);
  14,                                (def_MSS_FREQ_EQ_2666==1);
}

ispy  MCP.PORT0.SRQ.PC.MBASTR0Q_CFG_TCKESR [when=S] {
  spyv;
  5;
}

ispy  MCP.PORT0.SRQ.PC.MBASTR0Q_CFG_TXSDLL [when=S] {
  spyv, expr;
  597,                               (def_MSS_FREQ_EQ_1866==1);
  768,                               (def_MSS_FREQ_EQ_2133==1);
  768,                               (def_MSS_FREQ_EQ_2400==1);
  939,                               (def_MSS_FREQ_EQ_2666==1);
}

# Make Safe Refresh Match Refresh Interval
ispy  MCP.PORT0.SRQ.PC.MBASTR0Q_CFG_SAFE_REFRESH_INTERVAL [when=S] {
  spyv;
  def_REFRESH_INTERVAL;
}


# CID
# Slot 0
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S0_CID [when=S] {
  spyv;
  0b000;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S1_CID [when=S] {
  spyv;
  0b100;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S2_CID [when=S] {
  spyv;
  0b010;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S3_CID [when=S] {
  spyv;
  0b110;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S4_CID [when=S] {
  spyv, expr;
  0b001,                                 (def_SLOT0_DRAM_STACK_HEIGHT == 8);
  0b000,                                 (def_SLOT0_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S5_CID [when=S] {
  spyv, expr;
  0b101,                                 (def_SLOT0_DRAM_STACK_HEIGHT == 8);
  0b100,                                 (def_SLOT0_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S6_CID [when=S] {
  spyv, expr;
  0b011,                                 (def_SLOT0_DRAM_STACK_HEIGHT == 8);
  0b010,                                 (def_SLOT0_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT0_S7_CID [when=S] {
  spyv, expr;
  0b111,                                 (def_SLOT0_DRAM_STACK_HEIGHT == 8);
  0b110,                                 (def_SLOT0_DRAM_STACK_HEIGHT != 8);
}
# Slot 1
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S0_CID [when=S] {
  spyv;
  0b000;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S1_CID [when=S] {
  spyv;
  0b100;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S2_CID [when=S] {
  spyv;
  0b010;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S3_CID [when=S] {
  spyv;
  0b110;
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S4_CID [when=S] {
  spyv, expr;
  0b001,                                 (def_SLOT1_DRAM_STACK_HEIGHT == 8);
  0b000,                                 (def_SLOT1_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S5_CID [when=S] {
  spyv, expr;
  0b101,                                 (def_SLOT1_DRAM_STACK_HEIGHT == 8);
  0b100,                                 (def_SLOT1_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S6_CID [when=S] {
  spyv, expr;
  0b011,                                 (def_SLOT1_DRAM_STACK_HEIGHT == 8);
  0b010,                                 (def_SLOT1_DRAM_STACK_HEIGHT != 8);
}
ispy MCP.PORT0.SRQ.MBA_FARB1Q_CFG_SLOT1_S7_CID [when=S] {
  spyv, expr;
  0b111,                                 (def_SLOT1_DRAM_STACK_HEIGHT == 8);
  0b110,                                 (def_SLOT1_DRAM_STACK_HEIGHT != 8);
}

# ODT RD
# Slot 0
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK0_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][0] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][0] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][0] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][0] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK1_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][1] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][1] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][1] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][1] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK2_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][2] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][2] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][2] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][2] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK3_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][3] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][3] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][3] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][0][3] >> 2; # assuming it only takes right most bit since right justified
}
# Slot 1
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK4_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][0] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][0] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][0] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][0] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK5_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][1] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][1] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][1] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][1] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK6_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][2] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][2] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][2] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][2] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK7_RD_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][3] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][3] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][3] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_RD[def_PORT_INDEX][1][3] >> 2; # assuming it only takes right most bit since right justified
}

# ODT WR
# Slot 0
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK0_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][0] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][0] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][0] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][0] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK1_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][1] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][1] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][1] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][1] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK2_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][2] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][2] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][2] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][2] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK3_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][3] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][3] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][3] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][0][3] >> 2; # assuming it only takes right most bit since right justified
}
# Slot 1
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK4_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][0] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][0] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][0] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][0] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK5_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][1] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][1] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][1] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][1] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK6_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][2] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][2] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][2] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][2] >> 2; # assuming it only takes right most bit since right justified
}
ispy MCP.PORT0.SRQ.MBA_FARB2Q_CFG_RANK7_WR_ODT [when=S] {
  bits, spyv;
  # ATTR is AB--CD-- but for SPY need ABCD
  0, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][3] >> 7; # assuming it only takes right most bit since right justified
  1, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][3] >> 6; # assuming it only takes right most bit since right justified
  2, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][3] >> 3; # assuming it only takes right most bit since right justified
  3, MCS.ATTR_MSS_VPD_MT_ODT_WR[def_PORT_INDEX][1][3] >> 2; # assuming it only takes right most bit since right justified
}

ispy MCP.PORT0.SRQ.PC.MBAREF0Q_CFG_REFRESH_PRIORITY_THRESHOLD [when=S] {
  spyv;
  3;
}

ispy MCP.PORT0.SRQ.PC.MBAREF0Q_CFG_REFR_CHECK_INTERVAL [when=S] {
  spyv;
  ( def_REFRESH_INTERVAL * def_NUM_RANKS * 6 ) / 5;
}

ispy MCP.PORT0.SRQ.MBA_WRQ0Q_CFG_WRQ_FIFO_MODE [when=S] {
  spyv;
  MCBIST.ATTR_MSS_REORDER_QUEUE_SETTING;
}

ispy MCP.PORT0.SRQ.MBA_RRQ0Q_CFG_RRQ_FIFO_MODE [when=S] {
  spyv;
  MCBIST.ATTR_MSS_REORDER_QUEUE_SETTING;
}

ispy MCP.PORT0.SRQ.MBA_FARB0Q_CFG_2N_ADDR [when=S] {
  spyv, expr;
  0b1,                      (SYS.ATTR_MSS_MRW_DRAM_2N_MODE==0x02); # force 2n
  0b0,                      (SYS.ATTR_MSS_MRW_DRAM_2N_MODE==0x01); # force 1n
  0b1,                      (SYS.ATTR_MSS_MRW_DRAM_2N_MODE==0x00) && (MCS.ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET==0x02); # use auto vpd val -> auto vpd val = 2n
  0b0,                      (SYS.ATTR_MSS_MRW_DRAM_2N_MODE==0x00) && (MCS.ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET==0x01); # use auto vpd val -> auto vpd val = 1n
}

ispy MCP.PORT0.SRQ.MBA_RRQ0Q_CFG_RRQ_ACT_NUM_READS_PENDING [when=S] {
  spyv;
  0b1000;
}

ispy MCP.PORT0.SRQ.MBA_WRQ0Q_CFG_WRQ_ACT_NUM_WRITES_PENDING [when=S] {
  spyv;
  0b1000;
}


# Epsilon Settings per Power Bus Spreadsheet

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_JITTER_EPSILON [when=S] {
  spyv;
  0x1;
}

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_LOCAL_NODE_EPSILON [when=S] {
  spyv;
  # tier 0
  def_MC_EPSILON_CFG_T0;
}

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_NEAR_NODAL_EPSILON [when=S] {
  spyv;
  # tier 1
  def_MC_EPSILON_CFG_T1;
}

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_REMOTE_NODAL_EPSILON [when=S] {
  spyv;
  # tier 2
  def_MC_EPSILON_CFG_T2;
}

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_GROUP_EPSILON [when=S] {
  spyv;
  # tier 1
  def_MC_EPSILON_CFG_T1;
}

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCEPSQ_VECTOR_GROUP_EPSILON [when=S] {
  spyv;
  # tier 2
  def_MC_EPSILON_CFG_T2;
}


##################
# ASYNC SETTINGS
##################

# DD1
#    ASYNC DIALS LIST
#         L  = MBSECCQ_val_to_data_delay
#         D  = MBSECCQ_nest_val_to_data_delay
#         dn = MBSECCQ_delay_nonbypass
#         h  = MBSECCQ_delay_valid_1x
#    SETTINGS TABLE
#         Keep the stable default values we've been running for DD1
#              L  = 3
#              D  = 0
#              dn = 0 (0ff)
#              h  = 0 (0ff)
#         For performance testing put tuned 2400 settings in risk level 100
#              L  = 5
#              D  = 1
#              dn = 0 (0ff)
#              h  = 0 (0ff)
# DD2
#    ASYNC DIALS LIST
#         L  = MBSECCQ_val_to_data_delay
#         T  = MBSECCQ_bypass_tenure_3 (NEW FOR DD2)
#         D  = MBSECCQ_nest_val_to_data_delay
#         dn = MBSECCQ_delay_nonbypass
#         h  = MBSECCQ_delay_valid_1x
#    SETTINGS TABLE
#         Optimized For   | L T      D dn    h       | mfreq, assume nfreq 2GHz | m/n min   m/n max
#         -----------------------------------------------------------------------------------------
#         sync            | 5 2(off) 0 1(on) 0(off)  |                          |
#         1866 m : 2000 n | 5 2(off) 2 1(on) 0(off)  | 1.818 < mfreq < 2.000    |  909       963
#         1:1 async ratio | 5 3(on)  2 1(on) 0(off)  | 1.818 < mfreq < 2.286    |  963      1038
#         2133 m : 2000 n | 5 2(off) 0 1(on) 0.5(on) | 2.000 < mfreq < 2.167    | 1038      1084
#         (Gap filler)    | 5 3(on)  2 1(on) 0(off)  | 1.818 < mfreq < 2.286    | 1084      1143
#         2400 m : 2000 n | 5 3(on)  0 1(on) 0(off)  | 2.286 < mfreq < 2.667    | 1143      1250
#         2667 m : 2000 n | 6 3(on)  1 1(on) 0(off)  | 2.500 < mfreq < 2.769    | 1250      1385


# helpful expressions
define def_mn_freq_ratio = (1000 * MCBIST.ATTR_MSS_FREQ) / SYS.ATTR_FREQ_PB_MHZ;
define def_perf_tune_case = (MCBIST.ATTR_MSS_FREQ==2400) && (SYS.ATTR_FREQ_PB_MHZ==2000) && (SYS.ATTR_RISK_LEVEL>0);


# DD1

# "L" field
ispy MCP.PORT0.ECC64.SCOM.MBSECCQ_VAL_TO_DATA_DELAY [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD1_SPY_NAMES] {
  spyv, expr;
  3,      (def_perf_tune_case==0); # untuned
  5,      (def_perf_tune_case==1); # tuned
}

# "D" field
ispy MCP.PORT0.ECC64.SCOM.MBSECCQ_NEST_VAL_TO_DATA_DELAY [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD1_SPY_NAMES] {
  spyv, expr;
  0,      (def_perf_tune_case==0); # untuned
  1,      (def_perf_tune_case==1); # tuned
}

# "dn" field
espy MCP.PORT0.ECC64.SCOM.MBSECCQ_DELAY_NONBYPASS [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD1_SPY_NAMES] {
  spyv;
  OFF; # untuned and tuned same value
}

# "h" field
espy MCP.PORT0.ECC64.SCOM.MBSECCQ_DELAY_VALID_1X [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD1_SPY_NAMES] {
  spyv;
  OFF; # untuned and tuned same value
}


# DD2
# (note hierarchies for ECC scoms are slightly different in dd2)

# "L" field
ispy MCP.PORT0.ECC64.ECC.SCOM.MBSECCQ_VAL_TO_DATA_DELAY [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD2_SPY_NAMES] {
  spyv, expr;
  5,      (PROC.ATTR_MC_SYNC_MODE==1);                                                              # sync
  5,      (PROC.ATTR_MC_SYNC_MODE==0) &&                                (def_mn_freq_ratio < 1250); # async 2400m/2000n and below
  6,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1250);                               # async 2666m/2000n
}

# "T" field (new for DD2)
espy MCP.PORT0.ECC64.ECC.SCOM.MBSECCQ_BYPASS_TENURE_3 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv, expr;
  OFF,    (PROC.ATTR_MC_SYNC_MODE==1);                                                              # sync
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0)                                && (def_mn_freq_ratio <  963); # async 1866m/2000n
  ON,     (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >=  963) && (def_mn_freq_ratio < 1038); # async 1:1 optimized
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1038) && (def_mn_freq_ratio < 1084); # async 2133m/2000n
  ON,     (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1084) && (def_mn_freq_ratio < 1143); # async gap filler
  ON,     (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1143) && (def_mn_freq_ratio < 1250); # async 2400m/2000n
  ON,     (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1250) && (def_mn_freq_ratio < 1385); # async 2666m/2000n
}

# "D" field
ispy MCP.PORT0.ECC64.ECC.SCOM.MBSECCQ_NEST_VAL_TO_DATA_DELAY [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD2_SPY_NAMES] {
  spyv, expr;
  0,      (PROC.ATTR_MC_SYNC_MODE==1);                                                              # sync
  2,      (PROC.ATTR_MC_SYNC_MODE==0) &&                                (def_mn_freq_ratio <  963); # async 1866m/2000n
  2,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >=  963) && (def_mn_freq_ratio < 1038); # async 1:1 optimized
  0,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1038) && (def_mn_freq_ratio < 1084); # async 2133m/2000n
  2,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1084) && (def_mn_freq_ratio < 1143); # async gap filler
  0,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1143) && (def_mn_freq_ratio < 1250); # async 2400m/2000n
  1,      (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1250);                               # async 2666m/2000n
}

# "dn" field
espy MCP.PORT0.ECC64.ECC.SCOM.MBSECCQ_DELAY_NONBYPASS [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD2_SPY_NAMES] {
  spyv;
  ON; # same across all frequency settings
}

# "h" field
espy MCP.PORT0.ECC64.ECC.SCOM.MBSECCQ_DELAY_VALID_1X [when=S && ATTR_CHIP_EC_FEATURE_P9N_DD2_SPY_NAMES] {
  spyv, expr;
  OFF,    (PROC.ATTR_MC_SYNC_MODE==1);                                                              # sync
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) &&                                (def_mn_freq_ratio <  963); # async 1866m/2000n
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >=  963) && (def_mn_freq_ratio < 1038); # async 1:1 optimized
  ON,     (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1038) && (def_mn_freq_ratio < 1084); # async 2133m/2000n
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1084) && (def_mn_freq_ratio < 1143); # async gap filler
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1143) && (def_mn_freq_ratio < 1250); # async 2400m/2000n
  OFF,    (PROC.ATTR_MC_SYNC_MODE==0) && (def_mn_freq_ratio >= 1250);                               # async 2666m/2000n
}

############################
# DD2 REFRESH BLOCK SETTINGS
############################
# OVERVIEW
#      Intention is to keep queues from filling up with commands that we
#      wouldn't be able to service anyway due because they are being refreshed
#      and starving out commands to another rank not being refreshed that could
#      have been executed.
#      If a portion of the command address matches the address range being
#      refreshed, then the command will be blocked from getting into the queue.
#      A hash of three rank bits are used to do the address matching and
#      blocking. Which 3 rank bits are used for hash is configureable.
# RULES FOR BEST USE/PERFORMANCE
#      1) Refresh block should not be enabled if only 1 rank. No benefit in
#         blocking traffic to save room for another rank if there is no other
#         rank.
#      2) Not worth it to choose a mode that will block extra ranks than the
#         rank being refreshed. Obvious case is if more than 8 ranks exist
#         because by matching on just 3 bits, you'll inevitably block
#         additional unnecessary ranks. Essentially all existing rank bits
#         must be covered by 3 bit hash. If bits exist that can't all be
#         covered by hash, then not worth enabling feature.
# DIALS
#      (Enable bits) MCPERF2_ENABLE_REFRESH_BLOCK_SQ, MCPERF2_ENABLE_REFRESH_BLOCK_NSQ
#           If enabled, commands will be blocked from getting into queues if their address bits
#      (Mode select) MCPERF2_REFRESH_BLOCK_CONFIG
#           CONFIG  | HASH BITS  | DESCRIPTION
#           (0) 000 | s0, s1, s2 | Single slot, 1 mrank up to 8-high stack
#           (1) 001 | m2, s1, s2 | Single-slot, 2 mrank, up to 4-high stack
#           (2) 010 |  d, s1, s2 | Dual-slot, 1 mrank/slot, up to 4-high stack
#           (3) 011 |  d, m2, s2 | Dual-slot, 2 mrank/slot, up to 2-high stack
#           (4) 100 |  d, m1, m2 | Dual-slot, 4 mrank/slot
#           This field is DON'T CARE if not enabled (helps for simlplification)
# TABLE FOR IDEAL CONFIGS
#       # of     # of     # of  | # of  | CONFIGS | SIMPLIFIED |
#      d-bits   m-bits   s-bits | ranks | ALLOWED | CONFIG     | NOTES
#      -------------------------------------------------------------------
#        0        0        0    |   1   | DISABLE | 0          | 1 rank only
#        0        0        1    |   2   | 0,1,2,3 | 0          |
#        0        0        2    |   4   | 0,1,2   | 0          |
#        0        0        3    |   8   | 0       | 0          |
#        0        1        0    |   2   | 1,3,4   | 1          |
#        0        1        1    |   4   | 1       | 1          |
#        0        1        2    |   8   | 1       | 1          |
#        0        1        3    |  16   | DISABLE | 1          | >8 ranks
#        0        2        0    |   4   | 4       | 4          |
#        0        2        1    |   8   | DISABLE | 4          | no exact match
#        0        2        2    |  16   | DISABLE | 4          | >8 ranks
#        0        2        3    |  32   | DISABLE | 4          | >8 ranks
#        1        0        0    |   2   | 2,3,4   | 2          |
#        1        0        1    |   4   | 2,3     | 2          |
#        1        0        2    |   8   | 2       | 2          |
#        1        0        3    |  16   | DISABLE | 2          | >8 ranks
#        1        1        0    |   4   | 3,4     | 3          |
#        1        1        1    |   8   | 3       | 3          |
#        1        1        2    |  16   | DISABLE | 3          | >8 ranks
#        1        1        3    |  32   | DISABLE | 3          | >8 ranks
#        1        2        0    |   8   | 4       | 4          |
#        1        2        1    |  16   | DISABLE | 4          | >8 ranks
#        1        2        2    |  32   | DISABLE | 4          | >8 ranks
#        1        2        3    |  64   | DISABLE | 4          | >8 ranks
# SIMPLIFIED CONFIGS
#      CHOOSING TO ENABLE
#           ENABLE | CONDITION
#             OFF  | if total number of ranks = 1
#             OFF  | if total number of ranks > 8
#             OFF  | if it's the one 8 rank case that doesn't match exact
#                  |         (0 d-bits, 2 m-bits, 1 s-bit)
#             ON   | Else
#      CHOOSING CONFIG VALUE
#            # of     # of  | SIMPLIFIED
#           d-bits   m-bits | CONFIG
#           ----------------------------
#             0        0    | 0
#             0        1    | 1
#             0        2    | 4
#             1        0    | 2
#             1        1    | 3
#             1        2    | 4

# def_NUM_RANKS

define def_is_dual_slot = (MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][0]>0)
                       && (MCS.ATTR_EFF_NUM_RANKS_PER_DIMM[def_PORT_INDEX][1]>0);

# Variable to indicate special 8 rank case we want refresh block disabled
# Note: 4 master ranks == 2 m-bits; height of 2 == 2 slave ranks == 1 s-bit
define def_refblock_off_special_case = (def_is_dual_slot==0) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==4) && (def_SLOT0_DRAM_STACK_HEIGHT==2);

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_ENABLE_REFRESH_BLOCK_SQ [when=S] {
  spyv, expr;
  OFF,     (def_NUM_RANKS==1);
  OFF,     (def_NUM_RANKS>8);
  OFF,     (def_refblock_off_special_case==1);
  ON,      (def_NUM_RANKS>1) && (def_NUM_RANKS<=8) && (def_refblock_off_special_case==0);
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_ENABLE_REFRESH_BLOCK_NSQ [when=S] {
  spyv, expr;
  OFF,     (def_NUM_RANKS==1);
  OFF,     (def_NUM_RANKS>8);
  OFF,     (def_refblock_off_special_case==1);
  ON,      (def_NUM_RANKS>1) && (def_NUM_RANKS<=8) && (def_refblock_off_special_case==0);
}


ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_REFRESH_BLOCK_CONFIG [when=S] {
  spyv, expr;
  0b000,     (def_is_dual_slot==0) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==1); # 0 d-bit, 0-m-bits
  0b001,     (def_is_dual_slot==0) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==2); # 0 d-bit, 1-m-bits
  0b100,     (def_is_dual_slot==0) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==4); # 0 d-bit, 2-m-bits
  0b010,     (def_is_dual_slot==1) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==1); # 1 d-bit, 0-m-bits
  0b011,     (def_is_dual_slot==1) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==2); # 1 d-bit, 1-m-bits
  0b100,     (def_is_dual_slot==1) && (MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[def_PORT_INDEX][0]==4); # 1 d-bit, 2-m-bits
}

####################################################
# DD1 WORKAROUNDS
####################################################

# Force clock enable high DD1 Periodics Issue

espy  MCP.PORT0.SRQ.MBA_FARB0Q_CFG_OE_ALWAYS_ON [when=S && ATTR_CHIP_EC_FEATURE_HW384794]{
  spyv;
  ON;
}

# HW366164 - SRQ Fullness Control

ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_SQ_LFSR_CNTL [when=S] { # still applies to dd2
  spyv;
  0b0100;
}

# Number of RMW buffers available at 28
# DD1 and DD2
ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_NUM_RMW_BUF [when=S] {
  spyv;
  0b11100;
}

# All rctrl ops through tag FIFO (bit 0)
# Serialize CMDLIST pf drop through rctrl (bit 1)
ispy  MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_RCTRL_CONFIG [when=S && ATTR_CHIP_EC_FEATURE_HW375732] {
  spyv;
  0b110;
}

# Max 24 64-byte read buffers (HW375534)
ispy  MCP.PORT0.SRQ.MBA_RRQ0Q_CFG_RDBUFF_CAPACITY_LIMIT [when=S && ATTR_CHIP_EC_FEATURE_HW375534] {
  spyv;
  0b011000;
}

# AMO Caching disabled
ispy MC01.PORT0.ATCL.CL.CLSCOM.MCAMOC_WRTO_AMO_COLLISION_RULES [when=S] {
  spyv, expr;
  0b0000000000000000000000000,     (ATTR_CHIP_EC_FEATURE_HW401780==1); # DD1
  0b1100111111111111111111111,     (ATTR_CHIP_EC_FEATURE_HW401780!=1); # DD2
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF3_AMO_LIMIT_SEL [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  0x8;
}

# Noise Window DIsable (HW406577)
ispy MCP.PORT0.ECC64.SCOM.MBSECCQ_ENABLE_UE_NOISE_WINDOW [when=S && ATTR_CHIP_EC_FEATURE_HW406577] {
  spyv;
  0b0;
}

##################
# DD2 NEW SETTINGS
##################

ispy MCP.PORT0.SRQ.MBA_FARB0Q_CFG_OPT_RD_SIZE [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  0b011;
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCAMOC_AMO_SIZE_SELECT [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  128B_RW_64B_DATA;
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF0_AMO_LIMIT [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  0b100000;
}

espy MCP.PORT0.WRITE.NEW_WRITE_64B_MODE [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  ON;
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCAMOC_FORCE_PF_DROP0 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  OFF;
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_PF_DROP_VALUE0 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  1;
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_PF_DROP_VALUE1 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  3;
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_PF_DROP_VALUE2 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  5;
}

ispy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_PF_DROP_VALUE3 [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  7;
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF2_ENABLE_REFRESH_BLOCK_DISP [when=S && ATTR_CHIP_EC_FEATURE_NEW_MC_DD2_SETTINGS] {
  spyv;
  OFF;
}

#################
# DD2 WORKAROUNDS
#################

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF3_DISABLE_WRTO_IG [when=S && ATTR_CHIP_EC_FEATURE_HW401131] {
  spyv;
  ON;
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF3_ENABLE_AMO_MSI_RMW_ONLY [when=S && ATTR_CHIP_EC_FEATURE_HW399466] {
  spyv;
  ON;
}

espy MC01.PORT0.ATCL.CL.CLSCOM.MCPERF3_ENABLE_CL0 [when=S && ATTR_CHIP_EC_FEATURE_HW355538] {
  spyv;
  ON;
}

