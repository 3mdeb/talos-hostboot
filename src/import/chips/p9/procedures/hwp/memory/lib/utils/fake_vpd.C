/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/memory/lib/utils/fake_vpd.C $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2017                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

///
/// @file fake_vpd.C
/// @brief A tool to return fake (fixed) system VPD for testing, development
///
// *HWP HWP Owner: Brian Silver <bsilver@us.ibm.com>
// *HWP HWP Backup: Andre Marin <aamarin@us.ibm.com>
// *HWP Team: Memory
// *HWP Level: 2
// *HWP Consumed by: HB:FSP
#include <mss.H>
#include <lib/utils/fake_vpd.H>
#include <lib/shared/mss_const.H>
#include <generic/memory/lib/utils/pos.H>
#include <generic/memory/lib/utils/c_str.H>

#ifndef DOXYGEN

namespace mss
{

// VPD data from template_mt and template_mr - should be VBU/sim settings
constexpr auto raw_mt_size = 255;
static constexpr uint8_t raw_mt_layout_ver0[raw_mt_size] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
    0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x28,
    0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x16, 0x00, 0x01,
    0x31, 0xfd, 0x00, 0x01, 0x31, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static constexpr uint8_t zz_ver1_raw_bin_zz_mt_X0_bin[raw_mt_size] =
{
    0x01, 0x01, 0x86, 0xb8, 0x63, 0xa8, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0xb6, 0xdb, 0x6d, 0xb6,
    0xdb, 0x6d, 0xb6, 0xd0, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xd0,
    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
    0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0d, 0x0d, 0x00, 0x01, 0x17, 0x44, 0x00, 0x01, 0x17, 0x44,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
};

constexpr auto raw_mr_size = 255;
static constexpr uint8_t raw_mr_layout_ver0[raw_mr_size] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x01, 0x01, 0x01, 0x01, 0x03, 0x08, 0x03, 0x06,
    0x03, 0x09, 0x04, 0x04, 0x00, 0x01, 0x01, 0x00, 0x04, 0x02, 0x03, 0x00, 0x06, 0x0a, 0x02, 0x01,
    0x09, 0x09, 0x03, 0x01, 0x05, 0x07, 0x03, 0x05, 0x03, 0x03, 0x0a, 0x06, 0x08, 0x05, 0x09, 0x08,
    0x09, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x67, 0x64, 0x66, 0x6b, 0x66, 0x66, 0x68, 0x6b,
    0x0b, 0x03, 0x0b, 0x0a, 0x09, 0x0d, 0x0a, 0x0b, 0x09, 0x04, 0x15, 0x14, 0x00, 0x00, 0x25, 0x22,
    0x00, 0x00, 0x1b, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x11, 0x00, 0x00, 0x14, 0x0e,
    0x00, 0x00, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// The CKE blob has a header on it, and we want to return a pointer past that. However, to
// make creating this file easier we take the entire blob (header included)
// Note:: ZZ (and hence Monza?) CKE mapping is the same for VBU - so only one mapping needed
constexpr auto raw_ck_size = 136;
constexpr auto raw_ck_header = 4;

static constexpr uint8_t raw_ck[raw_ck_size] =
{
    0x01, 0x08, 0x10, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

constexpr auto raw_dq_size = 160;
static constexpr uint8_t raw_dq[raw_dq_size] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// ZZ data Just In Case. Note ZZ maps DQ's different for each MCS (or has a map for each in
// any event.) This also allows Louie to test sim (vbu VPD) and ! sim (ZZ VPD)
static constexpr uint8_t zz_dq[MCS_PER_MC * MC_PER_MODULE][raw_dq_size] =
{
    // Port with relative position of 0
    {
        0x01, 0x00, 0x02, 0x03, 0x05, 0x04, 0x07, 0x06, 0x08, 0x09, 0x0a, 0x0b, 0x0d, 0x0c, 0x0f, 0x0e,
        0x19, 0x18, 0x1a, 0x1b, 0x1d, 0x1c, 0x1f, 0x1e, 0x41, 0x42, 0x43, 0x40, 0x46, 0x47, 0x45, 0x44,
        0x33, 0x32, 0x30, 0x31, 0x36, 0x37, 0x35, 0x34, 0x29, 0x28, 0x2a, 0x2b, 0x2d, 0x2c, 0x2e, 0x2f,
        0x12, 0x13, 0x11, 0x10, 0x17, 0x16, 0x14, 0x15, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x38, 0x39, 0x3b, 0x3a, 0x3c, 0x3d, 0x3f, 0x3e, 0x40, 0x42, 0x43, 0x41, 0x44, 0x47, 0x45, 0x46,
        0x1a, 0x19, 0x1b, 0x18, 0x1e, 0x1c, 0x1d, 0x1f, 0x00, 0x03, 0x02, 0x01, 0x04, 0x06, 0x05, 0x07,
        0x09, 0x08, 0x0b, 0x0a, 0x0c, 0x0f, 0x0d, 0x0e, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x31, 0x30, 0x32, 0x33, 0x35, 0x34, 0x36, 0x37,
        0x2b, 0x2a, 0x28, 0x29, 0x2f, 0x2e, 0x2d, 0x2c, 0x12, 0x11, 0x13, 0x10, 0x14, 0x15, 0x16, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 1
    {
        0x11, 0x10, 0x12, 0x13, 0x15, 0x14, 0x16, 0x17, 0x0b, 0x0a, 0x08, 0x09, 0x0f, 0x0e, 0x0d, 0x0c,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x00, 0x01, 0x03, 0x02, 0x04, 0x05, 0x07, 0x06,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x00, 0x01, 0x03, 0x02, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0f, 0x0e,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2d, 0x2c, 0x2e, 0x2f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 2
    {
        0x19, 0x18, 0x1a, 0x1b, 0x1d, 0x1c, 0x1e, 0x1f, 0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15,
        0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x41, 0x43, 0x40, 0x42, 0x47, 0x44, 0x45, 0x46, 0x3a, 0x38, 0x3b, 0x39, 0x3e, 0x3c, 0x3d, 0x3f,
        0x29, 0x2a, 0x28, 0x2b, 0x2e, 0x2c, 0x2d, 0x2f, 0x20, 0x21, 0x22, 0x23, 0x25, 0x24, 0x26, 0x27,
        0x32, 0x33, 0x30, 0x31, 0x36, 0x37, 0x34, 0x35, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x15, 0x14, 0x18, 0x19, 0x1b, 0x1a, 0x1c, 0x1d, 0x1f, 0x1e,
        0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0f, 0x0e, 0x42, 0x43, 0x41, 0x40, 0x47, 0x46, 0x44, 0x45,
        0x32, 0x33, 0x30, 0x31, 0x37, 0x36, 0x35, 0x34, 0x02, 0x03, 0x01, 0x00, 0x06, 0x07, 0x05, 0x04,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x38, 0x3a, 0x3b, 0x39, 0x3e, 0x3c, 0x3f, 0x3d,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 3
    {
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x41, 0x42, 0x43, 0x40, 0x45, 0x44, 0x47, 0x46,
        0x00, 0x02, 0x01, 0x03, 0x04, 0x06, 0x05, 0x07, 0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0e, 0x0f,
        0x39, 0x38, 0x3a, 0x3b, 0x3c, 0x3d, 0x3f, 0x3e, 0x2a, 0x2b, 0x29, 0x28, 0x2f, 0x2e, 0x2d, 0x2c,
        0x30, 0x31, 0x33, 0x32, 0x35, 0x34, 0x36, 0x37, 0x23, 0x22, 0x20, 0x21, 0x27, 0x24, 0x26, 0x25,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x17, 0x16, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x19, 0x18, 0x1b, 0x1a, 0x1f, 0x1d, 0x1c, 0x1e, 0x23, 0x22, 0x21, 0x20, 0x24, 0x25, 0x26, 0x27,
        0x08, 0x09, 0x0b, 0x0a, 0x0d, 0x0c, 0x0e, 0x0f, 0x12, 0x13, 0x11, 0x10, 0x17, 0x16, 0x14, 0x15,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3d, 0x3c, 0x3e, 0x3f, 0x43, 0x42, 0x40, 0x41, 0x47, 0x46, 0x45, 0x44,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    }
};

///
/// @brief VPD helper function that imitates getVPD behavior
/// @tparam N size of the input array
/// @param[in] i_raw_vpd array of VPD data
/// @param[in,out] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of data from the DIMM - raw
/// @note passing nullptr for o_blob will return the size of the keyword
///
template< size_t N >
void vpd_helper( const uint8_t (&i_raw_vpd)[N],
                 fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                 uint8_t* o_blob)
{
    io_vpd_info.iv_size = sizeof( i_raw_vpd );

    if( o_blob != nullptr )
    {
        memcpy( o_blob, i_raw_vpd, io_vpd_info.iv_size );
    }

    return;
}

///
/// @brief Helper function to retrieve MT raw data
/// @param[in] i_target a valid fapi2 target
/// @param[in] i_version_layout version layout number
/// @param[in,out] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of raw data from the vpd
/// @note passing nullptr for o_blob will return the size of the keyword
///
void mt_helper( const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                const uint64_t i_version_layout,
                fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                uint8_t* o_blob )
{
    switch(i_version_layout)
    {
        case 0:
            vpd_helper(raw_mt_layout_ver0, io_vpd_info, o_blob);
            break;

        case 1:
            vpd_helper(zz_ver1_raw_bin_zz_mt_X0_bin, io_vpd_info, o_blob);
            break;

        default:
            FAPI_ERR("Invalid layout version layout received %d for %s", i_version_layout, mss::c_str(i_target));
            fapi2::Assert(false);
            break;
    };

    return;
}

///
/// @brief Helper function to retrieve MR raw data
/// @param[in] i_target a valid fapi2 target
/// @param[in] i_version_layout version layout number
/// @param[in,out] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of raw data from the vpd
/// @note passing nullptr for o_blob will return the size of the keyword
///
void mr_helper( const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                const uint64_t i_version_layout,
                fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                uint8_t* o_blob )
{
    switch(i_version_layout)
    {
        case 0:
            vpd_helper(raw_mr_layout_ver0, io_vpd_info, o_blob);
            break;

        default:
            FAPI_ERR("Invalid layout version layout received %d for %s", i_version_layout, mss::c_str(i_target));
            fapi2::Assert(false);
            break;
    };

    return;
}

///
/// @brief Helper function to retrieve CK raw data
/// @param[in] i_target a valid fapi2 target
/// @param[in,out] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of raw data from the vpd
/// @note passing nullptr for o_blob will return the size of the keyword
///
static void ck_helper( const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                       fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                       uint8_t* o_blob )
{
    io_vpd_info.iv_size = raw_ck_size - raw_ck_header;

    if (o_blob != nullptr)
    {
        memcpy(o_blob, raw_ck + raw_ck_header, io_vpd_info.iv_size);
    }
}

///
/// @brief Helper function to retrieve DQ raw data
/// @param[in] i_target a valid fapi2 target
/// @param[in,out] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of raw data from the vpd
/// @note passing nullptr for o_blob will return the size of the keyword
///
static fapi2::ReturnCode dq_helper( const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                                    fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                                    uint8_t* o_blob )
{
    io_vpd_info.iv_size = raw_dq_size;

    if (o_blob != nullptr)
    {
        uint8_t l_sim = 0;
        FAPI_TRY( is_simulation(l_sim) );

        // If we're in sim, we return the DQ map of the VBU (raw) DQ map - 1-1 more or less
        // If we're not in sim, we return the DQ map which corresponds with our MCS relative
        // postion.
        const uint8_t* blob = l_sim ? raw_dq : zz_dq[mss::relative_pos<fapi2::TARGET_TYPE_PROC_CHIP>(i_target)];
        memcpy(o_blob, blob, io_vpd_info.iv_size);
    }

    return fapi2::FAPI2_RC_SUCCESS;

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Return a blob of memory VPD data associated with the input target
/// @param[in] i_target a valid fapi2 target
/// @param[in] i_version_layout version layout number
/// @param[in] io_vpd_info fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob the blob of raw data from the vpd
/// @return FAPI2_RC_SUCCESS if there's no problem
/// @note passing nullptr for o_blob will return the size of the keyword
///
fapi2::ReturnCode getVPD(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                         const uint64_t i_version_layout,
                         fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                         uint8_t* o_blob)
{
    // We only have one blob for fake_vpd so there's no need to check the rest of the info struct.
    switch (io_vpd_info.iv_vpd_type)
    {
        case fapi2::MemVpdData::MR:
            mr_helper(i_target, i_version_layout, io_vpd_info, o_blob);
            break;

        case fapi2::MemVpdData::MT:
            mt_helper(i_target, i_version_layout, io_vpd_info, o_blob);
            break;

        case fapi2::MemVpdData::CK:
            FAPI_INF("CK isn't layout version dependent for %s", mss::c_str(i_target));
            ck_helper(i_target, io_vpd_info, o_blob);
            break;

        case fapi2::MemVpdData::DQ:
            FAPI_INF("DQ isn't layout version dependent for %s", mss::c_str(i_target));
            FAPI_TRY( dq_helper(i_target, io_vpd_info, o_blob) );
            break;

        case fapi2::MemVpdData::MP:
            FAPI_ERR("No MP? for %s", mss::c_str(i_target));
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
            break;

        default:
            FAPI_ERR("No vpd type %d? for %s", io_vpd_info.iv_vpd_type, mss::c_str(i_target));
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
            break;
    };

    return fapi2::FAPI2_RC_SUCCESS;

fapi_try_exit:
    return fapi2::current_err;
}

} // ns mss

#endif
