/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/memory/lib/utils/fake_vpd.C $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016                             */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

///
/// @file fake_vpd.C
/// @brief A tool to return fake (fixed) system VPD for testing, development
///
// *HWP HWP Owner: Brian Silver <bsilver@us.ibm.com>
// *HWP HWP Backup: Andre Marin <aamarin@us.ibm.com>
// *HWP Team: Memory
// *HWP Level: 2
// *HWP Consumed by: HB:FSP

#include <lib/utils/fake_vpd.H>
#include <lib/shared/mss_const.H>
#include <lib/utils/pos.H>

#ifndef DOXYGEN

namespace mss
{

// VPD data from template_mt and template_mr - should be VBU/sim settings
constexpr auto raw_mt_size = 255;
static constexpr uint8_t raw_mt[raw_mt_size] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
    0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x28,
    0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x16, 0x00, 0x01,
    0x31, 0xfd, 0x00, 0x01, 0x31, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

constexpr auto raw_mr_size = 255;
static constexpr uint8_t raw_mr[raw_mr_size] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x01, 0x01, 0x01, 0x01, 0x03, 0x08, 0x03, 0x06,
    0x03, 0x09, 0x04, 0x04, 0x00, 0x01, 0x01, 0x00, 0x04, 0x02, 0x03, 0x00, 0x06, 0x0a, 0x02, 0x01,
    0x09, 0x09, 0x03, 0x01, 0x05, 0x07, 0x03, 0x05, 0x03, 0x03, 0x0a, 0x06, 0x08, 0x05, 0x09, 0x08,
    0x09, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x67, 0x64, 0x66, 0x6b, 0x66, 0x66, 0x68, 0x6b,
    0x0b, 0x03, 0x0b, 0x0a, 0x09, 0x0d, 0x0a, 0x0b, 0x09, 0x04, 0x15, 0x14, 0x00, 0x00, 0x25, 0x22,
    0x00, 0x00, 0x1b, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x11, 0x00, 0x00, 0x14, 0x0e,
    0x00, 0x00, 0x01, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// The CKE blob has a header on it, and we want to return a pointer past that. Howevre, to
// make creating this file easier we take the entire blob (header included)
// Note:: ZZ (and hence Monza?) CKE mapping is the same for VBU - so only one mapping needed
constexpr auto raw_cke_header = 4;
constexpr auto raw_cke_size = 136;

static constexpr uint8_t raw_cke[raw_cke_size] =
{
    0x01, 0x08, 0x10, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

constexpr auto raw_dq_size = 160;
static constexpr uint8_t raw_dq[raw_dq_size] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// ZZ data Just In Case. Note ZZ maps DQ's different for each MCS (or has a map for each in
// any event.) This also allows Louie to test sim (vbu VPD) and ! sim (ZZ VPD)
static constexpr uint8_t zz_dq[MCS_PER_MC * MC_PER_MODULE][raw_dq_size] =
{
    // Port with relative position of 0
    {
        0x01, 0x00, 0x02, 0x03, 0x05, 0x04, 0x07, 0x06, 0x08, 0x09, 0x0a, 0x0b, 0x0d, 0x0c, 0x0f, 0x0e,
        0x19, 0x18, 0x1a, 0x1b, 0x1d, 0x1c, 0x1f, 0x1e, 0x41, 0x42, 0x43, 0x40, 0x46, 0x47, 0x45, 0x44,
        0x33, 0x32, 0x30, 0x31, 0x36, 0x37, 0x35, 0x34, 0x29, 0x28, 0x2a, 0x2b, 0x2d, 0x2c, 0x2e, 0x2f,
        0x12, 0x13, 0x11, 0x10, 0x17, 0x16, 0x14, 0x15, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x38, 0x39, 0x3b, 0x3a, 0x3c, 0x3d, 0x3f, 0x3e, 0x40, 0x42, 0x43, 0x41, 0x44, 0x47, 0x45, 0x46,
        0x1a, 0x19, 0x1b, 0x18, 0x1e, 0x1c, 0x1d, 0x1f, 0x00, 0x03, 0x02, 0x01, 0x04, 0x06, 0x05, 0x07,
        0x09, 0x08, 0x0b, 0x0a, 0x0c, 0x0f, 0x0d, 0x0e, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x31, 0x30, 0x32, 0x33, 0x35, 0x34, 0x36, 0x37,
        0x2b, 0x2a, 0x28, 0x29, 0x2f, 0x2e, 0x2d, 0x2c, 0x12, 0x11, 0x13, 0x10, 0x14, 0x15, 0x16, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 1
    {
        0x11, 0x10, 0x12, 0x13, 0x15, 0x14, 0x16, 0x17, 0x0b, 0x0a, 0x08, 0x09, 0x0f, 0x0e, 0x0d, 0x0c,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x00, 0x01, 0x03, 0x02, 0x04, 0x05, 0x07, 0x06,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x00, 0x01, 0x03, 0x02, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0f, 0x0e,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2d, 0x2c, 0x2e, 0x2f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 2
    {
        0x19, 0x18, 0x1a, 0x1b, 0x1d, 0x1c, 0x1e, 0x1f, 0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15,
        0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x41, 0x43, 0x40, 0x42, 0x47, 0x44, 0x45, 0x46, 0x3a, 0x38, 0x3b, 0x39, 0x3e, 0x3c, 0x3d, 0x3f,
        0x29, 0x2a, 0x28, 0x2b, 0x2e, 0x2c, 0x2d, 0x2f, 0x20, 0x21, 0x22, 0x23, 0x25, 0x24, 0x26, 0x27,
        0x32, 0x33, 0x30, 0x31, 0x36, 0x37, 0x34, 0x35, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x15, 0x14, 0x18, 0x19, 0x1b, 0x1a, 0x1c, 0x1d, 0x1f, 0x1e,
        0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0f, 0x0e, 0x42, 0x43, 0x41, 0x40, 0x47, 0x46, 0x44, 0x45,
        0x32, 0x33, 0x30, 0x31, 0x37, 0x36, 0x35, 0x34, 0x02, 0x03, 0x01, 0x00, 0x06, 0x07, 0x05, 0x04,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x38, 0x3a, 0x3b, 0x39, 0x3e, 0x3c, 0x3f, 0x3d,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },

    // Port with relative position of 3
    {
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x41, 0x42, 0x43, 0x40, 0x45, 0x44, 0x47, 0x46,
        0x00, 0x02, 0x01, 0x03, 0x04, 0x06, 0x05, 0x07, 0x08, 0x09, 0x0b, 0x0a, 0x0c, 0x0d, 0x0e, 0x0f,
        0x39, 0x38, 0x3a, 0x3b, 0x3c, 0x3d, 0x3f, 0x3e, 0x2a, 0x2b, 0x29, 0x28, 0x2f, 0x2e, 0x2d, 0x2c,
        0x30, 0x31, 0x33, 0x32, 0x35, 0x34, 0x36, 0x37, 0x23, 0x22, 0x20, 0x21, 0x27, 0x24, 0x26, 0x25,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x17, 0x16, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x19, 0x18, 0x1b, 0x1a, 0x1f, 0x1d, 0x1c, 0x1e, 0x23, 0x22, 0x21, 0x20, 0x24, 0x25, 0x26, 0x27,
        0x08, 0x09, 0x0b, 0x0a, 0x0d, 0x0c, 0x0e, 0x0f, 0x12, 0x13, 0x11, 0x10, 0x17, 0x16, 0x14, 0x15,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3d, 0x3c, 0x3e, 0x3f, 0x43, 0x42, 0x40, 0x41, 0x47, 0x46, 0x45, 0x44,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    }
};

///
/// @brief Return a blob of memory VPD data associated with the input target
/// @param[in] i_target     a valid fapi2 target
/// @param[in] io_vpd_info  fapi2::VPDInfo class that specifies which piece of data to return
/// @param[out] o_blob      the blob of raw data from the vpd
/// @return FAPI2_RC_SUCCESS if there's no problem
/// @note passing nullptr for o_blob will return the size of the keyword
///
/// Example:
/// fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS> vpdInfo(MR_keyword);
/// vpdInfo.iv_freq = 2667;
///
/// uint8_t * blob = NULL;
///
/// FAPI_TRY(getVPD( mcs, vpdInfo, blob ));
/// blob = static_cast<uint8_t *>(malloc(vpdInfo.iv_size));
/// FAPI_TRY(getVPD( mcs, vpdInfo, blob ));
/// blob now contains the VPD data for the MCS.
///
fapi2::ReturnCode getVPD(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
                         fapi2::VPDInfo<fapi2::TARGET_TYPE_MCS>& io_vpd_info,
                         uint8_t* o_blob)
{
    // We only have one blob for fake_vpd so there's no need to check the rest of the info struct.
    switch (io_vpd_info.iv_vpd_type)
    {
        case fapi2::MemVpdData::MR:
            io_vpd_info.iv_size = raw_mr_size;

            if (o_blob != nullptr)
            {
                memcpy(o_blob, raw_mr, raw_mr_size);
            }

            break;

        case fapi2::MemVpdData::MT:
            io_vpd_info.iv_size = raw_mt_size;

            if (o_blob != nullptr)
            {
                memcpy(o_blob, raw_mt, raw_mt_size);
            }

            break;

        case fapi2::MemVpdData::CK:
            io_vpd_info.iv_size = raw_cke_size - raw_cke_header;

            if (o_blob != nullptr)
            {
                memcpy(o_blob, raw_cke + raw_cke_header, io_vpd_info.iv_size);
            }

            break;

        case fapi2::MemVpdData::DQ:
            {
                io_vpd_info.iv_size = raw_dq_size;

                if (o_blob != nullptr)
                {
                    uint8_t is_sim = 0;
                    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_SIMULATION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), is_sim) );

                    // If we're in sim, we return the DQ map of the VBU (raw) DQ map - 1-1 more or less
                    // Ifwe're not in sim, we return the DQ map which corresponds with our MCS relative
                    // postion.
                    const uint8_t* blob = is_sim ? raw_dq : zz_dq[mss::relative_pos<fapi2::TARGET_TYPE_PROC_CHIP>(i_target)];
                    memcpy(o_blob, blob, io_vpd_info.iv_size);
                }
            }
            break;

        case fapi2::MemVpdData::MP:
            FAPI_ERR("No MP?");
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
            break;

        default:
            FAPI_ERR("No vpd type %d?", io_vpd_info.iv_vpd_type);
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
            break;
    };

    return fapi2::FAPI2_RC_SUCCESS;

fapi_try_exit:
    return fapi2::current_err;

}

} // ns mss

#endif
