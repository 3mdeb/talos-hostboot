/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/memory/lib/mss_attribute_accessors.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2017                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_attribute_accessors.H
#ifndef MSS_ATTR_ACCESS_H_
#define MSS_ATTR_ACCESS_H_

#include <fapi2.H>
#include <lib/mss_utils.H>
#include <lib/mss_attribute_accessors_manual.H>



namespace mss
{
///
/// @brief ATTR_MSS_VOLT_VDDR getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value. Computed in mss_volt
/// C code - in millivolts creator: mss_volt consumer: mss_eff_cnfg, others firmware
/// notes:
/// none
///
inline fapi2::ReturnCode volt_vddr(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VDDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VDDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_VPP getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM VPP Voltage, each voltage rail would need to have a value. Computed in
/// mss_volt C code - in millivolts. 0V - DDR3, 2.5V - DDR4 creator: mss_volt
/// consumer: mss_eff_cnfg, others firmware notes:
/// none
///
inline fapi2::ReturnCode volt_vpp(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VPP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VPP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_OVERRIDE getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  FOR LAB USE ONLY: Frequency override of this memory channel in MT/s comprising
/// of up to three DIMMs. Set by config file or an attribute writing program.
/// Consumed by mss_freq. The default of AUTO means mss_freq will find the best
/// frequencies given the DIMMs plugged in and other rules. Otherwise, this is the
/// system
/// frequency.
///
inline fapi2::ReturnCode freq_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second), comprising
/// of three DIMMs. Computed in mss_freq creator: mss_freq consumer: mss_eff_cnfg,
/// others firmware notes:
/// none
///
inline fapi2::ReturnCode freq(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_BIAS_PERCENTAGE getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Percentage to increase/decrease MEM frequency - two's complement number.
/// Measured in 100's. So the value of 100 is one percent increase. This frequency
/// change comes from changing multipliers and dividers to get the desired
/// frequency. The supported frequencies come from Tim Diemoz. Creator: platform set
/// this to 0. Users can set this to a valid value. VALID Values: (TBD % to TBD %)
/// (Tuleta) (TBD % to TBD %) (Glacier) Set by: PLL settings written by Dave
/// Cadigan
///
inline fapi2::ReturnCode freq_bias_percentage(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_BIAS_PERCENTAGE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_BIAS_PERCENTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_PORT_POS_OF_FAIL_THROTTLE getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the fapi position of the port that failed to calculate memory throttles
/// given the passed in watt target and or
/// utilization
///
inline fapi2::ReturnCode mem_port_fail_throttle(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_PORT_POS_OF_FAIL_THROTTLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_PORT_POS_OF_FAIL_THROTTLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]:[31]
/// Reserved for future use COARSE_WR and COARSE_RD will be consumed together to
/// form COARSE_LVL. WRITE_CTR will be run, even if only WRITE_CTR_2D_VREF is
/// enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D to function. Note:
/// LRDIMM steps will only be enabled for LRDIMMs and won't run on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]:[31]
/// Reserved for future use COARSE_WR and COARSE_RD will be consumed together to
/// form COARSE_LVL. WRITE_CTR will be run, even if only WRITE_CTR_2D_VREF is
/// enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D to function. Note:
/// LRDIMM steps will only be enabled for LRDIMMs and won't run on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]:[31]
/// Reserved for future use COARSE_WR and COARSE_RD will be consumed together to
/// form COARSE_LVL. WRITE_CTR will be run, even if only WRITE_CTR_2D_VREF is
/// enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D to function. Note:
/// LRDIMM steps will only be enabled for LRDIMMs and won't run on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_ABORT_ON_ERROR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Whether or not to abort on the first DDR PHY calibration error. Firmware should
/// always have this set to NO. YES can be used in the lab for troubleshooting,
/// screening,
/// etc.
///
inline fapi2::ReturnCode cal_abort_on_error(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_ABORT_ON_ERROR, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_ABORT_ON_ERROR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC0A, F[3,4]RC0B,
/// F[5,6]RC0A, F[5,6]RC0B, F[7,8]RC0A, F[7,8]RC0B, F[9,10]RC0A, F[9,10]RC0B,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC0B, F[1]RC0C, F[1]RC0D, F[1]RC0E, F[1]RC0F. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC0A, F[3,4]RC0B,
/// F[5,6]RC0A, F[5,6]RC0B, F[7,8]RC0A, F[7,8]RC0B, F[9,10]RC0A, F[9,10]RC0B,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC0B, F[1]RC0C, F[1]RC0D, F[1]RC0E, F[1]RC0F. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC0A, F[3,4]RC0B,
/// F[5,6]RC0A, F[5,6]RC0B, F[7,8]RC0A, F[7,8]RC0B, F[9,10]RC0A, F[9,10]RC0B,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC0B, F[1]RC0C, F[1]RC0D, F[1]RC0E, F[1]RC0F. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_OVERRIDE getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible DRAM voltage override. Firmware notes: Default should be NONE
/// (0x00).
///
inline fapi2::ReturnCode volt_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VDDR_OVERIDE_SPD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible VDDR voltage
/// override.
///
inline fapi2::ReturnCode vddr_overide_spd(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VDDR_OVERIDE_SPD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VDDR_OVERIDE_SPD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum number of installed DIMMs per VMEM regulator for all VMEM regulators in
/// the
/// system.
///
inline fapi2::ReturnCode vmem_regulator_max_dimm_count(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VCCD_OVERRIDE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Whether or not to override VCCD. Defaults to
/// no.
///
inline fapi2::ReturnCode vccd_override(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VCCD_OVERRIDE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VCCD_OVERRIDE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_IGNORE_PLUG_RULES getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set to IGNORE if you want to ignore the plug rules. Sometimes this is needed in
/// a partial-good
/// configuration
///
inline fapi2::ReturnCode ignore_plug_rules(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_IGNORE_PLUG_RULES, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_IGNORE_PLUG_RULES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][8];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][8];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][8];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, i_target, l_value) );
    memcpy(o_array, &l_value, 64);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_REORDER_QUEUE_SETTING getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Contains the settings for write/read reorder
/// queue
///
inline fapi2::ReturnCode reorder_queue_setting(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_REORDER_QUEUE_SETTING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_REORDER_QUEUE_SETTING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY RANK_PAIR settings. First uint16 value is for RANK_PAIR0 register
/// value, and second is for RANK_PAIR1. Note that DIMM1 ranks in a dual-drop config
/// will be converted from Centaur canonical number (4,5) to correct PHY settings
/// (2,3). Set this attribute to zero to use default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY RANK_PAIR settings. First uint16 value is for RANK_PAIR0 register
/// value, and second is for RANK_PAIR1. Note that DIMM1 ranks in a dual-drop config
/// will be converted from Centaur canonical number (4,5) to correct PHY settings
/// (2,3). Set this attribute to zero to use default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY RANK_PAIR settings. First uint16 value is for RANK_PAIR0 register
/// value, and second is for RANK_PAIR1. Note that DIMM1 ranks in a dual-drop config
/// will be converted from Centaur canonical number (4,5) to correct PHY settings
/// (2,3). Set this attribute to zero to use default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator
/// cfg_nm_n_per_port Set to below optimum value/ rate. On a per port (MCA) basis
/// Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally
/// protect the system in all supported environmental conditions when OCC is not
/// functional Consumer: thermal_init,
/// initfile
///
inline fapi2::ReturnCode mrw_safemode_mem_throttled_n_commands_per_port(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles
/// to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE
/// = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY =
/// 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits
/// 19-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM
/// = 32-63 Consumers: eff_config_thermal and
/// bulk_pwr_throttles
///
inline fapi2::ReturnCode mrw_thermal_memory_power_limit(uint64_t* o_array)
{
    uint64_t l_value[10];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            l_value) );
    memcpy(o_array, &l_value, 80);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_INTERCEPT getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR
/// and VDDR+VPP power curve for each DIMM Decoded and used to set
/// ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE =
/// bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY =
/// 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits
/// 19-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP
/// power curve = 48-63 Consumers:
/// eff_config_thermal
///
inline fapi2::ReturnCode mrw_pwr_intercept(uint64_t* o_array)
{
    uint64_t l_value[100];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_INTERCEPT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PWR_INTERCEPT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_SLOPE getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and
/// VDDR+VPP power curve for each DIMM Decoded and used to set
/// ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE =
/// bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY =
/// 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits
/// 19-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP
/// power curve = 48-63 Consumers:
/// eff_config_thermal
///
inline fapi2::ReturnCode mrw_pwr_slope(uint64_t* o_array)
{
    uint64_t l_value[100];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_SLOPE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PWR_SLOPE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_REFRESH_RATE_REQUEST getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh
/// register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02
/// us (SINGLE_10_PERCENT_FASTER) 3.51 us
/// (DOUBLE_10_PERCENT_FASTER)
///
inline fapi2::ReturnCode mrw_refresh_rate_request(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_REFRESH_RATE_REQUEST, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_REFRESH_RATE_REQUEST: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at max
/// utilization. Value should be 0 for
/// ISDIMMs
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at
/// idle utilization. Value should be 0 for
/// ISDIMMs
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift_idle(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook for the number of M DRAM clocks. One approach to
/// curbing DRAM power usage is by throttling traffic through a programmable N
/// commands over M
/// window.
///
inline fapi2::ReturnCode mrw_mem_m_dram_clocks(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for maximum dram data bus utilization in centi
/// percent (c%). Used to determine memory throttle values. Max databus utilization
/// on a per port basis Default to
/// 90%
///
inline fapi2::ReturnCode mrw_max_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Option to control MCS prefetch retry threshold, for performance optimization.
/// This attribute controls the number of retries in the prefetch engine. Retry
/// threshold available ranges from 16 to 30. Note: Values outside those ranges will
/// default to 30. In
/// MRW.
///
inline fapi2::ReturnCode mrw_mcs_prefetch_retry_threshold(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings programmed during IPL Used by OCC when exiting
/// idle power-save
/// mode
///
inline fapi2::ReturnCode mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings for IDLE powersave mode Used by OCC when entering
/// idle power-save
/// mode
///
inline fapi2::ReturnCode mrw_idle_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook enablement of the HWP code to adjust the VMEM
/// regulator power limit based on number of installed
/// DIMMs.
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_adj_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full
/// configuration. Units in cW Used for Cumulus Consumed in
/// mss_eff_config_thermal
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_ddr3(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full
/// configuration. Units in cW Consumed in
/// mss_eff_config_thermal
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_ddr4(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for the maximum possible number of dimms that
/// can be installed under any of the VMEM regulators. Consumed in
/// eff_config_thermal to calculate
/// mem_watt_target
///
inline fapi2::ReturnCode mrw_max_number_dimms_possible_per_vmem_regulator(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_AVDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to AVDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_avdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_AVDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_AVDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VCS_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vcs_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VCS_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VCS_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VPP_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vpp_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VPP_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VPP_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VDDR_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDDR. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vddr_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VDDR_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VDDR_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FINE_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec
/// 1716.78C from 07-2016 Page 47 Table
/// 4.9.1
///
inline fapi2::ReturnCode mrw_fine_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FINE_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_FINE_REFRESH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_RANGE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended
/// range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less
/// degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec
/// 1716.78C from 07-2016 page 46
/// 4.8.1
///
inline fapi2::ReturnCode mrw_temp_refresh_range(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_RANGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TEMP_REFRESH_RANGE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  For resetting the phy delay values at the beginning of calling
/// mss_draminit_training. YES means the vaules will be
/// reset.
///
inline fapi2::ReturnCode mrw_reset_delay_before_cal(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PREFETCH_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if prefetching enabled or
/// not.
///
inline fapi2::ReturnCode mrw_prefetch_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PREFETCH_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PREFETCH_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_CLEANER_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if the cleaner of the L4 cache (write modified
/// entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur
/// Workbook.
///
inline fapi2::ReturnCode mrw_cleaner_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_CLEANER_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_CLEANER_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic calibration for all ports: Reading left to
/// right. (DEFAULT: 0xD90C -> Byte 0(11011001), Byte 1(00001100)) For each bit: OFF
/// = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL
/// 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6:
/// PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2:
/// PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7:
/// SPARE
///
inline fapi2::ReturnCode mrw_periodic_memcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic ZQ calibration for all ports: Reading left
/// to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable
/// periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future
/// use
///
inline fapi2::ReturnCode mrw_periodic_zqcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_2N_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal
/// Integrity generated setting (from
/// VPD).
///
inline fapi2::ReturnCode mrw_dram_2n_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_2N_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DRAM_2N_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_SUPPORTED_FREQ getter
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  List of memory frequencies supported by the current
/// system.
///
inline fapi2::ReturnCode mrw_supported_freq(uint32_t* o_array)
{
    uint32_t l_value[4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SUPPORTED_FREQ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_SUPPORTED_FREQ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_WRITE_CRC getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables DRAM Write
/// CRC
///
inline fapi2::ReturnCode mrw_dram_write_crc(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_WRITE_CRC, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DRAM_WRITE_CRC: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used in MR4 A3 Temperature refresh mode Should be defaulted to
/// disable
///
inline fapi2::ReturnCode mrw_temp_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TEMP_REFRESH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MR_0_VERSION_LAYOUT getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mr_0_version_layout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_0_VERSION_LAYOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_0_VERSION_LAYOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_1_VERSION_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mr_1_version_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_1_VERSION_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_1_VERSION_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_2_SIGNATURE_HASH getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mr_2_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_2_SIGNATURE_HASH, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_2_SIGNATURE_HASH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal Integrity. 0x01 = 1N Mode , 0x02 = 2N
/// Mode
///
inline fapi2::ReturnCode vpd_mr_mc_2n_mode_autoset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_TSYS_ADR getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ADR WRClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of
/// clock. Phase Rotator Static Offset value used to determine the Phase of the
/// WrClk with respect to SysClk. For zero delay simulations, or simulations where
/// the delay of the SysClk tree and the WrClk tree are equal, Set this field to
/// 60h
///
inline fapi2::ReturnCode vpd_mr_tsys_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_TSYS_ADR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_TSYS_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_TSYS_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DP16 WrClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of
/// clock. Phase Rotator Static Offset value used to determine the Phase of the
/// WrClk with respect to SysClk. For zero delay simulations, or simulations where
/// the delay of the SysClk tree and the WrClk tree are equal, Set this field to
/// 60h
///
inline fapi2::ReturnCode vpd_mr_tsys_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_TSYS_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_TSYS_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MT_0_VERSION_LAYOUT getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mt_0_version_layout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_0_VERSION_LAYOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_0_VERSION_LAYOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_1_VERSION_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mt_1_version_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_1_VERSION_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_1_VERSION_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_2_SIGNATURE_HASH getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mt_2_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_2_SIGNATURE_HASH, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_2_SIGNATURE_HASH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value int16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. If this is enabled, disable periodic rd_ctr
/// in draminit_mc. Default is
/// 0
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, int16_t& o_value)
{
    int16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value int16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. If this is enabled, disable periodic rd_ctr
/// in draminit_mc. Default is
/// 0
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, int16_t& o_value)
{
    int16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] int16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. If this is enabled, disable periodic rd_ctr
/// in draminit_mc. Default is
/// 0
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, int16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    int16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_DQ_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  [PORT][Dimm DQ PIN] The map from the Dual Inline Memory Module (DIMM) Data (DQ)
/// Pin to the Module Package Data (DQ)
/// Pinout
///
inline fapi2::ReturnCode vpd_dq_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][72];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_DQ_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 72);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_DQ_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_DQ_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  [PORT][Dimm DQ PIN] The map from the Dual Inline Memory Module (DIMM) Data (DQ)
/// Pin to the Module Package Data (DQ)
/// Pinout
///
inline fapi2::ReturnCode vpd_dq_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][72];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_DQ_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 144);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_DQ_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_BAD_DQ_BITMAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for
/// each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored
/// in a special format translated to a DIMM Connector point of view. All of these
/// details are hidden from the user of this
/// attribute.
///
inline fapi2::ReturnCode bad_dq_bitmap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4][10];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BAD_DQ_BITMAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 40);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_BAD_DQ_BITMAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_BAD_DQ_BITMAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for
/// each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored
/// in a special format translated to a DIMM Connector point of view. All of these
/// details are hidden from the user of this
/// attribute.
///
inline fapi2::ReturnCode bad_dq_bitmap(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4][10];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BAD_DQ_BITMAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 80);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_BAD_DQ_BITMAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_BAD_DQ_BITMAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for
/// each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored
/// in a special format translated to a DIMM Connector point of view. All of these
/// details are hidden from the user of this
/// attribute.
///
inline fapi2::ReturnCode bad_dq_bitmap(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4][10];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BAD_DQ_BITMAP, i_target, l_value) );
    memcpy(o_array, &l_value, 160);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_BAD_DQ_BITMAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_FREQ_PROC_REFCLOCK_KHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of the processor refclock in kHz. Provided by the Machine Readable
/// Workbook. This can be overridden to adjust the refclock
/// frequency.
///
inline fapi2::ReturnCode freq_proc_refclock_khz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_PROC_REFCLOCK_KHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_PROC_REFCLOCK_KHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_MEM_REFCLOCK getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of the memory refclock in MHz. Provided by the Machine Readable
/// Workbook. This is read by the set_ref_clock HWP to find out the desired
/// frequency. This can be overridden to adjust the refclock
/// frequency.
///
inline fapi2::ReturnCode freq_mem_refclock(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_MEM_REFCLOCK, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_MEM_REFCLOCK: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MAX_ALLOWED_DIMM_FREQ getter
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5
/// possible values determined by the dimm configuration. For configurations which
/// have mixed rank configurations, the lowest frequency based on ranks of either
/// DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R
/// dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be
/// the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four
/// rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of
/// zero would indicate an unsupported configuration. Note: Do not use this
/// attribute to limit configurations, it is not checked during plug rules. If you
/// have an unsupported configuration, use the value 0 as the maximum
/// freq.
///
inline fapi2::ReturnCode max_allowed_dimm_freq(uint32_t* o_array)
{
    uint32_t l_value[5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MAX_ALLOWED_DIMM_FREQ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 20);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MAX_ALLOWED_DIMM_FREQ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEMVPD_POS getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The position of the MCS target's VPD selector data, relative to the EEPROM that
/// contains its data. The VPD defition supports up to 16 values per EEPROM. For
/// systems with an EEPROM per chip, this value should be equivalent to
/// ATTR_CHIP_UNIT_POS. For systems with a single EEPROM for all chips, the value
/// should follow the physical position in such a way to fit within the 16 available
/// slots.
///
inline fapi2::ReturnCode memvpd_pos(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEMVPD_POS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MEMVPD_POS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_REQUIRED_SYNCH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specify the system policy to enforce synchronous mode between memory and nest.
/// This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run
/// synchronously if the dimm and nest freq matches ALWAYS : Require matching
/// frequencies and deconfigure memory that does not match the nest NEVER : Do not
/// run synchronously, even if the frequencies
/// match
///
inline fapi2::ReturnCode required_synch_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_REQUIRED_SYNCH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_REQUIRED_SYNCH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_IS_SIMULATION getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  env: 1 = Awan/HWSimulator. 0 =
/// Simics/RealHW.
///
inline fapi2::ReturnCode is_simulation(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_SIMULATION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_IS_SIMULATION: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_EXECUTION_PLATFORM getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Which execution platform the HW Procedure is running on Some HWPs (e.g. special
/// wakeup) use different registers for different platforms to avoid arbitration
/// problems when multiple platforms do the same thing
/// concurrently
///
inline fapi2::ReturnCode execution_platform(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXECUTION_PLATFORM, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EXECUTION_PLATFORM: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MNFG_FLAGS getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The manufacturing flags. This is a bitfield. Each bit is a flag and multiple
/// flags can be
/// set
///
inline fapi2::ReturnCode mnfg_flags(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MNFG_FLAGS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MNFG_FLAGS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_RECONFIGURE_LOOP getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used to inidicate if a reconfigure loop is
/// needed
///
inline fapi2::ReturnCode reconfigure_loop(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_RECONFIGURE_LOOP, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_RECONFIGURE_LOOP: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_FREQ_PB_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of a processor's nest mesh clock, in MHz. This is the same for all
/// chips in the system. Provided by the
/// MRW.
///
inline fapi2::ReturnCode freq_pb_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_PB_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_PB_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_A_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of a processor's Abus, in MHz. This is the same for all chips in
/// the system. Provided by the
/// MRW.
///
inline fapi2::ReturnCode freq_a_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_A_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_A_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_X_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of a processor's Xbus mesh clocks, in MHz. This is the same for
/// all chips in the
/// system.
///
inline fapi2::ReturnCode freq_x_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_X_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_X_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_CORE_FLOOR_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest frequency that a core can be set to in MHz. This is the same for all
/// cores in the system. Provided by the MVPD #V and is calculated as the max of the
/// Power Save
/// frequencies.
///
inline fapi2::ReturnCode freq_core_floor_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_CORE_FLOOR_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_CORE_FLOOR_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_CORE_NOMINAL_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The nominal core frequency in MHz. This is the same for all cores in the system.
/// Provided by the #V bucket of module
/// VPD.
///
inline fapi2::ReturnCode freq_core_nominal_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_CORE_NOMINAL_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_CORE_NOMINAL_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_CORE_CEILING_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The maximum core frequency in MHz. This is the same for all cores in the system.
/// Provided by the #V bucket of module VPD and is calculated as the minimum of the
/// turbo
/// frequencies.
///
inline fapi2::ReturnCode freq_core_ceiling_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_CORE_CEILING_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_CORE_CEILING_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PM_SAFE_FREQUENCY_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency (in MHz) to move to if the Power Management function fails. This is
/// the same for all cores in the system. Provided by the
/// MRW.
///
inline fapi2::ReturnCode pm_safe_frequency_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PM_SAFE_FREQUENCY_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PM_SAFE_FREQUENCY_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PM_SAFE_VOLTAGE_MV getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Voltage (in mV) to move to if the Power Management function fails. Provided by
/// the
/// MRW.
///
inline fapi2::ReturnCode pm_safe_voltage_mv(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PM_SAFE_VOLTAGE_MV, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PM_SAFE_VOLTAGE_MV: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_PCIE_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of a processor's PCI-e bus in MHz. This is the same for all PCI-e
/// busses in the system. Provided by the
/// MRW.
///
inline fapi2::ReturnCode freq_pcie_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_PCIE_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_PCIE_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_DD1_SLOW_PCI_REF_CLOCK getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation of PCIE
/// reference clock. On Nimbus DD1 HW, Slow operation is required to achieve Gen4
/// operation. Provided by the
/// MRW.
///
inline fapi2::ReturnCode dd1_slow_pci_ref_clock(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DD1_SLOW_PCI_REF_CLOCK, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_DD1_SLOW_PCI_REF_CLOCK: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_ASYNC_SAFE_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set to force all fabric asynchronous boundary crossings into safe
/// mode.
///
inline fapi2::ReturnCode proc_fabric_async_safe_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_ASYNC_SAFE_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_ASYNC_SAFE_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_A_BUS_WIDTH getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP A bus width. Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_a_bus_width(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_A_BUS_WIDTH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_A_BUS_WIDTH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_X_BUS_WIDTH getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP X bus width. Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_x_bus_width(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_X_BUS_WIDTH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_X_BUS_WIDTH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_CORE_FLOOR_RATIO getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP core floor/nest frequency
/// ratio
///
inline fapi2::ReturnCode proc_fabric_core_floor_ratio(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_CORE_FLOOR_RATIO, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_CORE_FLOOR_RATIO: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_CORE_CEILING_RATIO getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP core celing/nest frequency
/// ratio
///
inline fapi2::ReturnCode proc_fabric_core_ceiling_ratio(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_CORE_CEILING_RATIO, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_CORE_CEILING_RATIO: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_PUMP_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 =
/// default CHIP_IS_GROUP = MODE2 Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_pump_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_PUMP_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_PUMP_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_CCSM_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP topology configuration. 0 = default = 1 or 2 hop topology (PHYP
/// image spans system) Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_ccsm_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_CCSM_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_CCSM_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_SMP_OPTICS_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 = Optics_is_A_bus
/// Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_smp_optics_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_SMP_OPTICS_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_SMP_OPTICS_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_FABRIC_CAPI_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor CAPI attachement protocol mode. 0 = default = no: SMPA CAPI
/// attachement 1 = yes: SMPA CAPI attachement Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_fabric_capi_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_FABRIC_CAPI_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_FABRIC_CAPI_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_GB_PERCENTAGE getter
/// @param[out] int8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Guardband percentage to apply to baseline epsilon calculations Set by
/// p9_fbc_eff_config.
///
inline fapi2::ReturnCode proc_eps_gb_percentage(int8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_GB_PERCENTAGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_GB_PERCENTAGE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_TABLE_TYPE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Processor epsilon table type. Used to calculate the processor nest epsilon
/// register values. Provided by the
/// MRW.
///
inline fapi2::ReturnCode proc_eps_table_type(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_TABLE_TYPE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_TABLE_TYPE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_READ_CYCLES_T0 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Calculated read tier0 epsilon protection
/// count.
///
inline fapi2::ReturnCode proc_eps_read_cycles_t0(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_READ_CYCLES_T0, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_READ_CYCLES_T0: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_READ_CYCLES_T1 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Calculated read tier1 epsilon protection
/// count.
///
inline fapi2::ReturnCode proc_eps_read_cycles_t1(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_READ_CYCLES_T1, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_READ_CYCLES_T1: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_READ_CYCLES_T2 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Calculated read tier2 epsilon protection
/// count.
///
inline fapi2::ReturnCode proc_eps_read_cycles_t2(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_READ_CYCLES_T2, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_READ_CYCLES_T2: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_WRITE_CYCLES_T1 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Calculated write tier1 epsilon protection
/// count.
///
inline fapi2::ReturnCode proc_eps_write_cycles_t1(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_WRITE_CYCLES_T1, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_WRITE_CYCLES_T1: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_EPS_WRITE_CYCLES_T2 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Calculated write tier2 epsilon protection
/// count.
///
inline fapi2::ReturnCode proc_eps_write_cycles_t2(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_EPS_WRITE_CYCLES_T2, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_EPS_WRITE_CYCLES_T2: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SYSTEM_IPL_PHASE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Define context for current phase of system
/// IPL.
///
inline fapi2::ReturnCode system_ipl_phase(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SYSTEM_IPL_PHASE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SYSTEM_IPL_PHASE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_IS_MPIPL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicates if current IPL is
/// memory-preserving
///
inline fapi2::ReturnCode is_mpipl(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_MPIPL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_IS_MPIPL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  XSCOM BAR base address offset creator: platform consumer: p9_sbe_scominit
/// firmware notes: Defines 16GB range (size implied) mapped for XSCOM usage
/// Attribute holds offset (relative to chip MMIO origin) to program into chip
/// address range field of BAR -- RA bits 22:29 (excludes system/memory
/// select/group/chip
/// fields)
///
inline fapi2::ReturnCode proc_xscom_bar_base_addr_offset(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LPC BAR base address offset creator: platform consumer: p9_sbe_scominit firmware
/// notes: Defines 4GB range (size implied) mapped for LPC usage Attribute holds
/// offset (relative to chip MMIO origin) to program into chip address range field
/// of BAR -- RA bits 22:31 (excludes system/memory select/group/chip
/// fields)
///
inline fapi2::ReturnCode proc_lpc_bar_base_addr_offset(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_MIRROR_PLACEMENT_POLICY getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Define placement policy/scheme for non-mirrored/mirrored memory layout NORMAL =
/// non-mirrored start: 0, mirrored start: 1024TB FLIPPED = mirrored start: 0,
/// non-mirrored start: 512TB Set by platform. Used by
/// mss_eff_grouping.
///
inline fapi2::ReturnCode mem_mirror_placement_policy(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_MIRROR_PLACEMENT_POLICY, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MEM_MIRROR_PLACEMENT_POLICY: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_INTERLEAVE_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used in the setting of groups. It is a bit vector. If the value BITWISE_AND 0x01
/// = 0x01 then groups of 1 are enabled, if the value BITWISE_AND 0x02 = 0x02, then
/// groups of 2 are possible, if the value BITWISE_AND 0x04 = 0x04, then group of 3
/// are possible, if the value BITWISE_AND 0x08 = 0x08, then groups of 4 are
/// possible, if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible,
/// if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible. If no
/// groups can formed according to this input, then an error will be thrown.
/// Provided by the
/// MRW
///
inline fapi2::ReturnCode mss_interleave_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_INTERLEAVE_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_INTERLEAVE_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_INTERLEAVE_GRANULARITY getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Determines the stride covered by each granule in an interleaving group. The
/// default stride -- 128B -- is the only value intended for production FW use. All
/// other combinations are for experimental performance evaluation. Regardless of
/// this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride
/// based on the logic
/// capabilities.
///
inline fapi2::ReturnCode mss_interleave_granularity(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_INTERLEAVE_GRANULARITY, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_INTERLEAVE_GRANULARITY: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_HW_MIRRORING_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TRUE : HW mirroring is enabled. FALSE : HW mirroring is disabled. Provided by
/// the
/// MRW.
///
inline fapi2::ReturnCode mrw_hw_mirroring_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_HW_MIRRORING_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_HW_MIRRORING_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_NEST_PLL_BUCKET getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Select Nest I2C and pll setting from one of the supported
/// frequencies
///
inline fapi2::ReturnCode nest_pll_bucket(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_NEST_PLL_BUCKET, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_NEST_PLL_BUCKET: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_RISK_LEVEL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  HWP/Init "risk level" enabled. Used by HB to pass to HB driven
/// HWPs
///
inline fapi2::ReturnCode risk_level(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_RISK_LEVEL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_RISK_LEVEL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_DISABLE_HBBL_VECTORS getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  BootLoader HWP flag to not place 12K exception vectors. This flag is only
/// applicable when security is
/// disabled.
///
inline fapi2::ReturnCode disable_hbbl_vectors(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DISABLE_HBBL_VECTORS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_DISABLE_HBBL_VECTORS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_BOOT_FLAGS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Switch to using a flag to indicate SEEPROM side
/// SBE
///
inline fapi2::ReturnCode boot_flags(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BOOT_FLAGS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_BOOT_FLAGS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SYS_FORCE_ALL_CORES getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicate that p9_sbe_select_ex should force selection to ALL good EX chiplets
/// having good cores even if only a single EX chiplet mode is
/// executed.
///
inline fapi2::ReturnCode sys_force_all_cores(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SYS_FORCE_ALL_CORES, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SYS_FORCE_ALL_CORES: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SECURITY_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Holds the state of Security Access Bit
/// (SAB)
///
inline fapi2::ReturnCode security_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SECURITY_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SECURITY_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SECURITY_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SBE context: If SBE image has ATTR_SECURITY_MODE == 0b1, leave SAB bit as is.
/// Otherwise (ATTR_SECURITY_MODE == 0b0), query mailbox scratch register 3 bit 6
/// and if set, clear the SAB bit. Non-SBE context: If ATTR_SECURITY_MODE == 0b1, do
/// not attempt to clear the SAB bit via the FSI path. Otherwise (ATTR_SECURITY_MODE
/// == 0b0), attempt to clear the SAB bit via the FSI path. Customer level chips
/// will silently ignore such a request, whereas early lab versions may honor it for
/// debug
/// purposes.
///
inline fapi2::ReturnCode security_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SECURITY_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SECURITY_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PIBMEM_REPAIR0 getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Pibmem repair attribute
/// 0
///
inline fapi2::ReturnCode pibmem_repair0(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PIBMEM_REPAIR0, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PIBMEM_REPAIR0: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PIBMEM_REPAIR1 getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Pibmem repair attribute
/// 1
///
inline fapi2::ReturnCode pibmem_repair1(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PIBMEM_REPAIR1, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PIBMEM_REPAIR1: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PIBMEM_REPAIR2 getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Pibmem repair attribute
/// 2
///
inline fapi2::ReturnCode pibmem_repair2(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PIBMEM_REPAIR2, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PIBMEM_REPAIR2: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SBE_SYS_CONFIG getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  System Configurtion information - 1 indicates a chip
/// present
///
inline fapi2::ReturnCode sbe_sys_config(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SBE_SYS_CONFIG, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SBE_SYS_CONFIG: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_CP_REFCLOCK_RCVR_TERM getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Defines system specific value of processor refclock receiver
/// termination
///
inline fapi2::ReturnCode cp_refclock_rcvr_term(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_CP_REFCLOCK_RCVR_TERM, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_CP_REFCLOCK_RCVR_TERM: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_IO_REFCLOCK_RCVR_TERM getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Defines system specific value of PCI refclock receiver
/// termination
///
inline fapi2::ReturnCode io_refclock_rcvr_term(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IO_REFCLOCK_RCVR_TERM, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_IO_REFCLOCK_RCVR_TERM: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SECTOR_BUFFER_STRENGTH getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sector buffer
/// strength
///
inline fapi2::ReturnCode sector_buffer_strength(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SECTOR_BUFFER_STRENGTH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SECTOR_BUFFER_STRENGTH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PULSE_MODE_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  enable the pulse
/// mode
///
inline fapi2::ReturnCode pulse_mode_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PULSE_MODE_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PULSE_MODE_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_PULSE_MODE_VALUE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  value for pulse
/// mode
///
inline fapi2::ReturnCode pulse_mode_value(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PULSE_MODE_VALUE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_PULSE_MODE_VALUE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_START_CBS_FIFO_RESET_SKIP getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Allow skipping fifo reset during p9_start_cbs, to enable systems without cfam
/// access to fifo registers
/// (WAFER/RBI).
///
inline fapi2::ReturnCode start_cbs_fifo_reset_skip(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_START_CBS_FIFO_RESET_SKIP, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_START_CBS_FIFO_RESET_SKIP: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  To allow for selective enablement for lab testing To allow skew function to be
/// enabled/disabled.
///
inline fapi2::ReturnCode system_corecache_skewadj_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  To allow for selective enablement for lab testing To allow dcadj function to be
/// enabled/disabled.
///
inline fapi2::ReturnCode system_corecache_dcadj_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MC_PLL_BUCKET getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MC pll bucket selection in async mode for
/// Cumulus
///
inline fapi2::ReturnCode mc_pll_bucket(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MC_PLL_BUCKET, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MC_PLL_BUCKET: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


}

#endif
