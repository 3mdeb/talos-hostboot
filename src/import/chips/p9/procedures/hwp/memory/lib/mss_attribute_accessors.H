/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/memory/lib/mss_attribute_accessors.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016                             */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_attribute_accessors.H
#ifndef MSS_ATTR_ACCESS_H_
#define MSS_ATTR_ACCESS_H_

#include <fapi2.H>
#include <lib/mss_utils.H>



namespace mss
{
///
/// @brief ATTR_MSS_VOLT_VDDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value. Computed in mss_volt
/// C code - in millivolts creator: mss_volt consumer: mss_eff_cnfg, others firmware
/// notes:
/// none
///
inline fapi2::ReturnCode volt_vddr(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VDDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VDDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_VPP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM VPP Voltage, each voltage rail would need to have a value. Computed in
/// mss_volt C code - in millivolts. 0V - DDR3, 2.5V - DDR4 creator: mss_volt
/// consumer: mss_eff_cnfg, others firmware notes:
/// none
///
inline fapi2::ReturnCode volt_vpp(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VPP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VPP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  FOR LAB USE ONLY: Frequency override of this memory channel in MT/s comprising
/// of up to three DIMMs. Set by config file or an attribute writing program.
/// Consumed by mss_freq. The default of AUTO means mss_freq will find the best
/// frequencies given the DIMMs plugged in and other rules. Otherwise, this is the
/// system
/// frequency.
///
inline fapi2::ReturnCode freq_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second), comprising
/// of three DIMMs. Computed in mss_freq creator: mss_freq consumer: mss_eff_cnfg,
/// others firmware notes:
/// none
///
inline fapi2::ReturnCode freq(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_BIAS_PERCENTAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Percentage to increase/decrease MEM frequency - two's complement number.
/// Measured in 100's. So the value of 100 is one percent increase. This frequency
/// change comes from changing multipliers and dividers to get the desired
/// frequency. The supported frequencies come from Tim Diemoz. Creator: platform set
/// this to 0. Users can set this to a valid value. VALID Values: (TBD % to TBD %)
/// (Tuleta) (TBD % to TBD %) (Glacier) Set by: PLL settings written by Dave
/// Cadigan
///
inline fapi2::ReturnCode freq_bias_percentage(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_BIAS_PERCENTAGE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_BIAS_PERCENTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Each memory channel will have
/// a value. creator: mss_eff_cnfg consumer: various firmware notes: none This
/// factors in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REFRESH_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REFRESH_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REFRESH_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication
/// mode.
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_NEST_CAPABLE_FREQUENCIES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The NEST frequencies the memory chip can run at computed by the mss_freq. The
/// possibilities are ORed together. The platform uses these value and the MRW to
/// determine what frequency to boot the fabric (nest) if it can. There are two
/// values: 8G and
/// 9.6G
///
inline fapi2::ReturnCode nest_capable_frequencies(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_NEST_CAPABLE_FREQUENCIES, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_NEST_CAPABLE_FREQUENCIES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible DRAM voltage override. Firmware notes: Default should be NONE
/// (0x00).
///
inline fapi2::ReturnCode volt_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VDDR_OVERIDE_SPD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible VDDR voltage
/// override.
///
inline fapi2::ReturnCode vddr_overide_spd(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VDDR_OVERIDE_SPD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VDDR_OVERIDE_SPD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum number of installed DIMMs per VMEM regulator for all VMEM regulators in
/// the
/// system.
///
inline fapi2::ReturnCode vmem_regulator_max_dimm_count(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// cfg_nm_n_per_port
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// cfg_nm_n_per_port
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// cfg_nm_n_per_port
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_OCC_THROTTLED_N_CMDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  cfg_nm_n_per_port throttle N value that was calculated from
/// MSS_DATABUS_UTIL
///
inline fapi2::ReturnCode occ_throttled_n_cmds(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_OCC_THROTTLED_N_CMDS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_OCC_THROTTLED_N_CMDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_OCC_THROTTLED_N_CMDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  cfg_nm_n_per_port throttle N value that was calculated from
/// MSS_DATABUS_UTIL
///
inline fapi2::ReturnCode occ_throttled_n_cmds(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_OCC_THROTTLED_N_CMDS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_OCC_THROTTLED_N_CMDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_OCC_THROTTLED_N_CMDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  cfg_nm_n_per_port throttle N value that was calculated from
/// MSS_DATABUS_UTIL
///
inline fapi2::ReturnCode occ_throttled_n_cmds(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_OCC_THROTTLED_N_CMDS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_OCC_THROTTLED_N_CMDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD
/// OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time in nck (number of clock cyles). Selected
/// tRFC value (tRFC_dl1, tRFC_dl2, or tRFC_dl4) depends on MRW attribute that
/// selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC time to different
/// logical ranks are defined as tRFC_dlr creator: eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time in nck (number of clock cyles). Selected
/// tRFC value (tRFC_dl1, tRFC_dl2, or tRFC_dl4) depends on MRW attribute that
/// selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC time to different
/// logical ranks are defined as tRFC_dlr creator: eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time in nck (number of clock cyles). Selected
/// tRFC value (tRFC_dl1, tRFC_dl2, or tRFC_dl4) depends on MRW attribute that
/// selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC time to different
/// logical ranks are defined as tRFC_dlr creator: eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TXS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Exit Self-Refresh to commands not requiring a locked DLL. In nck (number of
/// clock cycles). Each memory channel will have a value. creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_txs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TXS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TXS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7
/// (bits 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value is conceptually
/// [master + slave] ranks. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value is conceptually
/// [master + slave] ranks. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value is conceptually
/// [master + slave] ranks. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator
/// cfg_nm_n_per_port
///
inline fapi2::ReturnCode mrw_safemode_mem_throttled_n_commands_per_port(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power
/// Limit
///
inline fapi2::ReturnCode mrw_thermal_memory_power_limit(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at max
/// utilization.
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at
/// idle
/// utilization.
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift_idle(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook for the number of M DRAM clocks. One approach to
/// curbing DRAM power usage is by throttling traffic through a programmable N
/// commands over M
/// window.
///
inline fapi2::ReturnCode mrw_mem_m_dram_clocks(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for maximum dram data bus utilization in centi
/// percent (c%). Used to determine memory throttle
/// values.
///
inline fapi2::ReturnCode mrw_max_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Option to control MCS prefetch retry threshold, for performance optimization.
/// This attribute controls the number of retries in the prefetch engine. Retry
/// threshold available ranges from 16 to 30. Note: Values outside those ranges will
/// default to 30. In
/// MRW.
///
inline fapi2::ReturnCode mrw_mcs_prefetch_retry_threshold(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Capable power control settings. In
/// MRW.
///
inline fapi2::ReturnCode mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook enablement of the HWP code to adjust the VMEM
/// regulator power limit based on number of installed
/// DIMMs.
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_adj_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for the maximum possible number of dimms that
/// can be installed under any of the VMEM
/// regulators.
///
inline fapi2::ReturnCode mrw_max_number_dimms_possible_per_vmem_regulator(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_AVDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to AVDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_avdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_AVDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_AVDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VCS_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vcs_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VCS_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VCS_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VPP_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vpp_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VPP_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VPP_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_VDDR_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDDR. Supplied by
/// MRW.
///
inline fapi2::ReturnCode mrw_vddr_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_VDDR_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_VDDR_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FINE_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. Sets DDR4 MRS3. Should be defaulted to normal
/// mode.
///
inline fapi2::ReturnCode mrw_fine_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FINE_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_FINE_REFRESH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_RANGE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended
/// range.
///
inline fapi2::ReturnCode mrw_temp_refresh_range(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_RANGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TEMP_REFRESH_RANGE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  For resetting the phy delay values at the beginning of calling
/// mss_draminit_training. YES means the vaules will be
/// reset.
///
inline fapi2::ReturnCode mrw_reset_delay_before_cal(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PREFETCH_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if prefetching enabled or
/// not.
///
inline fapi2::ReturnCode mrw_prefetch_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PREFETCH_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PREFETCH_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_CLEANER_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if the cleaner of the L4 cache (write modified
/// entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur
/// Workbook.
///
inline fapi2::ReturnCode mrw_cleaner_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_CLEANER_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_CLEANER_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OFFSET_GPO getter
/// @param[out] int8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global Offset in number of Clocks. Delta from the value calculated or taken from
/// VPD.
///
inline fapi2::ReturnCode mrw_offset_gpo(int8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OFFSET_GPO, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_OFFSET_GPO: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OFFSET_RLO getter
/// @param[out] int8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Latency Offset in number of Clocks. Delta from the value calculated or
/// taken from
/// VPD.
///
inline fapi2::ReturnCode mrw_offset_rlo(int8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OFFSET_RLO, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_OFFSET_RLO: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OFFSET_WLO getter
/// @param[out] int8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Latency Offset in number of
/// Clocks
///
inline fapi2::ReturnCode mrw_offset_wlo(int8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OFFSET_WLO, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_OFFSET_WLO: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic calibration for all ports: Reading left to
/// right. (DEFAULT: 0xD90C -> Byte 0(11011001), Byte 1(00001100)) For each bit: OFF
/// = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL
/// 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6:
/// PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2:
/// PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7:
/// SPARE
///
inline fapi2::ReturnCode mrw_periodic_memcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic ZQ calibration for all ports: Reading left
/// to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable
/// periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future
/// use
///
inline fapi2::ReturnCode mrw_periodic_zqcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TSYS_ADR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value for the memory sub-system clock in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode mrw_tsys_adr(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TSYS_ADR, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TSYS_ADR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TSYS_DATA getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value for the memory sub-system data in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode mrw_tsys_data(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TSYS_DATA, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TSYS_DATA: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_2N_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal
/// Integrity generated setting (from
/// VPD).
///
inline fapi2::ReturnCode mrw_dram_2n_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_2N_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DRAM_2N_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MR_0_VERSION_LAYOUT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mr_0_version_layout(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_0_VERSION_LAYOUT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_0_VERSION_LAYOUT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_1_VERSION_DATA getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mr_1_version_data(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_1_VERSION_DATA, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_1_VERSION_DATA: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_2_SIGNATURE_HASH getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mr_2_signature_hash(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_2_SIGNATURE_HASH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_2_SIGNATURE_HASH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal
/// Integrity.
///
inline fapi2::ReturnCode vpd_mr_mc_2n_mode_autoset(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal
/// Integrity.
///
inline fapi2::ReturnCode vpd_mr_mc_2n_mode_autoset(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal
/// Integrity.
///
inline fapi2::ReturnCode vpd_mr_mc_2n_mode_autoset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MT_0_VERSION_LAYOUT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mt_0_version_layout(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_0_VERSION_LAYOUT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_0_VERSION_LAYOUT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_1_VERSION_DATA getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mt_1_version_data(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_1_VERSION_DATA, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_1_VERSION_DATA: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_2_SIGNATURE_HASH getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mt_2_signature_hash(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_2_SIGNATURE_HASH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_2_SIGNATURE_HASH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering
/// bitmap.
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for preamble. Calibration only uses 1 nCK preamble
/// (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble
/// option.
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for preamble. Calibration only uses 1 nCK preamble
/// (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble
/// option.
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for preamble. Calibration only uses 1 nCK preamble
/// (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble
/// option.
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps] with sign bit0 (0b0=positive, 0b1=negative)
/// and value in bits1..31, so 0x8023 for example would mean "-35ps". If this is
/// enabled, disable periodic rd_ctr in draminit_mc.
/// Default
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps] with sign bit0 (0b0=positive, 0b1=negative)
/// and value in bits1..31, so 0x8023 for example would mean "-35ps". If this is
/// enabled, disable periodic rd_ctr in draminit_mc.
/// Default
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps] with sign bit0 (0b0=positive, 0b1=negative)
/// and value in bits1..31, so 0x8023 for example would mean "-35ps". If this is
/// enabled, disable periodic rd_ctr in draminit_mc.
/// Default
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


}

#endif
