/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/io/p9_io_regs.H $          */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2015,2017                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
///
/// @file p9_io_regs.H
/// @brief Registers to be used with p9_io_scom.
///----------------------------------------------------------------------------
/// *HWP HWP Owner        : Chris Steffen <cwsteffen@us.ibm.com>
/// *HWP HWP Backup Owner : Gary Peterson <garyp@us.ibm.com>
/// *HWP FW Owner         : Jamie Knight <rjknight@us.ibm.com>
/// *HWP Team             : IO
/// *HWP Level            : 3
/// *HWP Consumed by      : FSP:HB
///----------------------------------------------------------------------------
///
/// @verbatim
/// Design specific registers
///
/// @endverbatim
///----------------------------------------------------------------------------


#ifndef P9_IO_REGS_H_
#define P9_IO_REGS_H_




/*
 * *****************************
 *  Registers & Fields
 * *****************************
*/
#define OPT_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_PSEG_PRE_EN                                 0x800d34000000003f, 51,  5 // pre bank pseg enable
#define OPT_TX_PSEG_PRE_SEL                                0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define OPT_TX_NSEG_PRE_EN                                 0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define OPT_TX_NSEG_PRE_SEL                                0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define OPT_TX_PSEG_MARGINPU_EN                            0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define OPT_TX_PSEG_MARGINPD_EN                            0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define OPT_TX_NSEG_MARGINPU_EN                            0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define OPT_TX_NSEG_MARGINPD_EN                            0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define OPT_TX_MARGINPU_SEL                                0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define OPT_TX_MARGINPD_SEL                                0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define OPT_TX_PSEG_MAIN_EN                                0x800d5c000000003f, 51,  7 // main bank pseg enable
#define OPT_TX_NSEG_MAIN_EN                                0x800d64000000003f, 51,  7 // main bank nseg enable
#define OPT_TX_PSEG_POST_EN                                0x800d84000000003f, 49,  7 // post bank pseg enable
#define OPT_TX_PSEG_POST_SEL                               0x800d84000000003f, 56,  7 // post bank pseg mode selection
#define OPT_TX_NSEG_POST_EN                                0x800d8c000000003f, 49,  7 // post bank nseg enable
#define OPT_TX_NSEG_POST_SEL                               0x800d8c000000003f, 56,  7 // post bank nseg mode selection
#define OPT_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define OPT_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_BUSY                                   0x800f04000000003f, 52,  1 // impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define OPT_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_SM_MIN_VAL                             0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_ZCAL_SM_MAX_VAL                             0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_IMPCAL_SWO2_PB                              0x800f2c000000003f, 48, 16 // register -- description
#define OPT_RX_RUN_DCCAL                                   0x800320000000003f, 49,  1 // run on-die dc training on given lane
#define OPT_RX_DCCAL_DONE                                  0x800328000000003f, 49,  1 // on-die dc training complete on given lane
#define OPT_RX_B_BANK_CONTROLS                             0x800008000000003f, 58,  6 // power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_IORESET_HARD_BUS0                              0x0000000000000020,  2,  1 // io hard reset per-bus and gcr reset
#define OPT_RX_CLKDIST_PDWN                                0x800810000000003f, 48,  3
#define OPT_TX_CLKDIST_PDWN                                0x800C14000000003f, 48,  3
#define OPT_RX_IREF_PDWN_B                                 0x8008C0000000003f, 54, 1
#define OPT_RX_CTL_DATASM_CLKDIST_PDWN                     0x800B80000000003f, 60, 1
#define OPT_RX_LANE_ANA_PDWN                               0x800008000000003f, 54, 1
#define OPT_RX_LANE_DIG_PDWN                               0x800220000000003f, 48, 1
#define OPT_TX_LANE_PDWN                                   0x800404000000003f, 48, 1
#define OPT_RX_PR_FW_OFF                                   0x800228000000003f, 56, 1
#define OPT_RX_PR_EDGE_TRACK_CNTL                          0x800248000000003f, 48, 2

#define EDIP_RX_FIR_RESET                                  0x800ab0000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches including the isolation and parity error latches.
#define EDIP_TX_ZCAL_REQ                                   0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_DONE                                  0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define EDIP_TX_ZCAL_ERROR                                 0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define EDIP_TX_IMPCAL_PB                                  0x800f04000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_N                                     0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_P                                     0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_SM_MIN_VAL                            0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_ZCAL_SM_MAX_VAL                            0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_IMPCAL_SWO2_PB                             0x800f2c000000003f, 48, 16 // register -- description
#define EDIP_TX_PSEG_PRE_EN                                0x800d34000000003f, 51,  5 // pre bank pseg enable
#define EDIP_TX_PSEG_PRE_SEL                               0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define EDIP_TX_NSEG_PRE_EN                                0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define EDIP_TX_NSEG_PRE_SEL                               0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define EDIP_TX_PSEG_MARGINPU_EN                           0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define EDIP_TX_PSEG_MARGINPD_EN                           0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define EDIP_TX_NSEG_MARGINPU_EN                           0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define EDIP_TX_NSEG_MARGINPD_EN                           0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define EDIP_TX_MARGINPU_SEL                               0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define EDIP_TX_MARGINPD_SEL                               0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define EDIP_TX_PSEG_MAIN_EN                               0x800d5c000000003f, 51, 13 // main bank pseg enable
#define EDIP_TX_NSEG_MAIN_EN                               0x800d64000000003f, 51, 13 // main bank nseg enable
#define EDIP_RX_LANE_INVALID                               0x800240000000003f, 50,  1 // marks this rx slice as invalid and fences other operations.  use this bit, for example, to broadcast a setting to all good lanes but not bad or disabled ones.
#define EDIP_RX_WT_CU_PLL_PGOOD                            0x8009f8000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset
#define EDIP_RX_WT_CU_BYP_PLL_LOCK                         0x8009f8000000003f, 49,  1 // override rx pll/dll lock.  this should be ored into places where pll locked is checked (i.e. wt state machine), used to bypass waiting for a pll lock
#define EDIP_RX_WT_PLL_REFCLKSEL                           0x8009f8000000003f, 50,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock
#define EDIP_RX_PLL_REFCLKSEL_SCOM_EN                      0x8009f8000000003f, 51,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock
#define EDIP_RX_IORESET                                    0x8009f8000000003f, 52,  1 // reset the given rx clock group including gcr slave
#define EDIP_RX_CTL_CNTL4_E_PG                             0x8009f8000000003f, 48, 16 // register -- description
#define EDIP_RX_START_DC_CALIBRATE                         0x8009f0000000003f, 53,  1 // when this register is written to a 1 the training state machine will run the dc calibrate substeps definedin eye optimizations.
#define EDIP_RX_DC_CALIBRATE_DONE                          0x800a38000000003f, 53,  1 // when this bit is read as a 1, the dc calibration steps have been completed. check the corresponding rx_dc_calibration_failed register field for the pass/fail status of operation state.
#define EDIP_RX_START_WDERF_ALIAS                          0x8009f0000000003f, 48,  5 // alias for rx_start_* bits
#define EDIP_RX_CTL_CNTL1_E_PG                             0x8009f0000000003f, 48, 16 // register -- description
#define EDIP_RX_WDERF_DONE_ALIAS                           0x800a38000000003f, 48,  5 // alias for rx_*_done bits
#define EDIP_RX_WDERF_FAILED_ALIAS                         0x800a38000000003f, 56,  5 // alias for rx_*_failed bits
#define EDIP_RX_CTL_STAT1_E_PG                             0x800a38000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_0_15                          0x800a40000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).  the bad_lane vector is only updated during initial training.  
#define EDIP_RX_CTL_STAT2_E_PG                             0x800a40000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_16_23                         0x800a50000000003f, 48,  8 // lanes found bad by hw (status) or method to force lane bad from software (control).
#define EDIP_RX_CTL_STAT4_E_PG                             0x800a50000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_0_15                     0x8009e0000000003f, 48, 16 // used to set which of group lanes 0-15 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE11_E_PG                            0x8009e0000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_16_23                    0x8009e8000000003f, 48,  8 // used to set which of group lanes 16-23 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE12_E_PG                            0x8009e8000000003f, 48, 16 // register -- description
#define EDIP_RX_MAIN_INIT_STATE                            0x800b18000000003f, 48,  4 // main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused
#define EDIP_RX_WTM_STATE                                  0x800b18000000003f, 52,  6 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail 
#define EDIP_RX_WTR_STATE                                  0x800b18000000003f, 58,  5 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused
#define EDIP_RX_GLBSM_STAT1_E_PG                           0x800b18000000003f, 48, 16 // register -- description
#define EDIP_RX_WTL_SM_STATUS                              0x800960000000003f, 48,  5 // wiretest lane machine status    
#define EDIP_RX_CTL_STAT3_EO_PG                            0x800960000000003f, 48, 16 // register -- description
#define EDIP_RX_WTR_BAD_LANE_COUNT                         0x800b20000000003f, 59,  5 // wiretest current number of bad lanes in this clk group
#define EDIP_RX_GLBSM_STAT2_E_PG                           0x800b20000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_CLK_LANE_INVERTED                       0x800a58000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted
#define EDIP_RX_WT_CLK_LANE_BAD_CODE                       0x800a58000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused
#define EDIP_RX_CTL_STAT5_E_PG                             0x800a58000000003f, 48, 16 // register -- description
#define EDIP_RX_EYE_OPT_STATE                              0x800ab8000000003f, 48, 12 // eye optimizaton state machine current state 
#define EDIP_RX_GLBSM_STAT1_EO_PG                          0x800ab8000000003f, 48, 16 // register -- description
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    0x800938000000003f, 49,  5 // rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define EDIP_RX_CTL_CNTL13_EO_PG                           0x800938000000003f, 48, 16 // register -- description
#define EDIP_RX_RPR_STATE                                  0x800b30000000003f, 48,  7 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state
#define EDIP_RX_GLBSM_STAT4_E_PG                           0x800b30000000003f, 48, 16 // register -- description
#define EDIP_RX_BAD_LANE1                                  0x800b58000000003f, 48,  7 // encoded bad lane one in relation to the entire rx bus
#define EDIP_RX_BAD_LANE2                                  0x800b58000000003f, 55,  7 // encoded bad lane two in relation to the entire rx bus
#define EDIP_RX_BAD_LANE_CODE                              0x800b58000000003f, 62,  2 // rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_RX_GLBSM_STAT9_E_PG                           0x800b58000000003f, 48, 16 // register -- description
#define EDIP_TX_CLK_UNLOAD_CLK_DISABLE                     0x800c1c000000003f, 50,  1 // set to 0 to clock off sync logic on the clock slice and save power.  it should not be necessary to use the sync logic on the clock slice since it has no fifo but control is available just in case.
#define EDIP_TX_CLK_RUN_COUNT                              0x800c1c000000003f, 51,  1 // set to 1 to enable the tx clock slice serializer.  this should be enabled at all times but control is available just in case.
#define EDIP_TX_UNLOAD_CLK_DISABLE                         0x80040c000000003f, 56,  1 // set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define EDIP_SCOM_FIR_PB                                   0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDIP_RX_LANE_DIG_PDWN                              0x800220000000003f, 48,  1 // used to power down digital logic for a lane. 
#define EDIP_RX_LANE_ANA_PDWN                              0x800008000000003f, 54,  1 // lane power down of analog and custom circuits
#define EDIP_TX_MSBSWAP                                    0x800c14000000003f, 58,  1 // used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode
#define EDIP_TX_END_LANE_ID                                0x800c84000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_TX_LANE_PDWN                                  0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default). 
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    0x800938000000003f, 49,  5 // rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define EDIP_RX_CTL_CNTL13_EO_PG                           0x800938000000003f, 48, 16 // register -- description
#define EDIP_TX_IORESET                                    0x800c9c000000003f, 48,  1 // reset the given tx clock group and gcr slave
#define EDIP_TX_FIR_RESET                                  0x800d14000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define EDIP_RX_ABORT_CHECK_TIMEOUT_SEL                    0x800840000000003f, 48,  4 // selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_POLLING_TIMEOUT_SEL                        0x800840000000003f, 52,  4 // selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_CTL_MODE7_EO_PG                            0x800840000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_CHG_CFG                              0x800868000000003f, 48,  4 // this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point. 
#define EDIP_RX_AMP_INIT_TIMEOUT                           0x800878000000003f, 48,  4 // rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMP_RECAL_TIMEOUT                          0x800878000000003f, 52,  4 // rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_INIT_TIMEOUT                          0x800878000000003f, 56,  4 // rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_RECAL_TIMEOUT                         0x800878000000003f, 60,  4 // rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE14_EO_PG                           0x800878000000003f, 48, 16 // register -- description
#define EDIP_RX_OFF_INIT_TIMEOUT                           0x800880000000003f, 48,  4 // rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.10 for timer settings)
#define EDIP_RX_OFF_RECAL_TIMEOUT                          0x800880000000003f, 52,  4 // rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_CM_TIMEOUT                                 0x800880000000003f, 56,  4 // rx_cm_timeout            used for common mode measurements         (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMIN_TIMEOUT                               0x800880000000003f, 60,  4 // rx_amin_timeout        used for amin masurements                   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE15_EO_PG                           0x800880000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_TIMEOUT                                0x800888000000003f, 48,  4 // rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.10 for timer settings)
#define EDIP_RX_USERDEF_TIMEOUT                            0x800888000000003f, 52,  4 // rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.10 for timer settings)
#define EDIP_RX_BER_TIMEOUT                                0x800888000000003f, 56,  4 // rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE16_EO_PG                           0x800888000000003f, 48, 16 // register -- description


#define EDI_RX_WTM_STATE                                   0x800950000000003f, 48,  5 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail \r\n\trjr
#define EDI_RX_WTR_STATE                                   0x800950000000003f, 53,  4 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused\r\n\trjr
#define EDI_RX_WTL_STATE                                   0x800950000000003f, 59,  5 // lane wiretest sub state machine current state (rjr)\r\n\tx00: idle\r\n\tx01: wait 1st long transition\r\n\tx02: wait 2nd long transition\r\n\tx03: wait short transition\r\n\tx04: wait transition from pn=01\r\n\tx05: wait transition from 10\r\n\tx06: wait transition from 00\r\n\tx07: wait transition from 11\r\n\tx10: good-no swap\r\n\tx11: bad-n=1-no swap\r\n\tx12: bad-n=0-no swap\r\n\tx13: bad-p=1-no swap\r\n\tx14: bad-p=0-no swap\r\n\tx15: bad-p or n floating\r\n\tx16: bad-pn=00\r\n\tx17: bad-pn=11\r\n\tx18: good--swapped\r\n\tx19: bad-n=1-swapped\r\n\tx1a: bad-n=0-swapped\r\n\tx1b: bad-p=1-swapped\r\n\tx1c: bad-p=0-swapped\r\n\tx1d: bad-pn=10\r\n\tx1e: bad-pn=01\r\n\tx1f: bad-unknown failure\r\n\trjr
#define EDI_RX_WIRETEST_STATE_PG                           0x800950000000003f, 48, 16 // rx wiretest state machine reg -- rx main and rx wiretest state machines
#define EDI_RX_WTR_BAD_LANE_COUNT                          0x800958000000003f, 59,  5 // wiretest current number of bad lanes in this clk group\r\n\trjr
#define EDI_RX_WIRETEST_LANEINFO_PG                        0x800958000000003f, 48, 16 // rx wiretest lane info reg -- rx wiretest current lane, max bad lanes allowed and number of currently marked bad lanes
#define EDI_RX_WT_CLK_LANE_INVERTED                        0x800a10000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted\r\n\trjr
#define EDI_RX_WT_CLK_LANE_BAD_CODE                        0x800a10000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused\r\n\trjr
#define EDI_RX_WT_CLK_STATUS_PG                            0x800a10000000003f, 48, 16 // rx clock wiretest status -- description
#define EDI_RX_EYE_OPT_STATE                               0x800ac0000000003f, 48,  8 // common edi/ei4 eye optimizaton state machine \r\n\t00000000: idle \r\n\t00000001: init latch offset cal done \r\n\t00000010: vref/dcd cal done \r\n\t00000011: vga done \r\n\t00000100: unused \r\n\t00000101: unused \r\n\t00000110: unused \r\n\t00000111: ctle done \r\n\t00001000: h1ap adjust done \r\n\t00001001: ddc done \r\n\t00001010: measure eye width done \r\n\t00001011: final l2u adjust done \r\n\t00001100: unused \r\n\t00001101: results check done \r\n\t00001110: eye opt all done \r\n\t00001111: unused \r\n\t00010000: start latch offset cal \r\n\t00010001: start latch offset cal 0 \r\n\t00010010: read latch offset cal 0 status \r\n\t00010011: check latch offset cal 0 status \r\n\t00010100: start latch offset cal 1 \r\n\t00010101: read latch offset cal 1 status \r\n\t00010110: check latch offset cal 1 status \r\n\t00010111: bist latch offset cal done \r\n\t00011000: unused \r\n\t00011001: unused \r\n\t00011010: unused \r\n\t00011011: unused \r\n\t00011100: unused \r\n\t00011101: unused \r\n\t00011110: unused \r\n\t00011111: unused \r\n\t00100000: start vref cal \r\n\t00100001: start vref servo \r\n\t00100010: read vref servo status \r\n\t00100011: check vref servo status \r\n\t00100100: start dcd adjust servo \r\n\t00100101: read dcd adjust servo status \r\n\t00100110: check dcd adjust servo status \r\n\t00100111: unused \r\n\t00101000: unused \r\n\t00101001: unused \r\n\t00101010: unused \r\n\t00101011: unused \r\n\t00101100: unused \r\n\t00101101: unused \r\n\t00101110: unused \r\n\t00101111: unused \r\n\t00110000: vga start-clear done flags \r\n\t00110001: vga measure ape/apo \r\n\t00110010: vga read ape/apo status \r\n\t00110011: vga check ape/apo status \r\n\t00110100: vga measure ane/ano \r\n\t00110101: vga read ane/ano status \r\n\t00110110: vga check ane/ano status \r\n\t00110111: vga measure ape dfe \r\n\t00111000: vga read ape dfe status \r\n\t00111001: vga check ape dfe status \r\n\t00111010: vga measure ane dfe \r\n\t00111011: vga read ane dfe status \r\n\t00111100: vga check ane dfe status \r\n\t00111101: vga measure apo dfe \r\n\t00111110: vga read apo dfe status \r\n\t00111111: vga check apo dfe status \r\n\t01000000: vga measure ano dfe \r\n\t01000001: vga read ano dfe status \r\n\t01000010: vga check ano dfe status \r\n\t01000011: vga measure amin no dfe \r\n\t01000100: vga read amin no dfe status \r\n\t01000101: vga check amin no dfe status \r\n\t01000110: vga measure amin dfe \r\n\t01000111: vga read amin dfe status \r\n\t01001000: vga check amin dfestatus \r\n\t01001001: vga clear lane address \r\n\t01001010: vga check lane valid \r\n\t01001011: vga read rx amp cntl \r\n\t01001100: vga read rx amp values \r\n\t01001101: vga read ape and apo \r\n\t01001110: vga read ane and ano \r\n\t01001111: vga read amine and amino \r\n\t01010000: vga check offset \r\n\t01010001: vga check amax \r\n\t01010010: vga write vga done control \r\n\t01010011: vga write all done status \r\n\t01010100: vga write vga adjust value \r\n\t01010101: vga check done \r\n\t01010110: unused \r\n\t01010111: unused \r\n\t01011000: unused \r\n\t01011001: unused \r\n\t01011010: unused \r\n\t01011011: unused \r\n\t01011100: unused \r\n\t01011101: unused \r\n\t01011110: unused \r\n\t01011111: unused \r\n\t01100000: unused \r\n\t01100001: unused \r\n\t01100010: unused \r\n\t01100011: unused \r\n\t01100100: unused \r\n\t01100101: unused \r\n\t01100110: unused \r\n\t01100111: unused \r\n\t01101000: unused \r\n\t01101001: unused \r\n\t01101010: unused \r\n\t01101011: unused \r\n\t01101100: unused \r\n\t01101101: unused \r\n\t01101110: unused \r\n\t01101111: unused \r\n\t01110000: ctle start \r\n\t01110001: ctle bump left \r\n\t01110010: ctle read bump left status \r\n\t01110011: ctle check bump left status \r\n\t01110100: ctle start servo \r\n\t01110101: ctle read servo status \r\n\t01110110: ctle check servo status \r\n\t01110111: ctle bump right \r\n\t01111000: ctle read bump right status \r\n\t01111001: ctle check bump rightstatus \r\n\t01111010: unused \r\n\t01111011: unused \r\n\t01111100: unused \r\n\t01111101: unused \r\n\t01111110: unused \r\n\t01111111: unused \r\n\t10000000: h1ap tweak start \r\n\t10000001: h1ap tweak run servo \r\n\t10000010: h1ap tweak read servo status \r\n\t10000011: h1ap tweak check servo status \r\n\t10000100: unused \r\n\t10000101: unused \r\n\t10000110: unused \r\n\t10000111: unused \r\n\t10001000: unused \r\n\t10001001: unused \r\n\t10001010: unused \r\n\t10001011: unused \r\n\t10001100: unused \r\n\t10001101: unused \r\n\t10001110: unused \r\n\t10001111: unused \r\n\t10010000: ddc start \r\n\t10010001: ddc run servo \r\n\t10010010: ddc read servo status \r\n\t10010011: ddc check servo status \r\n\t10010100: ddc check clear counter \r\n\t10010101: ddc check fly state \r\n\t10010110: ddc check lane \r\n\t10010111: ddc read  lane status \r\n\t10011000: ddc check lane status \r\n\t10011001: ddc write bad ddc \r\n\t10011010: ddc check if all done \r\n\t10011011: unused \r\n\t10011100: unused \r\n\t10011101: unused \r\n\t10011110: unused \r\n\t10011111: unused \r\n\t10100000: eye measure start \r\n\t10100001: eye measure start edge track \r\n\t10100010: eye measure read edge track status \r\n\t10100011: eye measure check edge track status \r\n\t10100100: eye measure fly state \r\n\t10100101: eye measure start eye track \r\n\t10100110: eye measure read eye track status \r\n\t10100111: eye measure check eye track status \r\n\t10101000: unused \r\n\t10101001: unused \r\n\t10101010: unused \r\n\t10101011: unused \r\n\t10101100: unused \r\n\t10101101: unused \r\n\t10101110: unused \r\n\t10101111: unused \r\n\t10110000: final l2u set sls checkers \r\n\t10110001: final l2u run err check timer \r\n\t10110010: final l2u dec l2u delay \r\n\t10110011: final l2u inc prbs \r\n\t10110100: final l2u inc l2u delay \r\n\t10110101: final l2u dec prbs \r\n\t10110110: unused \r\n\t10110111: final l2u run err check timer \r\n\t10111000: final l2u clear l2u counter \r\n\t10111001: final l2u check final delay \r\n\t10111010: final l2u inc l2u final delay \r\n\t10111011: final l2u dec prbs \r\n\t10111100: unused \r\n\t10111101: unused \r\n\t10111110: final l2u done \r\n\t10111111: final l2u fail \r\n\t11000000: final l2u wait for prev group status \r\n\t11000001: final l2u send status to next group \r\n\t11000010: final l2u wait for all group status \r\n\t11000011: unused \r\n\t11000100: unused \r\n\t11000101: unused \r\n\t11000110: unused \r\n\t11000111: unused \r\n\t11001000: unused \r\n\t11001001: unused \r\n\t11001010: unused \r\n\t11001011: unused \r\n\t11001100: unused \r\n\t11001101: unused \r\n\t11001110: final l2u max change send fail \r\n\t11001111: final l2u max change recv fail \r\n\t11010000: result check clear and start \r\n\t11010001: result check fly state \r\n\t11010010: result check for valid lane \r\n\t11010011: result check read eye width \r\n\t11010100: result check write bad width \r\n\t11010101: result check read amin values \r\n\t11010110: result check check height \r\n\t11010111: result check write bad height \r\n\t11011000: result check start ber servo \r\n\t11011001: result check read ber servo stat \r\n\t11011010: result check checkber status \r\n\t11011011: result check read ber count \r\n\t11011100: result checkcheck ber \r\n\t11011101: result check write bad ber \r\n\t11011110: result checkcheck if done \r\n\t11011111: result check fail \r\n\t11100000: completion start \r\n\t11100001: completion enable driving all \r\n\t11100010: completion drive eye opt done \r\n\t11100011: completion set up sls rcvr \r\n\t11100100: completion watch for sls nop \r\n\t11100101: completion drive sls nop ds \r\n\t11100110: completion wait for sls nop \r\n\t11100111: completion undrive lanes \r\n\t11101000: completion drive bogus sls nop \r\n\t11101001: completion wait non-sls data \r\n\t11101010: completion enable receive sls \r\n\t11101011: completion eye opt done \r\n\t11101100: unused \r\n\t11101101: unused \r\n\t11101110: unused \r\n\t11101111: unused \r\n\t11110000: latch offset fail \r\n\t11110001: vref fail \r\n\t11110010: vga measure ape/o fail \r\n\t11110011: vga measure ane/o fail \r\n\t11110100: vga measure ape dfe fail \r\n\t11110101: vga measure ane/o fail \r\n\t11110110: vga measure ane/o fail \r\n\t11110111: vga measure ano dfe fail \r\n\t11111000: vga measure amine fail \r\n\t11111001: vga measure amine fail \r\n\t11111010: ctle adjust fail \r\n\t11111011: h1ap tweak fail \r\n\t11111100: ddc fail \r\n\t11111101: measure eye fail \r\n\t11111110: dcd duty cycle fail \r\n\t11111111: unused \r\n\trjr
#define EDI_RX_EO_RECAL_PG                                 0x800ac0000000003f, 48, 16 // rx eye opt and recal status -- description
#define EDI_RX_RPR_STATE                                   0x800990000000003f, 48,  6 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state\r\n\tsmr
#define EDI_RX_STATIC_REPAIR_STATE_PG                      0x800990000000003f, 48, 16 // rx static repair state machine reg -- description
#define EDI_RX_BAD_LANE1_GCRMSG                            0x800988000000003f, 48,  7 // gcr message: encoded bad lane one in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE2_GCRMSG                            0x800988000000003f, 55,  7 // gcr message: encoded bad lane two in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE_CODE_GCRMSG                        0x800988000000003f, 62,  2 // gcr message: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_RX_BAD_LANE_ENC_GCRMSG_PG                      0x800988000000003f, 48, 16 // rx bad lanes encoded -- description
#define EDI_RX_START_WDERF_ALIAS                           0x800880000000003f, 48,  5 // alias for rx_start_* bits\r\n\tpmt
#define EDI_RX_TRAINING_START_PG                           0x800880000000003f, 48, 16 // rx training state start reg -- description
#define EDI_RX_WDERF_DONE_ALIAS                            0x800888000000003f, 48,  5 // alias for rx_*_done bits\r\n\tpmt
#define EDI_RX_WDERF_FAILED_ALIAS                          0x800888000000003f, 56,  5 // alias for rx_*_failed bits\r\n\tpmt
#define EDI_RX_TRAINING_STATUS_PG                          0x800888000000003f, 48, 16 // rx training state status reg -- description
#define EDI_RX_LANE_BAD_VEC_0_15                           0x800918000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).to be clear, the bad_lane vector is only updated during training.  it will not reflect bad lanes found post training during dynamic repair or dynamic recal.  for that, you need to read the [rx,tx]_bad_lane[1,2]_gcrmsg registers.  to calculate what you want to know, you need five registers:\r\n\t rx_bad_lane1_gcrmsg\r\n\t rx_bad_lane2_gcrmsg\r\n\t rx_bad_lane_code_gcrmsg\r\n\t rx_sls_lane_gcrmsg\r\n\t rx_wtr_max_bad_lanes\r\n\tin general, if the spares deployed fir goes on, and the bad_lane_code is a 1, then the newly spared lane resides in the rx_bad_lane1_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 2, then the newly spared lane resides in the rx_bad_lane2_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 3, then the newly spared lane resides in the rx_sls_lane_gcrmsg register. that might be enough information for what you want to know, trying to keep the answer very general.  at the moment, this case where both the spare deployed and max spares exceeded both come on at the same time, is for the edi where a third bad lane has been found and we have chosen to use the sls lane as a third spare. edi normally only has two spare lanes. in that case, i first set the spare deployed fir as the sls lane is being used as a third spare. but then a few cycles later, i set the max spares exceeded because i no longer have an sls lane and cant finish my sls repair handshake.\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_0_15_PG                        0x800918000000003f, 48, 16 // rx bad lanes 0 to 15 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_BAD_VEC_16_31                          0x800920000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_16_31_PG                       0x800920000000003f, 48, 16 // rx bad lanes 16 to 31 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_DISABLED_VEC_0_15                      0x800928000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_0_15_PG                   0x800928000000003f, 48, 16 // rx lane disable(d) 0 to 15 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_RX_LANE_DISABLED_VEC_16_31                     0x800930000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_16_31_PG                  0x800930000000003f, 48, 16 // rx lane disable(d) 16_31 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_SCOM_FIR_PB                                    0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDI_TX_FIR_RESET                                   0x800c44000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.\r\n\tpmt
#define EDI_RX_FIR_RESET                                   0x800848000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_NVAL_PB                              0x800f0c000000003f, 48, 16 // tx impedance cal n value reg -- tx impedance cal n value reg
#define EDI_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_PVAL_PB                              0x800f14000000003f, 48, 16 // tx impedance cal p value reg -- tx impedance cal p value reg
#define EDI_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // tx impedance cal cntl and status reg -- tx impedance cal cntl and status reg
#define EDI_TX_FFE_MAIN_P_ENC                              0x800cd4000000003f, 49,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_MAIN_N_ENC                              0x800cd4000000003f, 57,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_POST_P_ENC                              0x800cdc000000003f, 51,  5 // tbd this field is updated during tx bist by logic temporarily\r\n\tjfg
#define EDI_TX_FFE_POST_N_ENC                              0x800cdc000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_P_ENC                            0x800ce4000000003f, 51,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_N_ENC                            0x800ce4000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_RX_PDWN_LITE_DISABLE                           0x800818000000003f, 50,  1 // disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)\r\n\tsmr
#define EDI_RX_WT_TIMEOUT_SEL                              0x800898000000003f, 58,  3 // selects wiretest timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_WT_CU_PLL_PGOOD                             0x800a30000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_RESET                             0x800a30000000003f, 49,  1 // rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing\r\n\tjfg
#define EDI_RX_WT_CU_PLL_PGOODDLY                          0x800a30000000003f, 50,  3 // rx pll/dll pgood delay selects length of reset period after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking period \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_LOCK                              0x800a30000000003f, 53,  1 // rx pll/dll locked\r\n\tjfg
#define EDI_RX_WT_PLL_REFCLKSEL                            0x800a30000000003f, 54,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock\r\n\tdmb
#define EDI_RX_PLL_REFCLKSEL_SCOM_EN                       0x800a30000000003f, 55,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock\r\n\tdmb
#define EDI_RX_WIRETEST_PLL_CNTL_PG                        0x800a30000000003f, 48, 16 // rx pll or dll reset and calibration controls -- description
#define EDI_RX_OFFSET_CAL_DONE                             0x800888000000003f, 54,  1 // when this bit is read as a 1, offset cal has completed. \r\n\tjgr
#define EDI_RX_OFFSET_CAL_FAILED                           0x800888000000003f, 62,  1 // when this bit is read as a 1, the rx cu pll failed to lock and offset cal was not performed. (this bit is set along with rx_wt_bypass_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_TRAINING_STATUS_PG                          0x800888000000003f, 48, 16 // rx training state status reg -- description
#define EDI_RX_START_OFFSET_CAL                            0x800880000000003f, 54,  1 // set bit to run offset cal and the required tx fifo init, rx cu pll lock, and rx fifo init through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (ocal) start offset cal \r\n\tjgr
#define EDI_RX_EO_LATCH_OFFSET_DONE                        0x800a40000000003f, 48,  1 // rx eye optimization latch offset adjustment done\r\n\trjr
#define EDI_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.\r\n\tjfg
#define EDI_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.\r\n\tjfg

#endif /*IO_HW_REGS_H_*/
