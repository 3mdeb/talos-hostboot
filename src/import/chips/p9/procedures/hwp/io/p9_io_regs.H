/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: chips/p9/procedures/hwp/io/p9_io_regs.H $                     */
/*                                                                        */
/* IBM CONFIDENTIAL                                                       */
/*                                                                        */
/* EKB Project                                                            */
/*                                                                        */
/* COPYRIGHT 2015                                                         */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* The source code for this program is not published or otherwise         */
/* divested of its trade secrets, irrespective of what has been           */
/* deposited with the U.S. Copyright Office.                              */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
///
/// @file p9_io_regs.H
/// @brief Register / Field Details.
///----------------------------------------------------------------------------
/// *HWP HWP Owner   : Chris Steffen <cwsteffen@us.ibm.com>
/// *HWP FW Owner    : Jamie Knight <rjknight@us.ibm.com>
/// *HWP Team        : IO
/// *HWP Level       : 2
/// *HWP Consumed by : FSP:HB
///----------------------------------------------------------------------------
///
/// @verbatim
/// Provides Register and Field defines.
///
/// @endverbatim
///----------------------------------------------------------------------------

#ifndef P9_IO_REGS_H_
#define P9_IO_REGS_H_


#define GET_NAME(VAR) lc(#VAR)
#define GET_1(ID, START_ADDR, WIDTH) ID
#define GET_2(ID, START_ADDR, WIDTH) START_ADDR
#define GET_3(ID, START_ADDR, WIDTH) WIDTH

#define FLD_ID(...) GET_1(__VA_ARGS__)
#define FLD_START(...) GET_2(__VA_ARGS__)
#define FLD_WIDTH(...) GET_3(__VA_ARGS__)
#define REG_ID(...) GET_1(__VA_ARGS__)
#define REG_ADDR(...) GET_2(__VA_ARGS__)
#define REG_WIDTH(...) GET_3(__VA_ARGS__)



/*
 * *****************************
 *  Registers
 * *****************************
*/

#define OPT_TX_MODE1_PL                            0, 0x8004040000000000, 16
#define OPT_TX_MODE2_PL                            1, 0x80040c0000000000, 16
#define OPT_TX_CNTL1G_PL                           2, 0x8004140000000000, 16
#define OPT_TX_STAT1_PL                            3, 0x80041c0000000000, 16
#define OPT_TX_FIR_PL                              4, 0x8004240000000000, 16
#define OPT_TX_FIR_MASK_PL                         5, 0x80042c0000000000, 16
#define OPT_TX_FIR_ERROR_INJECT_PL                 6, 0x8004340000000000, 16
#define OPT_TX_BIT_MODE1_E_PL                      7, 0x80043c0000000000, 16
#define OPT_TX_BIT_MODE2_E_PL                      8, 0x8004440000000000, 16
#define OPT_TX_CNTL2_O_PL                          9, 0x80044c0000000000, 16
#define OPT_TX_SPARE_MODE_PG                      10, 0x800c040000000000, 16
#define OPT_TX_ID1_PG                             11, 0x800c0c0000000000, 16
#define OPT_TX_CTL_MODE1_EO_PG                    12, 0x800c140000000000, 16
#define OPT_TX_CTL_MODE2_EO_PG                    13, 0x800c1c0000000000, 16
#define OPT_TX_CTL_CNTLG1_EO_PG                   14, 0x800c240000000000, 16
#define OPT_TX_CTL_CNTL2_EO_PG                    15, 0x800c2c0000000000, 16
#define OPT_TX_CTL_CNTL3_EO_PG                    16, 0x800c340000000000, 16
#define OPT_TX_CTL_STAT1_O_PG                     17, 0x800c840000000000, 16
#define OPT_TX_CTL_STAT2_O_PG                     18, 0x800c8c0000000000, 16
#define OPT_TX_FIR_PG                             19, 0x800d040000000000, 16
#define OPT_TX_FIR_MASK_PG                        20, 0x800d0c0000000000, 16
#define OPT_TX_FIR_RESET_PG                       21, 0x800d140000000000, 16
#define OPT_TX_FIR_ERROR_INJECT_PG                22, 0x800d1c0000000000, 16
#define OPT_TX_CTLSM_SPARE_MODE_PG                23, 0x800d240000000000, 16
#define OPT_TX_CTLSM_MODE1_EO_PG                  24, 0x800d2c0000000000, 16
#define OPT_TX_CTLSM_CNTL1_EO_PG                  25, 0x800d340000000000, 16
#define OPT_TX_CTLSM_CNTL2_EO_PG                  26, 0x800d3c0000000000, 16
#define OPT_TX_CTLSM_CNTL3_EO_PG                  27, 0x800d440000000000, 16
#define OPT_TX_CTLSM_CNTL4_EO_PG                  28, 0x800d4c0000000000, 16
#define OPT_TX_CTLSM_CNTL5_EO_PG                  29, 0x800d540000000000, 16
#define OPT_TX_CTLSM_CNTL6_EO_PG                  30, 0x800d5c0000000000, 16
#define OPT_TX_CTLSM_CNTL7_EO_PG                  31, 0x800d640000000000, 16
#define OPT_TX_CTLSM_STAT1_EO_PG                  32, 0x800d6c0000000000, 16
#define OPT_TX_CTLSM_CNTL1_O_PG                   33, 0x800d840000000000, 16
#define OPT_TX_CTLSM_CNTL2_O_PG                   34, 0x800d8c0000000000, 16
#define OPT_TX_IMPCAL_PB                          35, 0x800f040000000000, 16
#define OPT_TX_IMPCAL2_PB                         36, 0x800f3c0000000000, 16
#define OPT_TX_IMPCAL_NVAL_PB                     37, 0x800f0c0000000000, 16
#define OPT_TX_IMPCAL_PVAL_PB                     38, 0x800f140000000000, 16
#define OPT_TX_IMPCAL_P_4X_PB                     39, 0x800f1c0000000000, 16
#define OPT_TX_IMPCAL_SWO1_PB                     40, 0x800f240000000000, 16
#define OPT_TX_IMPCAL_SWO2_PB                     41, 0x800f2c0000000000, 16
#define OPT_SPARE_MODE_PB                         42, 0x800f340000000000, 16
#define OPT_RX_DATA_DAC_SPARE_MODE_PL             43, 0x8000000000000000, 16
#define OPT_RX_DAC_CNTL1_EO_PL                    44, 0x8000080000000000, 16
#define OPT_RX_DAC_CNTL2_EO_PL                    45, 0x8000100000000000, 16
#define OPT_RX_DAC_CNTL3_EO_PL                    46, 0x8000180000000000, 16
#define OPT_RX_DAC_CNTL4_EO_PL                    47, 0x8000200000000000, 16
#define OPT_RX_DAC_CNTL5_EO_PL                    48, 0x8000280000000000, 16
#define OPT_RX_DAC_CNTL6_EO_PL                    49, 0x8000300000000000, 16
#define OPT_RX_DAC_CNTL7_EO_PL                    50, 0x8000380000000000, 16
#define OPT_RX_DAC_CNTL8_EO_PL                    51, 0x8000400000000000, 16
#define OPT_RX_DAC_CNTL1_O_PL                     52, 0x8000800000000000, 16
#define OPT_RX_DAC_CNTL2_O_PL                     53, 0x8000880000000000, 16
#define OPT_RX_DAC_CNTL3_O_PL                     54, 0x8000900000000000, 16
#define OPT_RX_DAC_CNTL4_O_PL                     55, 0x8000980000000000, 16
#define OPT_RX_DAC_CNTL5_O_PL                     56, 0x8000a00000000000, 16
#define OPT_RX_DAC_CNTL6_O_PL                     57, 0x8000a80000000000, 16
#define OPT_RX_DAC_CNTL7_O_PL                     58, 0x8000b00000000000, 16
#define OPT_RX_DAC_CNTL8_O_PL                     59, 0x8000b80000000000, 16
#define OPT_RX_DAC_CNTL9_O_PL                     60, 0x8000c00000000000, 16
#define OPT_RX_DAC_CNTL10_O_PL                    61, 0x8000c80000000000, 16
#define OPT_RX_SPARE_MODE_PL                      62, 0x8002000000000000, 16
#define OPT_RX_FIR_PL                             63, 0x8002080000000000, 16
#define OPT_RX_FIR_MASK_PL                        64, 0x8002100000000000, 16
#define OPT_RX_FIR_ERROR_INJECT_PL                65, 0x8002180000000000, 16
#define OPT_RX_BIT_MODE1_EO_PL                    66, 0x8002200000000000, 16
#define OPT_RX_BIT_MODE2_EO_PL                    67, 0x8002280000000000, 16
#define OPT_RX_BIT_MODE3_EO_PL                    68, 0x8002300000000000, 16
#define OPT_RX_BIT_CNTLX1_EO_PL                   69, 0x8002380000000000, 16
#define OPT_RX_BIT_CNTL2_EO_PL                    70, 0x8002400000000000, 16
#define OPT_RX_BIT_CNTL3_EO_PL                    71, 0x8002480000000000, 16
#define OPT_RX_BIT_CNTL4_EO_PL                    72, 0x8002500000000000, 16
#define OPT_RX_BIT_STAT1_EO_PL                    73, 0x8002580000000000, 16
#define OPT_RX_BIT_STAT2_EO_PL                    74, 0x8002600000000000, 16
#define OPT_RX_BIT_STAT3_EO_PL                    75, 0x8002680000000000, 16
#define OPT_RX_BIT_STAT1_O_PL                     76, 0x8003180000000000, 16
#define OPT_RX_GLBSM_PL_CNTL1_O_PL                77, 0x8003200000000000, 16
#define OPT_RX_GLBSM_PL_STAT1_O_PL                78, 0x8003280000000000, 16
#define OPT_RX_GLBSM_PL_CNTL1X_O_PL               79, 0x8003300000000000, 16
#define OPT_RX_DATA_WORK_SPARE_MODE_PL            80, 0x8003800000000000, 16
#define OPT_RX_WORK_STAT1_EO_PL                   81, 0x8003880000000000, 16
#define OPT_RX_WORK_STAT2_EO_PL                   82, 0x8003900000000000, 16
#define OPT_RX_WORK_STAT3_EO_PL                   83, 0x8003980000000000, 16
#define OPT_RX_WORK_STAT4_EO_PL                   84, 0x8003a00000000000, 16
#define OPT_RX_SPARE_MODE_PG                      85, 0x8008000000000000, 16
#define OPT_RX_ID1_PG                             86, 0x8008080000000000, 16
#define OPT_RX_CTL_MODE1_EO_PG                    87, 0x8008100000000000, 16
#define OPT_RX_CTL_MODE2_EO_PG                    88, 0x8008180000000000, 16
#define OPT_RX_CTL_MODE5_EO_PG                    89, 0x8008300000000000, 16
#define OPT_RX_CTL_MODE6_EO_PG                    90, 0x8008380000000000, 16
#define OPT_RX_CTL_MODE7_EO_PG                    91, 0x8008400000000000, 16
#define OPT_RX_CTL_MODE8_EO_PG                    92, 0x8008480000000000, 16
#define OPT_RX_CTL_MODE9_EO_PG                    93, 0x8008500000000000, 16
#define OPT_RX_CTL_MODE10_EO_PG                   94, 0x8008580000000000, 16
#define OPT_RX_CTL_MODE11_EO_PG                   95, 0x8008600000000000, 16
#define OPT_RX_CTL_MODE12_EO_PG                   96, 0x8008680000000000, 16
#define OPT_RX_CTL_MODE13_EO_PG                   97, 0x8008700000000000, 16
#define OPT_RX_CTL_MODE14_EO_PG                   98, 0x8008780000000000, 16
#define OPT_RX_CTL_MODE15_EO_PG                   99, 0x8008800000000000, 16
#define OPT_RX_CTL_MODE16_EO_PG                  100, 0x8008880000000000, 16
#define OPT_RX_CTL_MODE17_EO_PG                  101, 0x8008900000000000, 16
#define OPT_RX_CTL_MODE18_EO_PG                  102, 0x8008980000000000, 16
#define OPT_RX_CTL_MODE19_EO_PG                  103, 0x8008a00000000000, 16
#define OPT_RX_CTL_MODE20_EO_PG                  104, 0x8008a80000000000, 16
#define OPT_RX_CTL_MODE21_EO_PG                  105, 0x8008b00000000000, 16
#define OPT_RX_CTL_MODE22_EO_PG                  106, 0x8008b80000000000, 16
#define OPT_RX_CTL_MODE23_EO_PG                  107, 0x8008c00000000000, 16
#define OPT_RX_CTL_MODE24_EO_PG                  108, 0x8008c80000000000, 16
#define OPT_RX_CTL_MODE29_EO_PG                  109, 0x8008d00000000000, 16
#define OPT_RX_CTL_CNTL1_EO_PG                   110, 0x8008d80000000000, 16
#define OPT_RX_CTL_CNTL2_EO_PG                   111, 0x8008e00000000000, 16
#define OPT_RX_CTL_CNTL3_EO_PG                   112, 0x8008e80000000000, 16
#define OPT_RX_CTL_CNTL4_EO_PG                   113, 0x8008f00000000000, 16
#define OPT_RX_CTL_CNTL5_EO_PG                   114, 0x8008f80000000000, 16
#define OPT_RX_CTL_CNTL6_EO_PG                   115, 0x8009000000000000, 16
#define OPT_RX_CTL_CNTLX7_EO_PG                  116, 0x8009080000000000, 16
#define OPT_RX_CTL_CNTL8_EO_PG                   117, 0x8009100000000000, 16
#define OPT_RX_CTL_CNTL9_EO_PG                   118, 0x8009180000000000, 16
#define OPT_RX_CTL_CNTL10_EO_PG                  119, 0x8009200000000000, 16
#define OPT_RX_CTL_CNTL11_EO_PG                  120, 0x8009280000000000, 16
#define OPT_RX_CTL_CNTL12_EO_PG                  121, 0x8009300000000000, 16
#define OPT_RX_CTL_CNTL13_EO_PG                  122, 0x8009380000000000, 16
#define OPT_RX_CTL_CNTL14_EO_PG                  123, 0x8009400000000000, 16
#define OPT_RX_CTL_CNTL15_EO_PG                  124, 0x8009480000000000, 16
#define OPT_RX_CTL_STAT1_EO_PG                   125, 0x8009500000000000, 16
#define OPT_RX_CTL_STAT2_EO_PG                   126, 0x8009580000000000, 16
#define OPT_RX_CTL_STAT3_EO_PG                   127, 0x8009600000000000, 16
#define OPT_RX_CTL_MODE26_EO_PG                  128, 0x8009680000000000, 16
#define OPT_RX_CTL_MODE27_EO_PG                  129, 0x8009700000000000, 16
#define OPT_RX_CTL_MODE28_EO_PG                  130, 0x8009780000000000, 16
#define OPT_RX_CTL_CNTL1_O_PG                    131, 0x8009800000000000, 16
#define OPT_RX_CTL_CNTL2_O_PG                    132, 0x8009880000000000, 16
#define OPT_RX_CTL_CNTL3_O_PG                    133, 0x8009900000000000, 16
#define OPT_RX_CTL_CNTL4_O_PG                    134, 0x8009980000000000, 16
#define OPT_RX_CTL_MODE1_O_PG                    135, 0x8009b00000000000, 16
#define OPT_RX_GLBSM_SPARE_MODE_PG               136, 0x800a800000000000, 16
#define OPT_RX_FIR1_PG                           137, 0x800a880000000000, 16
#define OPT_RX_FIR1_MASK_PG                      138, 0x800a900000000000, 16
#define OPT_RX_FIR1_ERROR_INJECT_PG              139, 0x800a980000000000, 16
#define OPT_RX_FIR_TRAINING_PG                   140, 0x800aa00000000000, 16
#define OPT_RX_FIR_TRAINING_MASK_PG              141, 0x800aa80000000000, 16
#define OPT_RX_GLBSM_CNTL1_EO_PG                 142, 0x800ab00000000000, 16
#define OPT_RX_GLBSM_STAT1_EO_PG                 143, 0x800ab80000000000, 16
#define OPT_RX_GLBSM_STAT2_EO_PG                 144, 0x800ac00000000000, 16
#define OPT_RX_GLBSM_STAT3_EO_PG                 145, 0x800ac80000000000, 16
#define OPT_RX_GLBSM_STAT4_EO_PG                 146, 0x800ad00000000000, 16
#define OPT_RX_DATASM_SPARE_MODE_PG              147, 0x800b800000000000, 16
#define OPT_RX_DATASM_CNTLX1_EO_PG               148, 0x800b880000000000, 16
#define OPT_RX_DATASM_STAT1_EO_PG                149, 0x800b900000000000, 16
#define OPT_RX_DATASM_STAT2_EO_PG                150, 0x800b980000000000, 16
#define OPT_RX_DATASM_STAT3_EO_PG                151, 0x800ba00000000000, 16
#define OPT_RX_DATASM_STAT4_EO_PG                152, 0x800ba80000000000, 16
#define OPT_RX_DATASM_STAT5_EO_PG                153, 0x800bb00000000000, 16
#define OPT_RX_DATASM_STAT6_EO_PG                154, 0x800bb80000000000, 16
#define OPT_RX_DATASM_STAT7_EO_PG                155, 0x800bc00000000000, 16
#define OPT_RX_DATASM_STAT8_EO_PG                156, 0x800bc80000000000, 16
#define OPT_RX_DATASM_STAT9_EO_PG                157, 0x800bd00000000000, 16
#define OPT_RX_DATASM_STAT10_EO_PG               158, 0x800bd80000000000, 16
#define OPT_RX_DATASM_STAT11_EO_PG               159, 0x800be00000000000, 16
#define OPT_RX_FIR_RESET_PB                      160, 0x800f800000000000, 16
#define OPT_RX_FIR_PB                            161, 0x800f880000000000, 16
#define OPT_RX_FIR_MASK_PB                       162, 0x800f900000000000, 16
#define OPT_RX_FIR_ERROR_INJECT_PB               163, 0x800f980000000000, 16
#define OPT_RX_INTR_MSG_PB                       164, 0x800ff00000000000, 16
#define OPT_RX_FIR_MSG_PB                        165, 0x800ff80000000000, 16
#define OPT_SCOM_MODE_PB                         166, 0x20, 64
#define OPT_SCOM_FIR_PB                          167, 0x0, 64
#define OPT_SCOM_FIR_CLR_PB                      168, 0x1, 64
#define OPT_SCOM_FIR_SET_PB                      169, 0x2, 64
#define OPT_SCOM_FIR_MASK_PB                     170, 0x3, 64
#define OPT_SCOM_FIR_MASK_CLR_PB                 171, 0x4, 64
#define OPT_SCOM_FIR_MASK_SET_PB                 172, 0x5, 64
#define OPT_SCOM_FIR_ACTION0_PB                  173, 0x6, 64
#define OPT_SCOM_FIR_ACTION1_PB                  174, 0x7, 64
#define OPT_SCOM_FIR_WOF_PB                      175, 0x8, 64
#define OPT_SCOM_PPE_XCR_NONE                    176, 0xa, 64
#define OPT_SCOM_PPE_XCR_SPRG0                   177, 0xb, 64
#define OPT_SCOM_PPE_IR_SPRG0                    178, 0xc, 64
#define OPT_SCOM_PPE_XSR_SPRG0                   179, 0xd, 64
#define OPT_SCOM_PPE_IR_EDR                      180, 0xe, 64
#define OPT_SCOM_PPE_XSR_IAR                     181, 0xf, 64
#define OPT_SCOM_PPE_MEM_ARB_CSAR                182, 0x18, 64
#define OPT_SCOM_PPE_MEM_ARB_CSDR                183, 0x19, 64
#define OPT_SCOM_PPE_MEM_ARB_SCR                 184, 0x15, 64
#define OPT_SCOM_PPE_CNTL                        185, 0x20, 64
#define OPT_SCOM_PPE_WORK_REG1                   186, 0x21, 64
#define OPT_SCOM_PPE_WORK_REG2                   187, 0x22, 64
#define OPT_SCOM_PPE_FLAGS_REG                   188, 0x23, 64
#define OPT_SCOM_PPE_FLAGS_SET_REG               189, 0x24, 64
#define OPT_SCOM_PPE_FLAGS_CLR_REG               190, 0x25, 64
#define EDI_TX_MODE_PL                           191, 0x8004040000000000, 16
#define EDI_TX_CNTL_STAT_PL                      192, 0x80040c0000000000, 16
#define EDI_TX_SPARE_MODE_PL                     193, 0x8004140000000000, 16
#define EDI_TX_BIST_STAT_PL                      194, 0x80042c0000000000, 16
#define EDI_TX_PRBS_MODE_PL                      195, 0x8004340000000000, 16
#define EDI_TX_DATA_CNTL_GCRMSG_PL               196, 0x80043c0000000000, 16
#define EDI_TX_SYNC_PATTERN_GCRMSG_PL            197, 0x8004440000000000, 16
#define EDI_TX_FIR_PL                            198, 0x8004540000000000, 16
#define EDI_TX_FIR_MASK_PL                       199, 0x80045c0000000000, 16
#define EDI_TX_FIR_ERROR_INJECT_PL               200, 0x8004640000000000, 16
#define EDI_TX_MODE_FAST_PL                      201, 0x80046c0000000000, 16
#define EDI_TX_TDR_STAT_PL                       202, 0x8004740000000000, 16
#define EDI_TX_CNTL_GCRMSG_PL                    203, 0x80047c0000000000, 16
#define EDI_TX_CLK_MODE_PG                       204, 0x800c040000000000, 16
#define EDI_TX_SPARE_MODE_PG                     205, 0x800c0c0000000000, 16
#define EDI_TX_CNTL_STAT_PG                      206, 0x800c140000000000, 16
#define EDI_TX_MODE_PG                           207, 0x800c1c0000000000, 16
#define EDI_TX_RESET_ACT_PG                      208, 0x800c440000000000, 16
#define EDI_TX_BIST_STAT_PG                      209, 0x800c4c0000000000, 16
#define EDI_TX_FIR_PG                            210, 0x800c540000000000, 16
#define EDI_TX_FIR_MASK_PG                       211, 0x800c5c0000000000, 16
#define EDI_TX_FIR_ERROR_INJECT_PG               212, 0x800c640000000000, 16
#define EDI_TX_ID1_PG                            213, 0x800c940000000000, 16
#define EDI_TX_ID2_PG                            214, 0x800c9c0000000000, 16
#define EDI_TX_ID3_PG                            215, 0x800ca40000000000, 16
#define EDI_TX_CLK_CNTL_GCRMSG_PG                216, 0x800cc40000000000, 16
#define EDI_TX_FFE_MODE_PG                       217, 0x800ccc0000000000, 16
#define EDI_TX_FFE_MAIN_PG                       218, 0x800cd40000000000, 16
#define EDI_TX_FFE_POST_PG                       219, 0x800cdc0000000000, 16
#define EDI_TX_FFE_MARGIN_PG                     220, 0x800ce40000000000, 16
#define EDI_TX_BAD_LANE_ENC_GCRMSG_PG            221, 0x800cec0000000000, 16
#define EDI_TX_BER_CNTL_PG                       222, 0x800cf40000000000, 16
#define EDI_TX_SLS_LANE_ENC_GCRMSG_PG            223, 0x800cfc0000000000, 16
#define EDI_TX_WT_SEG_ENABLE_PG                  224, 0x800d040000000000, 16
#define EDI_TX_LANE_DISABLED_VEC_0_15_PG         225, 0x800d1c0000000000, 16
#define EDI_TX_LANE_DISABLED_VEC_16_31_PG        226, 0x800d240000000000, 16
#define EDI_TX_SLS_LANE_MUX_GCRMSG_PG            227, 0x800d2c0000000000, 16
#define EDI_TX_DYN_RPR_PG                        228, 0x800d340000000000, 16
#define EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG       229, 0x800d3c0000000000, 16
#define EDI_TX_WIRETEST_PP                       230, 0x800e840000000000, 16
#define EDI_TX_MODE_PP                           231, 0x800e8c0000000000, 16
#define EDI_TX_SLS_GCRMSG_PP                     232, 0x800e940000000000, 16
#define EDI_TX_BER_CNTL_A_PP                     233, 0x800e9c0000000000, 16
#define EDI_TX_BER_CNTL_B_PP                     234, 0x800ea40000000000, 16
#define EDI_TX_DYN_RECAL_TIMEOUTS_PP             235, 0x800eac0000000000, 16
#define EDI_TX_BIST_CNTL_PP                      236, 0x800eb40000000000, 16
#define EDI_TX_BER_CNTL_SLS_PP                   237, 0x800ebc0000000000, 16
#define EDI_TX_CNTL_PP                           238, 0x800ec40000000000, 16
#define EDI_TX_RESET_CFG_PP                      239, 0x800ecc0000000000, 16
#define EDI_TX_TDR_CNTL1_PP                      240, 0x800ed40000000000, 16
#define EDI_TX_TDR_CNTL2_PP                      241, 0x800edc0000000000, 16
#define EDI_TX_TDR_CNTL3_PP                      242, 0x800ee40000000000, 16
#define EDI_TX_IMPCAL_PB                         243, 0x800f040000000000, 16
#define EDI_TX_IMPCAL_NVAL_PB                    244, 0x800f0c0000000000, 16
#define EDI_TX_IMPCAL_PVAL_PB                    245, 0x800f140000000000, 16
#define EDI_TX_IMPCAL_P_4X_PB                    246, 0x800f1c0000000000, 16
#define EDI_TX_IMPCAL_SWO1_PB                    247, 0x800f240000000000, 16
#define EDI_TX_IMPCAL_SWO2_PB                    248, 0x800f2c0000000000, 16
#define EDI_TX_ANALOG_IREF_PB                    249, 0x800f340000000000, 16
#define EDI_TX_MINIKERF_PB                       250, 0x800f3c0000000000, 16
#define EDI_TX_INIT_VERSION_PB                   251, 0x800f440000000000, 16
#define EDI_TX_SCRATCH_REG_PB                    252, 0x800f4c0000000000, 16
#define EDI_RX_MODE_PL                           253, 0x8000000000000000, 16
#define EDI_RX_CNTL_PL                           254, 0x8000080000000000, 16
#define EDI_RX_SPARE_MODE_PL                     255, 0x8000100000000000, 16
#define EDI_RX_PROT_EDGE_STATUS_PL               256, 0x8000180000000000, 16
#define EDI_RX_BIST_STAT_PL                      257, 0x8000280000000000, 16
#define EDI_RX_OFFSET_EVEN_PL                    258, 0x8000400000000000, 16
#define EDI_RX_OFFSET_ODD_PL                     259, 0x8000480000000000, 16
#define EDI_RX_AMP_VAL_PL                        260, 0x8000500000000000, 16
#define EDI_RX_AMP_CNTL_PL                       261, 0x8000580000000000, 16
#define EDI_RX_PROT_STATUS_PL                    262, 0x8000600000000000, 16
#define EDI_RX_PROT_MODE_PL                      263, 0x8000680000000000, 16
#define EDI_RX_PROT_CNTL_PL                      264, 0x8000700000000000, 16
#define EDI_RX_FIFO_STAT_PL                      265, 0x8000780000000000, 16
#define EDI_RX_AP_PL                             266, 0x8000800000000000, 16
#define EDI_RX_AN_PL                             267, 0x8000880000000000, 16
#define EDI_RX_AMIN_PL                           268, 0x8000900000000000, 16
#define EDI_RX_H1_EVEN_PL                        269, 0x8000980000000000, 16
#define EDI_RX_H1_ODD_PL                         270, 0x8000a00000000000, 16
#define EDI_RX_PRBS_MODE_PL                      271, 0x8000b00000000000, 16
#define EDI_RX_STAT_PL                           272, 0x8000c00000000000, 16
#define EDI_RX_DESKEW_STAT_PL                    273, 0x8000c80000000000, 16
#define EDI_RX_FIR_PL                            274, 0x8000d00000000000, 16
#define EDI_RX_FIR_MASK_PL                       275, 0x8000d80000000000, 16
#define EDI_RX_FIR_ERROR_INJECT_PL               276, 0x8000e00000000000, 16
#define EDI_RX_SLS_PL                            277, 0x8000e80000000000, 16
#define EDI_RX_WT_STATUS_PL                      278, 0x8000f00000000000, 16
#define EDI_RX_FIFO_CNTL_PL                      279, 0x8000f80000000000, 16
#define EDI_RX_BER_STATUS_PL                     280, 0x8001000000000000, 16
#define EDI_RX_BER_TIMER_0_15_PL                 281, 0x8001080000000000, 16
#define EDI_RX_BER_TIMER_16_31_PL                282, 0x8001100000000000, 16
#define EDI_RX_BER_TIMER_32_39_PL                283, 0x8001180000000000, 16
#define EDI_RX_SERVO_CNTL_PL                     284, 0x8001200000000000, 16
#define EDI_RX_FIFO_DIAG_0_15_PL                 285, 0x8001280000000000, 16
#define EDI_RX_FIFO_DIAG_16_31_PL                286, 0x8001300000000000, 16
#define EDI_RX_FIFO_DIAG_32_47_PL                287, 0x8001380000000000, 16
#define EDI_RX_EYE_WIDTH_STATUS_PL               288, 0x8001400000000000, 16
#define EDI_RX_EYE_WIDTH_CNTL_PL                 289, 0x8001480000000000, 16
#define EDI_RX_DFE_CLKADJ_PL                     290, 0x8001500000000000, 16
#define EDI_RX_TRACE_PL                          291, 0x8001580000000000, 16
#define EDI_RX_SERVO_BER_COUNT_PL                292, 0x8001600000000000, 16
#define EDI_RX_EYE_OPT_STAT_PL                   293, 0x8001680000000000, 16
#define EDI_RX_CLK_MODE_PG                       294, 0x8008000000000000, 16
#define EDI_RX_SPARE_MODE_PG                     295, 0x8008080000000000, 16
#define EDI_RX_STOP_CNTL_STAT_PG                 296, 0x8008100000000000, 16
#define EDI_RX_MODE_PG                           297, 0x8008180000000000, 16
#define EDI_RX_STOP_ADDR_LSB_PG                  298, 0x8008380000000000, 16
#define EDI_RX_STOP_MASK_LSB_PG                  299, 0x8008400000000000, 16
#define EDI_RX_RESET_ACT_PG                      300, 0x8008480000000000, 16
#define EDI_RX_ID1_PG                            301, 0x8008500000000000, 16
#define EDI_RX_ID2_PG                            302, 0x8008580000000000, 16
#define EDI_RX_ID3_PG                            303, 0x8008600000000000, 16
#define EDI_RX_MINIKERF_PG                       304, 0x8008680000000000, 16
#define EDI_RX_DYN_RPR_DEBUG2_PG                 305, 0x8008700000000000, 16
#define EDI_RX_SLS_MODE_PG                       306, 0x8008780000000000, 16
#define EDI_RX_TRAINING_START_PG                 307, 0x8008800000000000, 16
#define EDI_RX_TRAINING_STATUS_PG                308, 0x8008880000000000, 16
#define EDI_RX_RECAL_STATUS_PG                   309, 0x8008900000000000, 16
#define EDI_RX_TIMEOUT_SEL_PG                    310, 0x8008980000000000, 16
#define EDI_RX_FIFO_MODE_PG                      311, 0x8008a00000000000, 16
#define EDI_RX_SLS_STATUS_PG                     312, 0x8008b80000000000, 16
#define EDI_RX_DYN_RPR_MODE_PG                   313, 0x8008c00000000000, 16
#define EDI_RX_FIR1_PG                           314, 0x8008d00000000000, 16
#define EDI_RX_FIR2_PG                           315, 0x8008d80000000000, 16
#define EDI_RX_FIR1_MASK_PG                      316, 0x8008e00000000000, 16
#define EDI_RX_FIR2_MASK_PG                      317, 0x8008e80000000000, 16
#define EDI_RX_FIR1_ERROR_INJECT_PG              318, 0x8008f00000000000, 16
#define EDI_RX_FIR2_ERROR_INJECT_PG              319, 0x8008f80000000000, 16
#define EDI_RX_FIR_TRAINING_PG                   320, 0x8009000000000000, 16
#define EDI_RX_FIR_TRAINING_MASK_PG              321, 0x8009080000000000, 16
#define EDI_RX_TIMEOUT_SEL1_PG                   322, 0x8009100000000000, 16
#define EDI_RX_LANE_BAD_VEC_0_15_PG              323, 0x8009180000000000, 16
#define EDI_RX_LANE_BAD_VEC_16_31_PG             324, 0x8009200000000000, 16
#define EDI_RX_LANE_DISABLED_VEC_0_15_PG         325, 0x8009280000000000, 16
#define EDI_RX_LANE_DISABLED_VEC_16_31_PG        326, 0x8009300000000000, 16
#define EDI_RX_LANE_SWAPPED_VEC_0_15_PG          327, 0x8009380000000000, 16
#define EDI_RX_LANE_SWAPPED_VEC_16_31_PG         328, 0x8009400000000000, 16
#define EDI_RX_INIT_STATE_PG                     329, 0x8009480000000000, 16
#define EDI_RX_WIRETEST_STATE_PG                 330, 0x8009500000000000, 16
#define EDI_RX_WIRETEST_LANEINFO_PG              331, 0x8009580000000000, 16
#define EDI_RX_WIRETEST_GCRMSG_PG                332, 0x8009600000000000, 16
#define EDI_RX_DESKEW_GCRMSG_PG                  333, 0x8009680000000000, 16
#define EDI_RX_DESKEW_STATE_PG                   334, 0x8009700000000000, 16
#define EDI_RX_DESKEW_MODE_PG                    335, 0x8009780000000000, 16
#define EDI_RX_DESKEW_STATUS_PG                  336, 0x8009800000000000, 16
#define EDI_RX_BAD_LANE_ENC_GCRMSG_PG            337, 0x8009880000000000, 16
#define EDI_RX_STATIC_REPAIR_STATE_PG            338, 0x8009900000000000, 16
#define EDI_RX_TX_BUS_INFO_PG                    339, 0x8009980000000000, 16
#define EDI_RX_SLS_LANE_ENC_GCRMSG_PG            340, 0x8009a00000000000, 16
#define EDI_RX_FENCE_PG                          341, 0x8009a80000000000, 16
#define EDI_RX_TIMEOUT_SEL2_PG                   342, 0x8009b80000000000, 16
#define EDI_RX_MISC_ANALOG_PG                    343, 0x8009c00000000000, 16
#define EDI_RX_DYN_RPR_PG                        344, 0x8009c80000000000, 16
#define EDI_RX_DYN_RPR_GCRMSG_PG                 345, 0x8009d00000000000, 16
#define EDI_RX_DYN_RPR_ERR_TALLYING1_PG          346, 0x8009d80000000000, 16
#define EDI_RX_EO_FINAL_L2U_GCRMSG_PG            347, 0x8009e00000000000, 16
#define EDI_RX_GCR_MSG_DEBUG_DEST_IDS_PG         348, 0x8009e80000000000, 16
#define EDI_RX_GCR_MSG_DEBUG_SRC_IDS_PG          349, 0x8009f00000000000, 16
#define EDI_RX_GCR_MSG_DEBUG_DEST_ADDR_PG        350, 0x8009f80000000000, 16
#define EDI_RX_GCR_MSG_DEBUG_WRITE_DATA_PG       351, 0x800a000000000000, 16
#define EDI_RX_DYN_RECAL_PG                      352, 0x800a080000000000, 16
#define EDI_RX_WT_CLK_STATUS_PG                  353, 0x800a100000000000, 16
#define EDI_RX_DYN_RECAL_CONFIG_PG               354, 0x800a180000000000, 16
#define EDI_RX_WT_CONFIG_PG                      355, 0x800a200000000000, 16
#define EDI_RX_DYN_RECAL_GCRMSG_PG               356, 0x800a280000000000, 16
#define EDI_RX_WIRETEST_PLL_CNTL_PG              357, 0x800a300000000000, 16
#define EDI_RX_EO_STEP_CNTL_PG                   358, 0x800a380000000000, 16
#define EDI_RX_EO_STEP_STAT_PG                   359, 0x800a400000000000, 16
#define EDI_RX_EO_STEP_FAIL_PG                   360, 0x800a480000000000, 16
#define EDI_RX_AP_PG                             361, 0x800a500000000000, 16
#define EDI_RX_AN_PG                             362, 0x800a580000000000, 16
#define EDI_RX_AMIN_PG                           363, 0x800a600000000000, 16
#define EDI_RX_AMAX_PG                           364, 0x800a680000000000, 16
#define EDI_RX_AMP_VAL_PG                        365, 0x800a700000000000, 16
#define EDI_RX_AMP_OFFSET_PG                     366, 0x800a780000000000, 16
#define EDI_RX_EO_CONVERGENCE_PG                 367, 0x800a800000000000, 16
#define EDI_RX_SLS_RCVY_PG                       368, 0x800a880000000000, 16
#define EDI_RX_SLS_RCVY_GCRMSG_PG                369, 0x800a900000000000, 16
#define EDI_RX_TX_LANE_INFO_GCRMSG_PG            370, 0x800a980000000000, 16
#define EDI_RX_ERR_TALLYING_GCRMSG_PG            371, 0x800aa00000000000, 16
#define EDI_RX_TRACE_PG                          372, 0x800aa80000000000, 16
#define EDI_RX_RC_STEP_CNTL_PG                   373, 0x800ab80000000000, 16
#define EDI_RX_EO_RECAL_PG                       374, 0x800ac00000000000, 16
#define EDI_RX_SERVO_BER_COUNT_PG                375, 0x800ac80000000000, 16
#define EDI_RX_FUNC_STATE_PG                     376, 0x800ad00000000000, 16
#define EDI_RX_DYN_RPR_DEBUG_PG                  377, 0x800ad80000000000, 16
#define EDI_RX_DYN_RPR_ERR_TALLYING2_PG          378, 0x800ae00000000000, 16
#define EDI_RX_RESULT_CHK_PG                     379, 0x800ae80000000000, 16
#define EDI_RX_BER_CHK_PG                        380, 0x800af00000000000, 16
#define EDI_RX_SLS_RCVY_FIN_GCRMSG_PG            381, 0x800af80000000000, 16
#define EDI_RX_MODE1_PP                          382, 0x800b080000000000, 16
#define EDI_RX_CNTL_FAST_PP                      383, 0x800b100000000000, 16
#define EDI_RX_DYN_RECAL_TIMEOUTS_PP             384, 0x800b400000000000, 16
#define EDI_RX_BER_CNTL_PP                       385, 0x800b500000000000, 16
#define EDI_RX_BER_MODE_PP                       386, 0x800b580000000000, 16
#define EDI_RX_SERVO_TO1_PP                      387, 0x800b600000000000, 16
#define EDI_RX_SERVO_TO2_PP                      388, 0x800b680000000000, 16
#define EDI_RX_SERVO_TO3_PP                      389, 0x800b700000000000, 16
#define EDI_RX_DFE_CONFIG_PP                     390, 0x800b780000000000, 16
#define EDI_RX_DFE_TIMERS_PP                     391, 0x800b800000000000, 16
#define EDI_RX_RESET_CFG_PP                      392, 0x800b880000000000, 16
#define EDI_RX_RECAL_TO1_PP                      393, 0x800b900000000000, 16
#define EDI_RX_RECAL_TO2_PP                      394, 0x800b980000000000, 16
#define EDI_RX_RECAL_TO3_PP                      395, 0x800ba00000000000, 16
#define EDI_RX_MODE2_PP                          396, 0x800bb00000000000, 16
#define EDI_RX_BIST_GCRMSG_PP                    397, 0x800bb80000000000, 16
#define EDI_RX_SCOPE_CNTL_PP                     398, 0x800bc00000000000, 16
#define EDI_RX_MODE3_PP                          399, 0x800bc80000000000, 16
#define EDI_RX_FIR_RESET_PB                      400, 0x800f800000000000, 16
#define EDI_RX_FIR_PB                            401, 0x800f880000000000, 16
#define EDI_RX_FIR_MASK_PB                       402, 0x800f900000000000, 16
#define EDI_RX_FIR_ERROR_INJECT_PB               403, 0x800f980000000000, 16
#define EDI_RX_FIR_MSG_PB                        404, 0x800ff80000000000, 16
#define EDI_SCOM_MODE_PB                         405, 0x20, 64
#define EDI_SCOM_FIR_PB                          406, 0x0, 64
#define EDI_SCOM_FIR_CLR_PB                      407, 0x1, 64
#define EDI_SCOM_FIR_SET_PB                      408, 0x2, 64
#define EDI_SCOM_FIR_MASK_PB                     409, 0x3, 64
#define EDI_SCOM_FIR_MASK_CLR_PB                 410, 0x4, 64
#define EDI_SCOM_FIR_MASK_SET_PB                 411, 0x5, 64
#define EDI_SCOM_FIR_ACTION0_PB                  412, 0x6, 64
#define EDI_SCOM_FIR_ACTION1_PB                  413, 0x7, 64
#define EDI_SCOM_FIR_WOF_PB                      414, 0x8, 64
#define EI4_TX_MODE_PL                           415, 0x8004040000000000, 16
#define EI4_TX_CNTL_STAT_PL                      416, 0x80040c0000000000, 16
#define EI4_TX_SPARE_MODE_PL                     417, 0x8004140000000000, 16
#define EI4_TX_BIST_STAT_PL                      418, 0x80042c0000000000, 16
#define EI4_TX_PRBS_MODE_PL                      419, 0x8004340000000000, 16
#define EI4_TX_DATA_CNTL_GCRMSG_PL               420, 0x80043c0000000000, 16
#define EI4_TX_SYNC_PATTERN_GCRMSG_PL            421, 0x8004440000000000, 16
#define EI4_TX_FIR_PL                            422, 0x8004540000000000, 16
#define EI4_TX_FIR_MASK_PL                       423, 0x80045c0000000000, 16
#define EI4_TX_FIR_ERROR_INJECT_PL               424, 0x8004640000000000, 16
#define EI4_TX_MODE_FAST_PL                      425, 0x80046c0000000000, 16
#define EI4_TX_TDR_STAT_PL                       426, 0x8004740000000000, 16
#define EI4_TX_CLK_MODE_PG                       427, 0x800c040000000000, 16
#define EI4_TX_SPARE_MODE_PG                     428, 0x800c0c0000000000, 16
#define EI4_TX_CNTL_STAT_PG                      429, 0x800c140000000000, 16
#define EI4_TX_MODE_PG                           430, 0x800c1c0000000000, 16
#define EI4_TX_RESET_ACT_PG                      431, 0x800c440000000000, 16
#define EI4_TX_BIST_STAT_PG                      432, 0x800c4c0000000000, 16
#define EI4_TX_FIR_PG                            433, 0x800c540000000000, 16
#define EI4_TX_FIR_MASK_PG                       434, 0x800c5c0000000000, 16
#define EI4_TX_FIR_ERROR_INJECT_PG               435, 0x800c640000000000, 16
#define EI4_TX_ID1_PG                            436, 0x800c940000000000, 16
#define EI4_TX_ID2_PG                            437, 0x800c9c0000000000, 16
#define EI4_TX_ID3_PG                            438, 0x800ca40000000000, 16
#define EI4_TX_CLK_CNTL_GCRMSG_PG                439, 0x800cc40000000000, 16
#define EI4_TX_BAD_LANE_ENC_GCRMSG_PG            440, 0x800cec0000000000, 16
#define EI4_TX_BER_CNTL_PG                       441, 0x800cf40000000000, 16
#define EI4_TX_SLS_LANE_ENC_GCRMSG_PG            442, 0x800cfc0000000000, 16
#define EI4_TX_WT_SEG_ENABLE_PG                  443, 0x800d040000000000, 16
#define EI4_TX_PC_FFE_PG                         444, 0x800d0c0000000000, 16
#define EI4_TX_MISC_ANALOG_PG                    445, 0x800d140000000000, 16
#define EI4_TX_LANE_DISABLED_VEC_0_15_PG         446, 0x800d1c0000000000, 16
#define EI4_TX_LANE_DISABLED_VEC_16_31_PG        447, 0x800d240000000000, 16
#define EI4_TX_SLS_LANE_MUX_GCRMSG_PG            448, 0x800d2c0000000000, 16
#define EI4_TX_DYN_RPR_PG                        449, 0x800d340000000000, 16
#define EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG       450, 0x800d3c0000000000, 16
#define EI4_TX_RDT_CNTL_PG                       451, 0x800d440000000000, 16
#define EI4_RX_DLL_CAL_CNTL_PG                   452, 0x800e380000000000, 16
#define EI4_RX_DLL1_SETPOINT1_PG                 453, 0x800e400000000000, 16
#define EI4_RX_DLL1_SETPOINT2_PG                 454, 0x800e480000000000, 16
#define EI4_RX_DLL1_SETPOINT3_PG                 455, 0x800e500000000000, 16
#define EI4_RX_DLL2_SETPOINT1_PG                 456, 0x800e580000000000, 16
#define EI4_RX_DLL2_SETPOINT2_PG                 457, 0x800e600000000000, 16
#define EI4_RX_DLL2_SETPOINT3_PG                 458, 0x800e680000000000, 16
#define EI4_RX_DLL_FILTER_MODE_PG                459, 0x800e700000000000, 16
#define EI4_RX_DLL_ANALOG_TWEAKS_PG              460, 0x800e780000000000, 16
#define EI4_TX_WIRETEST_PP                       461, 0x800e840000000000, 16
#define EI4_TX_MODE_PP                           462, 0x800e8c0000000000, 16
#define EI4_TX_SLS_GCRMSG_PP                     463, 0x800e940000000000, 16
#define EI4_TX_BER_CNTL_A_PP                     464, 0x800e9c0000000000, 16
#define EI4_TX_BER_CNTL_B_PP                     465, 0x800ea40000000000, 16
#define EI4_TX_BIST_CNTL_PP                      466, 0x800eb40000000000, 16
#define EI4_TX_BER_CNTL_SLS_PP                   467, 0x800ebc0000000000, 16
#define EI4_TX_CNTL_PP                           468, 0x800ec40000000000, 16
#define EI4_TX_RESET_CFG_PP                      469, 0x800ecc0000000000, 16
#define EI4_TX_TDR_CNTL1_PP                      470, 0x800ed40000000000, 16
#define EI4_TX_TDR_CNTL2_PP                      471, 0x800edc0000000000, 16
#define EI4_TX_TDR_CNTL3_PP                      472, 0x800ee40000000000, 16
#define EI4_TX_INIT_VERSION_PB                   473, 0x800f440000000000, 16
#define EI4_TX_SCRATCH_REG_PB                    474, 0x800f4c0000000000, 16
#define EI4_RX_MODE_PL                           475, 0x8000000000000000, 16
#define EI4_RX_CNTL_PL                           476, 0x8000080000000000, 16
#define EI4_RX_SPARE_MODE_PL                     477, 0x8000100000000000, 16
#define EI4_RX_PROT_EDGE_STATUS_PL               478, 0x8000180000000000, 16
#define EI4_RX_BIST_STAT_PL                      479, 0x8000280000000000, 16
#define EI4_RX_OFFSET_EVEN_PL                    480, 0x8000400000000000, 16
#define EI4_RX_OFFSET_ODD_PL                     481, 0x8000480000000000, 16
#define EI4_RX_AMP_VAL_PL                        482, 0x8000500000000000, 16
#define EI4_RX_PROT_STATUS_PL                    483, 0x8000600000000000, 16
#define EI4_RX_PROT_MODE_PL                      484, 0x8000680000000000, 16
#define EI4_RX_PROT_CNTL_PL                      485, 0x8000700000000000, 16
#define EI4_RX_FIFO_STAT_PL                      486, 0x8000780000000000, 16
#define EI4_RX_PRBS_MODE_PL                      487, 0x8000b00000000000, 16
#define EI4_RX_VREF_PL                           488, 0x8000b80000000000, 16
#define EI4_RX_STAT_PL                           489, 0x8000c00000000000, 16
#define EI4_RX_DESKEW_STAT_PL                    490, 0x8000c80000000000, 16
#define EI4_RX_FIR_PL                            491, 0x8000d00000000000, 16
#define EI4_RX_FIR_MASK_PL                       492, 0x8000d80000000000, 16
#define EI4_RX_FIR_ERROR_INJECT_PL               493, 0x8000e00000000000, 16
#define EI4_RX_SLS_PL                            494, 0x8000e80000000000, 16
#define EI4_RX_WT_STATUS_PL                      495, 0x8000f00000000000, 16
#define EI4_RX_FIFO_CNTL_PL                      496, 0x8000f80000000000, 16
#define EI4_RX_BER_STATUS_PL                     497, 0x8001000000000000, 16
#define EI4_RX_BER_TIMER_0_15_PL                 498, 0x8001080000000000, 16
#define EI4_RX_BER_TIMER_16_31_PL                499, 0x8001100000000000, 16
#define EI4_RX_BER_TIMER_32_39_PL                500, 0x8001180000000000, 16
#define EI4_RX_SERVO_CNTL_PL                     501, 0x8001200000000000, 16
#define EI4_RX_FIFO_DIAG_0_15_PL                 502, 0x8001280000000000, 16
#define EI4_RX_FIFO_DIAG_16_31_PL                503, 0x8001300000000000, 16
#define EI4_RX_FIFO_DIAG_32_47_PL                504, 0x8001380000000000, 16
#define EI4_RX_EYE_WIDTH_STATUS_PL               505, 0x8001400000000000, 16
#define EI4_RX_EYE_WIDTH_CNTL_PL                 506, 0x8001480000000000, 16
#define EI4_RX_TRACE_PL                          507, 0x8001580000000000, 16
#define EI4_RX_SERVO_BER_COUNT_PL                508, 0x8001600000000000, 16
#define EI4_RX_EYE_OPT_STAT_PL                   509, 0x8001680000000000, 16
#define EI4_RX_DCD_ADJ_PL                        510, 0x8001700000000000, 16
#define EI4_RX_CLK_MODE_PG                       511, 0x8008000000000000, 16
#define EI4_RX_SPARE_MODE_PG                     512, 0x8008080000000000, 16
#define EI4_RX_STOP_CNTL_STAT_PG                 513, 0x8008100000000000, 16
#define EI4_RX_MODE_PG                           514, 0x8008180000000000, 16
#define EI4_RX_STOP_ADDR_LSB_PG                  515, 0x8008380000000000, 16
#define EI4_RX_STOP_MASK_LSB_PG                  516, 0x8008400000000000, 16
#define EI4_RX_RESET_ACT_PG                      517, 0x8008480000000000, 16
#define EI4_RX_ID1_PG                            518, 0x8008500000000000, 16
#define EI4_RX_ID2_PG                            519, 0x8008580000000000, 16
#define EI4_RX_ID3_PG                            520, 0x8008600000000000, 16
#define EI4_RX_DYN_RPR_DEBUG2_PG                 521, 0x8008700000000000, 16
#define EI4_RX_SLS_MODE_PG                       522, 0x8008780000000000, 16
#define EI4_RX_TRAINING_START_PG                 523, 0x8008800000000000, 16
#define EI4_RX_TRAINING_STATUS_PG                524, 0x8008880000000000, 16
#define EI4_RX_RECAL_STATUS_PG                   525, 0x8008900000000000, 16
#define EI4_RX_TIMEOUT_SEL_PG                    526, 0x8008980000000000, 16
#define EI4_RX_FIFO_MODE_PG                      527, 0x8008a00000000000, 16
#define EI4_RX_SLS_STATUS_PG                     528, 0x8008b80000000000, 16
#define EI4_RX_DYN_RPR_MODE_PG                   529, 0x8008c00000000000, 16
#define EI4_RX_FIR1_PG                           530, 0x8008d00000000000, 16
#define EI4_RX_FIR2_PG                           531, 0x8008d80000000000, 16
#define EI4_RX_FIR1_MASK_PG                      532, 0x8008e00000000000, 16
#define EI4_RX_FIR2_MASK_PG                      533, 0x8008e80000000000, 16
#define EI4_RX_FIR1_ERROR_INJECT_PG              534, 0x8008f00000000000, 16
#define EI4_RX_FIR2_ERROR_INJECT_PG              535, 0x8008f80000000000, 16
#define EI4_RX_FIR_TRAINING_PG                   536, 0x8009000000000000, 16
#define EI4_RX_FIR_TRAINING_MASK_PG              537, 0x8009080000000000, 16
#define EI4_RX_TIMEOUT_SEL1_PG                   538, 0x8009100000000000, 16
#define EI4_RX_LANE_BAD_VEC_0_15_PG              539, 0x8009180000000000, 16
#define EI4_RX_LANE_BAD_VEC_16_31_PG             540, 0x8009200000000000, 16
#define EI4_RX_LANE_DISABLED_VEC_0_15_PG         541, 0x8009280000000000, 16
#define EI4_RX_LANE_DISABLED_VEC_16_31_PG        542, 0x8009300000000000, 16
#define EI4_RX_LANE_SWAPPED_VEC_0_15_PG          543, 0x8009380000000000, 16
#define EI4_RX_LANE_SWAPPED_VEC_16_31_PG         544, 0x8009400000000000, 16
#define EI4_RX_INIT_STATE_PG                     545, 0x8009480000000000, 16
#define EI4_RX_WIRETEST_STATE_PG                 546, 0x8009500000000000, 16
#define EI4_RX_WIRETEST_LANEINFO_PG              547, 0x8009580000000000, 16
#define EI4_RX_WIRETEST_GCRMSG_PG                548, 0x8009600000000000, 16
#define EI4_RX_DESKEW_GCRMSG_PG                  549, 0x8009680000000000, 16
#define EI4_RX_DESKEW_STATE_PG                   550, 0x8009700000000000, 16
#define EI4_RX_DESKEW_MODE_PG                    551, 0x8009780000000000, 16
#define EI4_RX_DESKEW_STATUS_PG                  552, 0x8009800000000000, 16
#define EI4_RX_BAD_LANE_ENC_GCRMSG_PG            553, 0x8009880000000000, 16
#define EI4_RX_STATIC_REPAIR_STATE_PG            554, 0x8009900000000000, 16
#define EI4_RX_TX_BUS_INFO_PG                    555, 0x8009980000000000, 16
#define EI4_RX_SLS_LANE_ENC_GCRMSG_PG            556, 0x8009a00000000000, 16
#define EI4_RX_FENCE_PG                          557, 0x8009a80000000000, 16
#define EI4_RX_TERM_PG                           558, 0x8009b00000000000, 16
#define EI4_RX_TIMEOUT_SEL2_PG                   559, 0x8009b80000000000, 16
#define EI4_RX_MISC_ANALOG_PG                    560, 0x8009c00000000000, 16
#define EI4_RX_DYN_RPR_PG                        561, 0x8009c80000000000, 16
#define EI4_RX_DYN_RPR_GCRMSG_PG                 562, 0x8009d00000000000, 16
#define EI4_RX_DYN_RPR_ERR_TALLYING1_PG          563, 0x8009d80000000000, 16
#define EI4_RX_EO_FINAL_L2U_GCRMSG_PG            564, 0x8009e00000000000, 16
#define EI4_RX_GCR_MSG_DEBUG_DEST_IDS_PG         565, 0x8009e80000000000, 16
#define EI4_RX_GCR_MSG_DEBUG_SRC_IDS_PG          566, 0x8009f00000000000, 16
#define EI4_RX_GCR_MSG_DEBUG_DEST_ADDR_PG        567, 0x8009f80000000000, 16
#define EI4_RX_GCR_MSG_DEBUG_WRITE_DATA_PG       568, 0x800a000000000000, 16
#define EI4_RX_WT_CLK_STATUS_PG                  569, 0x800a100000000000, 16
#define EI4_RX_WT_CONFIG_PG                      570, 0x800a200000000000, 16
#define EI4_RX_WIRETEST_PLL_CNTL_PG              571, 0x800a300000000000, 16
#define EI4_RX_EO_STEP_CNTL_PG                   572, 0x800a380000000000, 16
#define EI4_RX_EO_STEP_STAT_PG                   573, 0x800a400000000000, 16
#define EI4_RX_EO_STEP_FAIL_PG                   574, 0x800a480000000000, 16
#define EI4_RX_AMP_VAL_PG                        575, 0x800a700000000000, 16
#define EI4_RX_SLS_RCVY_PG                       576, 0x800a880000000000, 16
#define EI4_RX_SLS_RCVY_GCRMSG_PG                577, 0x800a900000000000, 16
#define EI4_RX_TX_LANE_INFO_GCRMSG_PG            578, 0x800a980000000000, 16
#define EI4_RX_ERR_TALLYING_GCRMSG_PG            579, 0x800aa00000000000, 16
#define EI4_RX_TRACE_PG                          580, 0x800aa80000000000, 16
#define EI4_RX_RDT_CNTL_PG                       581, 0x800ab00000000000, 16
#define EI4_RX_RC_STEP_CNTL_PG                   582, 0x800ab80000000000, 16
#define EI4_RX_EO_RECAL_PG                       583, 0x800ac00000000000, 16
#define EI4_RX_SERVO_BER_COUNT_PG                584, 0x800ac80000000000, 16
#define EI4_RX_FUNC_STATE_PG                     585, 0x800ad00000000000, 16
#define EI4_RX_DYN_RPR_DEBUG_PG                  586, 0x800ad80000000000, 16
#define EI4_RX_DYN_RPR_ERR_TALLYING2_PG          587, 0x800ae00000000000, 16
#define EI4_RX_RESULT_CHK_PG                     588, 0x800ae80000000000, 16
#define EI4_RX_BER_CHK_PG                        589, 0x800af00000000000, 16
#define EI4_RX_SLS_RCVY_FIN_GCRMSG_PG            590, 0x800af80000000000, 16
#define EI4_RX_MODE1_PP                          591, 0x800b080000000000, 16
#define EI4_RX_CNTL_FAST_PP                      592, 0x800b100000000000, 16
#define EI4_RX_EI4_CAL_CNTL_PP                   593, 0x800b180000000000, 16
#define EI4_RX_EI4_CAL_INC_A_D_PP                594, 0x800b200000000000, 16
#define EI4_RX_EI4_CAL_INC_E_H_PP                595, 0x800b280000000000, 16
#define EI4_RX_EI4_CAL_DEC_A_D_PP                596, 0x800b300000000000, 16
#define EI4_RX_EI4_CAL_DEC_E_H_PP                597, 0x800b380000000000, 16
#define EI4_RX_BER_CNTL_PP                       598, 0x800b500000000000, 16
#define EI4_RX_BER_MODE_PP                       599, 0x800b580000000000, 16
#define EI4_RX_SERVO_TO1_PP                      600, 0x800b600000000000, 16
#define EI4_RX_SERVO_TO2_PP                      601, 0x800b680000000000, 16
#define EI4_RX_RESET_CFG_PP                      602, 0x800b880000000000, 16
#define EI4_RX_RECAL_TO1_PP                      603, 0x800b900000000000, 16
#define EI4_RX_RECAL_TO2_PP                      604, 0x800b980000000000, 16
#define EI4_RX_MODE2_PP                          605, 0x800bb00000000000, 16
#define EI4_RX_BIST_GCRMSG_PP                    606, 0x800bb80000000000, 16
#define EI4_RX_MODE3_PP                          607, 0x800bc80000000000, 16
#define EI4_RX_FIR_RESET_PB                      608, 0x800f800000000000, 16
#define EI4_RX_FIR_PB                            609, 0x800f880000000000, 16
#define EI4_RX_FIR_MASK_PB                       610, 0x800f900000000000, 16
#define EI4_RX_FIR_ERROR_INJECT_PB               611, 0x800f980000000000, 16
#define EI4_RX_FIR_MSG_PB                        612, 0x800ff80000000000, 16
#define EI4_SCOM_MODE_PB                         613, 0x20, 64
#define EI4_SCOM_FIR_PB                          614, 0x0, 64
#define EI4_SCOM_FIR_CLR_PB                      615, 0x1, 64
#define EI4_SCOM_FIR_SET_PB                      616, 0x2, 64
#define EI4_SCOM_FIR_MASK_PB                     617, 0x3, 64
#define EI4_SCOM_FIR_MASK_CLR_PB                 618, 0x4, 64
#define EI4_SCOM_FIR_MASK_SET_PB                 619, 0x5, 64
#define EI4_SCOM_FIR_ACTION0_PB                  620, 0x6, 64
#define EI4_SCOM_FIR_ACTION1_PB                  621, 0x7, 64
#define EI4_SCOM_FIR_WOF_PB                      622, 0x8, 64
#define EDIP_TX_MODE1_PL                         623, 0x8004040000000000, 16
#define EDIP_TX_MODE2_PL                         624, 0x80040c0000000000, 16
#define EDIP_TX_CNTL1G_PL                        625, 0x8004140000000000, 16
#define EDIP_TX_STAT1_PL                         626, 0x80041c0000000000, 16
#define EDIP_TX_FIR_PL                           627, 0x8004240000000000, 16
#define EDIP_TX_FIR_MASK_PL                      628, 0x80042c0000000000, 16
#define EDIP_TX_FIR_ERROR_INJECT_PL              629, 0x8004340000000000, 16
#define EDIP_TX_BIT_MODE1_E_PL                   630, 0x80043c0000000000, 16
#define EDIP_TX_BIT_MODE2_E_PL                   631, 0x8004440000000000, 16
#define EDIP_TX_SPARE_MODE_PG                    632, 0x800c040000000000, 16
#define EDIP_TX_ID1_PG                           633, 0x800c0c0000000000, 16
#define EDIP_TX_CTL_MODE1_EO_PG                  634, 0x800c140000000000, 16
#define EDIP_TX_CTL_MODE2_EO_PG                  635, 0x800c1c0000000000, 16
#define EDIP_TX_CTL_CNTLG1_EO_PG                 636, 0x800c240000000000, 16
#define EDIP_TX_CTL_CNTL2_EO_PG                  637, 0x800c2c0000000000, 16
#define EDIP_TX_CTL_CNTL3_EO_PG                  638, 0x800c340000000000, 16
#define EDIP_TX_ID2_PG                           639, 0x800c840000000000, 16
#define EDIP_TX_CTL_MODE1_E_PG                   640, 0x800c8c0000000000, 16
#define EDIP_TX_CTL_CNTL2_E_PG                   641, 0x800c9c0000000000, 16
#define EDIP_TX_CTL_CNTLG3_E_PG                  642, 0x800ca40000000000, 16
#define EDIP_TX_CTL_CNTLG4_E_PG                  643, 0x800cac0000000000, 16
#define EDIP_TX_CTL_CNTLG5_E_PG                  644, 0x800cb40000000000, 16
#define EDIP_TX_CTL_CNTLG6_E_PG                  645, 0x800cbc0000000000, 16
#define EDIP_TX_CTL_CNTLG7_E_PG                  646, 0x800cc40000000000, 16
#define EDIP_TX_CTL_CNTL8_E_PG                   647, 0x800ccc0000000000, 16
#define EDIP_TX_CTL_CNTL9_E_PG                   648, 0x800cd40000000000, 16
#define EDIP_TX_CTL_CNTL10_E_PG                  649, 0x800cdc0000000000, 16
#define EDIP_TX_CTL_STATG1_E_PG                  650, 0x800ce40000000000, 16
#define EDIP_TX_FIR_PG                           651, 0x800d040000000000, 16
#define EDIP_TX_FIR_MASK_PG                      652, 0x800d0c0000000000, 16
#define EDIP_TX_FIR_RESET_PG                     653, 0x800d140000000000, 16
#define EDIP_TX_FIR_ERROR_INJECT_PG              654, 0x800d1c0000000000, 16
#define EDIP_TX_CTLSM_SPARE_MODE_PG              655, 0x800d240000000000, 16
#define EDIP_TX_CTLSM_MODE1_EO_PG                656, 0x800d2c0000000000, 16
#define EDIP_TX_CTLSM_CNTL1_EO_PG                657, 0x800d340000000000, 16
#define EDIP_TX_CTLSM_CNTL2_EO_PG                658, 0x800d3c0000000000, 16
#define EDIP_TX_CTLSM_CNTL3_EO_PG                659, 0x800d440000000000, 16
#define EDIP_TX_CTLSM_CNTL4_EO_PG                660, 0x800d4c0000000000, 16
#define EDIP_TX_CTLSM_CNTL5_EO_PG                661, 0x800d540000000000, 16
#define EDIP_TX_CTLSM_CNTL6_EO_PG                662, 0x800d5c0000000000, 16
#define EDIP_TX_CTLSM_CNTL7_EO_PG                663, 0x800d640000000000, 16
#define EDIP_TX_CTLSM_STAT1_EO_PG                664, 0x800d6c0000000000, 16
#define EDIP_TX_CTLSM_CNTLG1_E_PG                665, 0x800d840000000000, 16
#define EDIP_TX_CTLSM_STAT1_E_PG                 666, 0x800d8c0000000000, 16
#define EDIP_TX_IMPCAL_PB                        667, 0x800f040000000000, 16
#define EDIP_TX_IMPCAL2_PB                       668, 0x800f3c0000000000, 16
#define EDIP_TX_IMPCAL_NVAL_PB                   669, 0x800f0c0000000000, 16
#define EDIP_TX_IMPCAL_PVAL_PB                   670, 0x800f140000000000, 16
#define EDIP_TX_IMPCAL_P_4X_PB                   671, 0x800f1c0000000000, 16
#define EDIP_TX_IMPCAL_SWO1_PB                   672, 0x800f240000000000, 16
#define EDIP_TX_IMPCAL_SWO2_PB                   673, 0x800f2c0000000000, 16
#define EDIP_SPARE_MODE_PB                       674, 0x800f340000000000, 16
#define EDIP_RX_DATA_DAC_SPARE_MODE_PL           675, 0x8000000000000000, 16
#define EDIP_RX_DAC_CNTL1_EO_PL                  676, 0x8000080000000000, 16
#define EDIP_RX_DAC_CNTL2_EO_PL                  677, 0x8000100000000000, 16
#define EDIP_RX_DAC_CNTL3_EO_PL                  678, 0x8000180000000000, 16
#define EDIP_RX_DAC_CNTL4_EO_PL                  679, 0x8000200000000000, 16
#define EDIP_RX_DAC_CNTL5_EO_PL                  680, 0x8000280000000000, 16
#define EDIP_RX_DAC_CNTL6_EO_PL                  681, 0x8000300000000000, 16
#define EDIP_RX_DAC_CNTL7_EO_PL                  682, 0x8000380000000000, 16
#define EDIP_RX_DAC_CNTL8_EO_PL                  683, 0x8000400000000000, 16
#define EDIP_RX_DAC_CNTL1_E_PL                   684, 0x8000800000000000, 16
#define EDIP_RX_DAC_CNTL2_E_PL                   685, 0x8000880000000000, 16
#define EDIP_RX_DAC_CNTL3_E_PL                   686, 0x8000900000000000, 16
#define EDIP_RX_DAC_CNTL4_E_PL                   687, 0x8000980000000000, 16
#define EDIP_RX_DAC_CNTL5_E_PL                   688, 0x8000a00000000000, 16
#define EDIP_RX_DAC_CNTL6_E_PL                   689, 0x8000a80000000000, 16
#define EDIP_RX_DAC_CNTL7_E_PL                   690, 0x8000b00000000000, 16
#define EDIP_RX_DAC_CNTL8_E_PL                   691, 0x8000b80000000000, 16
#define EDIP_RX_DAC_CNTL9_E_PL                   692, 0x8000c00000000000, 16
#define EDIP_RX_SPARE_MODE_PL                    693, 0x8002000000000000, 16
#define EDIP_RX_FIR_PL                           694, 0x8002080000000000, 16
#define EDIP_RX_FIR_MASK_PL                      695, 0x8002100000000000, 16
#define EDIP_RX_FIR_ERROR_INJECT_PL              696, 0x8002180000000000, 16
#define EDIP_RX_BIT_MODE1_EO_PL                  697, 0x8002200000000000, 16
#define EDIP_RX_BIT_MODE2_EO_PL                  698, 0x8002280000000000, 16
#define EDIP_RX_BIT_MODE3_EO_PL                  699, 0x8002300000000000, 16
#define EDIP_RX_BIT_CNTLX1_EO_PL                 700, 0x8002380000000000, 16
#define EDIP_RX_BIT_CNTL2_EO_PL                  701, 0x8002400000000000, 16
#define EDIP_RX_BIT_CNTL3_EO_PL                  702, 0x8002480000000000, 16
#define EDIP_RX_BIT_CNTL4_EO_PL                  703, 0x8002500000000000, 16
#define EDIP_RX_BIT_STAT1_EO_PL                  704, 0x8002580000000000, 16
#define EDIP_RX_BIT_STAT2_EO_PL                  705, 0x8002600000000000, 16
#define EDIP_RX_BIT_STAT3_EO_PL                  706, 0x8002680000000000, 16
#define EDIP_RX_BIT_MODE1_E_PL                   707, 0x8002c00000000000, 16
#define EDIP_RX_BIT_MODE2_E_PL                   708, 0x8002c80000000000, 16
#define EDIP_RX_BIT_CNTL1_E_PL                   709, 0x8003000000000000, 16
#define EDIP_RX_BIT_CNTL2_E_PL                   710, 0x8003080000000000, 16
#define EDIP_RX_BIT_CNTL3_E_PL                   711, 0x8003100000000000, 16
#define EDIP_RX_BIT_STAT1_O_PL                   712, 0x8003180000000000, 16
#define EDIP_RX_DATA_WORK_SPARE_MODE_PL          713, 0x8003800000000000, 16
#define EDIP_RX_WORK_STAT1_EO_PL                 714, 0x8003880000000000, 16
#define EDIP_RX_WORK_STAT2_EO_PL                 715, 0x8003900000000000, 16
#define EDIP_RX_WORK_STAT3_EO_PL                 716, 0x8003980000000000, 16
#define EDIP_RX_SPARE_MODE_PG                    717, 0x8008000000000000, 16
#define EDIP_RX_ID1_PG                           718, 0x8008080000000000, 16
#define EDIP_RX_CTL_MODE1_EO_PG                  719, 0x8008100000000000, 16
#define EDIP_RX_CTL_MODE2_EO_PG                  720, 0x8008180000000000, 16
#define EDIP_RX_CTL_MODE5_EO_PG                  721, 0x8008300000000000, 16
#define EDIP_RX_CTL_MODE6_EO_PG                  722, 0x8008380000000000, 16
#define EDIP_RX_CTL_MODE7_EO_PG                  723, 0x8008400000000000, 16
#define EDIP_RX_CTL_MODE8_EO_PG                  724, 0x8008480000000000, 16
#define EDIP_RX_CTL_MODE9_EO_PG                  725, 0x8008500000000000, 16
#define EDIP_RX_CTL_MODE10_EO_PG                 726, 0x8008580000000000, 16
#define EDIP_RX_CTL_MODE11_EO_PG                 727, 0x8008600000000000, 16
#define EDIP_RX_CTL_MODE12_EO_PG                 728, 0x8008680000000000, 16
#define EDIP_RX_CTL_MODE13_EO_PG                 729, 0x8008700000000000, 16
#define EDIP_RX_CTL_MODE14_EO_PG                 730, 0x8008780000000000, 16
#define EDIP_RX_CTL_MODE15_EO_PG                 731, 0x8008800000000000, 16
#define EDIP_RX_CTL_MODE16_EO_PG                 732, 0x8008880000000000, 16
#define EDIP_RX_CTL_MODE17_EO_PG                 733, 0x8008900000000000, 16
#define EDIP_RX_CTL_MODE18_EO_PG                 734, 0x8008980000000000, 16
#define EDIP_RX_CTL_MODE19_EO_PG                 735, 0x8008a00000000000, 16
#define EDIP_RX_CTL_MODE20_EO_PG                 736, 0x8008a80000000000, 16
#define EDIP_RX_CTL_MODE21_EO_PG                 737, 0x8008b00000000000, 16
#define EDIP_RX_CTL_MODE22_EO_PG                 738, 0x8008b80000000000, 16
#define EDIP_RX_CTL_MODE23_EO_PG                 739, 0x8008c00000000000, 16
#define EDIP_RX_CTL_MODE24_EO_PG                 740, 0x8008c80000000000, 16
#define EDIP_RX_CTL_MODE29_EO_PG                 741, 0x8008d00000000000, 16
#define EDIP_RX_CTL_CNTL1_EO_PG                  742, 0x8008d80000000000, 16
#define EDIP_RX_CTL_CNTL2_EO_PG                  743, 0x8008e00000000000, 16
#define EDIP_RX_CTL_CNTL3_EO_PG                  744, 0x8008e80000000000, 16
#define EDIP_RX_CTL_CNTL4_EO_PG                  745, 0x8008f00000000000, 16
#define EDIP_RX_CTL_CNTL5_EO_PG                  746, 0x8008f80000000000, 16
#define EDIP_RX_CTL_CNTL6_EO_PG                  747, 0x8009000000000000, 16
#define EDIP_RX_CTL_CNTLX7_EO_PG                 748, 0x8009080000000000, 16
#define EDIP_RX_CTL_CNTL8_EO_PG                  749, 0x8009100000000000, 16
#define EDIP_RX_CTL_CNTL9_EO_PG                  750, 0x8009180000000000, 16
#define EDIP_RX_CTL_CNTL10_EO_PG                 751, 0x8009200000000000, 16
#define EDIP_RX_CTL_CNTL11_EO_PG                 752, 0x8009280000000000, 16
#define EDIP_RX_CTL_CNTL12_EO_PG                 753, 0x8009300000000000, 16
#define EDIP_RX_CTL_CNTL13_EO_PG                 754, 0x8009380000000000, 16
#define EDIP_RX_CTL_CNTL14_EO_PG                 755, 0x8009400000000000, 16
#define EDIP_RX_CTL_CNTL15_EO_PG                 756, 0x8009480000000000, 16
#define EDIP_RX_CTL_STAT1_EO_PG                  757, 0x8009500000000000, 16
#define EDIP_RX_CTL_STAT2_EO_PG                  758, 0x8009580000000000, 16
#define EDIP_RX_CTL_STAT3_EO_PG                  759, 0x8009600000000000, 16
#define EDIP_RX_CTL_MODE26_EO_PG                 760, 0x8009680000000000, 16
#define EDIP_RX_CTL_MODE27_EO_PG                 761, 0x8009700000000000, 16
#define EDIP_RX_CTL_MODE28_EO_PG                 762, 0x8009780000000000, 16
#define EDIP_RX_ID2_PG                           763, 0x8009800000000000, 16
#define EDIP_RX_CTL_MODE1_E_PG                   764, 0x8009900000000000, 16
#define EDIP_RX_CTL_MODE2_E_PG                   765, 0x8009980000000000, 16
#define EDIP_RX_CTL_MODE3_E_PG                   766, 0x8009a00000000000, 16
#define EDIP_RX_CTL_MODE4_E_PG                   767, 0x8009a80000000000, 16
#define EDIP_RX_CTL_MODE5_E_PG                   768, 0x8009b00000000000, 16
#define EDIP_RX_CTL_MODE6_E_PG                   769, 0x8009b80000000000, 16
#define EDIP_RX_CTL_MODE7_E_PG                   770, 0x8009c00000000000, 16
#define EDIP_RX_CTL_MODE8_E_PG                   771, 0x8009c80000000000, 16
#define EDIP_RX_CTL_MODE9_E_PG                   772, 0x8009d00000000000, 16
#define EDIP_RX_CTL_MODE10_E_PG                  773, 0x8009d80000000000, 16
#define EDIP_RX_CTL_MODE11_E_PG                  774, 0x8009e00000000000, 16
#define EDIP_RX_CTL_MODE12_E_PG                  775, 0x8009e80000000000, 16
#define EDIP_RX_CTL_CNTL1_E_PG                   776, 0x8009f00000000000, 16
#define EDIP_RX_CTL_CNTL4_E_PG                   777, 0x8009f80000000000, 16
#define EDIP_RX_CTL_CNTLX5_E_PG                  778, 0x800a000000000000, 16
#define EDIP_RX_CTL_CNTL6_E_PG                   779, 0x800a080000000000, 16
#define EDIP_RX_CTL_CNTLX10_E_PG                 780, 0x800a280000000000, 16
#define EDIP_RX_CTL_CNTLX11_E_PG                 781, 0x800a300000000000, 16
#define EDIP_RX_CTL_STAT1_E_PG                   782, 0x800a380000000000, 16
#define EDIP_RX_CTL_STAT2_E_PG                   783, 0x800a400000000000, 16
#define EDIP_RX_CTL_STAT4_E_PG                   784, 0x800a500000000000, 16
#define EDIP_RX_CTL_STAT5_E_PG                   785, 0x800a580000000000, 16
#define EDIP_RX_CTL_STAT6_E_PG                   786, 0x800a600000000000, 16
#define EDIP_RX_CTL_STATX8_E_PG                  787, 0x800a680000000000, 16
#define EDIP_RX_GLBSM_SPARE_MODE_PG              788, 0x800a800000000000, 16
#define EDIP_RX_FIR1_PG                          789, 0x800a880000000000, 16
#define EDIP_RX_FIR1_MASK_PG                     790, 0x800a900000000000, 16
#define EDIP_RX_FIR1_ERROR_INJECT_PG             791, 0x800a980000000000, 16
#define EDIP_RX_FIR_TRAINING_PG                  792, 0x800aa00000000000, 16
#define EDIP_RX_FIR_TRAINING_MASK_PG             793, 0x800aa80000000000, 16
#define EDIP_RX_GLBSM_CNTL1_EO_PG                794, 0x800ab00000000000, 16
#define EDIP_RX_GLBSM_STAT1_EO_PG                795, 0x800ab80000000000, 16
#define EDIP_RX_GLBSM_STAT2_EO_PG                796, 0x800ac00000000000, 16
#define EDIP_RX_GLBSM_STAT3_EO_PG                797, 0x800ac80000000000, 16
#define EDIP_RX_GLBSM_STAT4_EO_PG                798, 0x800ad00000000000, 16
#define EDIP_RX_FIR2_PG                          799, 0x800b000000000000, 16
#define EDIP_RX_FIR2_MASK_PG                     800, 0x800b080000000000, 16
#define EDIP_RX_FIR2_ERROR_INJECT_PG             801, 0x800b100000000000, 16
#define EDIP_RX_GLBSM_STAT1_E_PG                 802, 0x800b180000000000, 16
#define EDIP_RX_GLBSM_STAT2_E_PG                 803, 0x800b200000000000, 16
#define EDIP_RX_GLBSM_STAT3_E_PG                 804, 0x800b280000000000, 16
#define EDIP_RX_GLBSM_STAT4_E_PG                 805, 0x800b300000000000, 16
#define EDIP_RX_GLBSM_STAT6_E_PG                 806, 0x800b400000000000, 16
#define EDIP_RX_GLBSM_STAT7_E_PG                 807, 0x800b480000000000, 16
#define EDIP_RX_GLBSM_STAT8_E_PG                 808, 0x800b500000000000, 16
#define EDIP_RX_GLBSM_STAT9_E_PG                 809, 0x800b580000000000, 16
#define EDIP_RX_GLBSM_STAT10_E_PG                810, 0x800b600000000000, 16
#define EDIP_RX_DATASM_SPARE_MODE_PG             811, 0x800b800000000000, 16
#define EDIP_RX_DATASM_CNTLX1_EO_PG              812, 0x800b880000000000, 16
#define EDIP_RX_DATASM_STAT1_EO_PG               813, 0x800b900000000000, 16
#define EDIP_RX_DATASM_STAT2_EO_PG               814, 0x800b980000000000, 16
#define EDIP_RX_DATASM_STAT3_EO_PG               815, 0x800ba00000000000, 16
#define EDIP_RX_DATASM_STAT4_EO_PG               816, 0x800ba80000000000, 16
#define EDIP_RX_DATASM_STAT5_EO_PG               817, 0x800bb00000000000, 16
#define EDIP_RX_DATASM_STAT6_EO_PG               818, 0x800bb80000000000, 16
#define EDIP_RX_DATASM_STAT7_EO_PG               819, 0x800bc00000000000, 16
#define EDIP_RX_DATASM_STAT8_EO_PG               820, 0x800bc80000000000, 16
#define EDIP_RX_DATASM_STAT9_EO_PG               821, 0x800bd00000000000, 16
#define EDIP_RX_DATASM_STAT10_EO_PG              822, 0x800bd80000000000, 16
#define EDIP_RX_DATASM_STAT11_EO_PG              823, 0x800be00000000000, 16
#define EDIP_RX_DATASM_CNTL1_E_PG                824, 0x800be80000000000, 16
#define EDIP_RX_FIR_RESET_PB                     825, 0x800f800000000000, 16
#define EDIP_RX_FIR_PB                           826, 0x800f880000000000, 16
#define EDIP_RX_FIR_MASK_PB                      827, 0x800f900000000000, 16
#define EDIP_RX_FIR_ERROR_INJECT_PB              828, 0x800f980000000000, 16
#define EDIP_RX_INTR_MSG_PB                      829, 0x800ff00000000000, 16
#define EDIP_RX_FIR_MSG_PB                       830, 0x800ff80000000000, 16
#define EDIP_SCOM_MODE_PB                        831, 0x20, 64
#define EDIP_SCOM_FIR_PB                         832, 0x0, 64
#define EDIP_SCOM_FIR_CLR_PB                     833, 0x1, 64
#define EDIP_SCOM_FIR_SET_PB                     834, 0x2, 64
#define EDIP_SCOM_FIR_MASK_PB                    835, 0x3, 64
#define EDIP_SCOM_FIR_MASK_CLR_PB                836, 0x4, 64
#define EDIP_SCOM_FIR_MASK_SET_PB                837, 0x5, 64
#define EDIP_SCOM_FIR_ACTION0_PB                 838, 0x6, 64
#define EDIP_SCOM_FIR_ACTION1_PB                 839, 0x7, 64
#define EDIP_SCOM_FIR_WOF_PB                     840, 0x8, 64
#define EDIP_SCOM_PPE_XCR_NONE                   841, 0xa, 64
#define EDIP_SCOM_PPE_XCR_SPRG0                  842, 0xb, 64
#define EDIP_SCOM_PPE_IR_SPRG0                   843, 0xc, 64
#define EDIP_SCOM_PPE_XSR_SPRG0                  844, 0xd, 64
#define EDIP_SCOM_PPE_IR_EDR                     845, 0xe, 64
#define EDIP_SCOM_PPE_XSR_IAR                    846, 0xf, 64
#define EDIP_SCOM_PPE_MEM_ARB_CSAR               847, 0x18, 64
#define EDIP_SCOM_PPE_MEM_ARB_CSDR               848, 0x19, 64
#define EDIP_SCOM_PPE_MEM_ARB_SCR                849, 0x15, 64
#define EDIP_SCOM_PPE_CNTL                       850, 0x20, 64
#define EDIP_SCOM_PPE_WORK_REG1                  851, 0x21, 64
#define EDIP_SCOM_PPE_WORK_REG2                  852, 0x22, 64
#define EDIP_SCOM_PPE_FLAGS_REG                  853, 0x23, 64
#define EDIP_SCOM_PPE_FLAGS_SET_REG              854, 0x24, 64
#define EDIP_SCOM_PPE_FLAGS_CLR_REG              855, 0x25, 64


/*
 * *****************************
 *  Fields
 * *****************************
*/

#define OPT_TX_MODE1_PL_FULL_REG                             0,  0, 16 // OPT_TX_MODE1_PL :: iotk alias: for entire tx_mode1_pl register
#define OPT_TX_LANE_PDWN                                     0,  0,  1 // OPT_TX_MODE1_PL :: used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default). 
#define OPT_TX_LANE_INVERT                                   0,  1,  1 // OPT_TX_MODE1_PL :: used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.
#define OPT_TX_LANE_QUIESCE                                  0,  2,  2 // OPT_TX_MODE1_PL :: used to force the output of a lane to a particular logical value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.
#define OPT_TX_PSAVE_REQ_DIS                                 0,  6,  1 // OPT_TX_MODE1_PL :: disable tx slice power gating from link layer psav_req control
#define OPT_TX_ERR_INJ_A_ENABLE                              0,  7,  1 // OPT_TX_MODE1_PL :: control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane.
#define OPT_TX_ERR_INJ_B_ENABLE                              0,  8,  1 // OPT_TX_MODE1_PL :: control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane.
#define OPT_TX_PL_SPARE_MODE_0                               0, 12,  1 // OPT_TX_MODE1_PL :: per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_1                               0, 13,  1 // OPT_TX_MODE1_PL :: per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_2                               0, 14,  1 // OPT_TX_MODE1_PL :: per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_3                               0, 15,  1 // OPT_TX_MODE1_PL :: per-lane spare mode latch.
#define OPT_TX_FIFO_L2U_DLY                                  1,  0,  3 // OPT_TX_MODE2_PL :: this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define OPT_TX_UNLOAD_CLK_DISABLE                            1,  8,  1 // OPT_TX_MODE2_PL :: set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define OPT_TX_RXCAL                                         1,  9,  1 // OPT_TX_MODE2_PL :: set transmitter to drive vio/2 common mode on both legs.  use this control during far end rx offset calibration.
#define OPT_TX_UNLOAD_SEL                                    1, 10,  3 // OPT_TX_MODE2_PL :: controls the preset value of the tx slice unload counter, which effectively gives subcycle control of the offset of tx unload clock from grid clock.
#define OPT_TX_ERR_INJECT                                    2,  0,  5 // OPT_TX_CNTL1G_PL :: inject one beat of error on this lane.  set code 1yyyy where yyyy is the beat in the deserialized cycle to inject on.
#define OPT_TX_FIFO_INIT                                     2,  5,  1 // OPT_TX_CNTL1G_PL :: used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.
#define OPT_TX_IORESET                                       9,  0,  1 // OPT_TX_CNTL2_O_PL :: reset the given tx lane
#define OPT_TX_LANE_BIST_ERR                                 3,  0,  1 // OPT_TX_STAT1_PL :: indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.
#define OPT_TX_LANE_BIST_ACTVITY_DET                         3,  1,  1 // OPT_TX_STAT1_PL :: indicates that activity was detected in prbs checker. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define OPT_TX_SEG_TEST_STATUS                               3,  2,  2 // OPT_TX_STAT1_PL :: driver segment test result. bit0 for pad p, bit1 for pad n
#define OPT_TX_PL_FIR_ERRS_FULL_REG                          4,  0, 16 // OPT_TX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define OPT_TX_PL_FIR_ERRS                                   4,  0,  1 // OPT_TX_FIR_PL :: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs
#define OPT_TX_PL_FIR_ERR_PL_REGS                            4,  0,  1 // OPT_TX_FIR_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.
#define OPT_TX_PL_FIR_ERRS_MASK_FULL_REG                     5,  0, 16 // OPT_TX_FIR_MASK_PL :: iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.
#define OPT_TX_PL_FIR_ERRS_MASK                              5,  0,  1 // OPT_TX_FIR_MASK_PL :: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs
#define OPT_TX_PL_FIR_ERR_MASK_PL_REGS                       5,  0,  1 // OPT_TX_FIR_MASK_PL :: iotk alias: fir mask for the per-lane tx register checker.
#define OPT_TX_PL_FIR_ERR_INJ_FULL_REG                       6,  0, 16 // OPT_TX_FIR_ERROR_INJECT_PL :: iotk alias: for tx_fir_error_inject_pl register
#define OPT_TX_PL_FIR_ERR_INJ                                6,  0,  1 // OPT_TX_FIR_ERROR_INJECT_PL :: tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker
#define OPT_TX_PL_FIR_ERR_INJ_PL_REGS                        6,  0,  1 // OPT_TX_FIR_ERROR_INJECT_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.
#define OPT_TX_PG_SPARE_MODE_0                              10,  0,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_1                              10,  1,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_2                              10,  2,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_3                              10,  3,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_4                              10,  4,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_5                              10,  5,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_6                              10,  6,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_7                              10,  7,  1 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_8_9                            10,  8,  2 // OPT_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_BIST_DONE                                    32,  2,  1 // OPT_TX_CTLSM_STAT1_EO_PG :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running
#define OPT_TX_CLKDIST_PDWN                                 12,  0,  3 // OPT_TX_CTL_MODE1_EO_PG :: used to disable the tx group clocks and put them into a low power state. this does not control per-lane circuits or logic.  \r\n\t bit 0 disables slices 16-23 \r\n\t bit 1 disables slices 8-15 \r\n\t bit 2 disables slices 0-7
#define OPT_TX_BIST_EN                                      12,  3,  1 // OPT_TX_CTL_MODE1_EO_PG :: this bit enables the tx bist state machine to begin testing.
#define OPT_TX_EXBIST_MODE                                  12,  4,  1 // OPT_TX_CTL_MODE1_EO_PG :: this bit is the chicken switch to diable the bist enable through external io.
#define OPT_TX_BUS_ID                                       11,  0,  6 // OPT_TX_ID1_PG :: this field is used to programmably set the bus number that a group belongs to.
#define OPT_TX_DRV_DATA_PATTERN_GCRMSG                      14,  2,  4 // OPT_TX_CTL_CNTLG1_EO_PG :: tx drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id)\r\n\t0110:(drv_rxbist) alternate prbs7 pattern for rx bist \r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_prbs7) prbs7 pattern\r\n\t1001:(drv_prbs11) prbs11 pattern\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(drv_prbs15) prbs15 pattern\r\n\t1100:(drv_nvbus) alternate prbs23 for nvbus\r\n\t1101:(drv_prbs31) prbs31 pattern\r\n\t1110:(unused_a) unused\r\n\t1111:(unused_b) unused\r\n\trjr
#define OPT_TX_ERR_INJ_A_FINE_SEL                           15,  0,  3 // OPT_TX_CTL_CNTL2_EO_PG :: random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define OPT_TX_ERR_INJ_A_COARSE_SEL                         15,  3,  4 // OPT_TX_CTL_CNTL2_EO_PG :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define OPT_TX_ERR_INJ_A_BER_SEL                            15,  7,  6 // OPT_TX_CTL_CNTL2_EO_PG :: used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). 
#define OPT_TX_ERR_INJ_ENABLE                               15, 13,  1 // OPT_TX_CTL_CNTL2_EO_PG :: overall error injection enable.  when set to 0, all other injection is gated.
#define OPT_TX_ERR_INJ_CLOCK_ENABLE                         15, 14,  1 // OPT_TX_CTL_CNTL2_EO_PG :: enable clocks to larger counter and prbs logic.  use this to stagger start times and effectively seed the injection mechanism randomly.
#define OPT_TX_ERR_INJ_B_FINE_SEL                           16,  0,  3 // OPT_TX_CTL_CNTL3_EO_PG :: random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define OPT_TX_ERR_INJ_B_COARSE_SEL                         16,  3,  4 // OPT_TX_CTL_CNTL3_EO_PG :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define OPT_TX_ERR_INJ_B_BER_SEL                            16,  7,  6 // OPT_TX_CTL_CNTL3_EO_PG :: used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). 
#define OPT_TX_SEG_TEST_MODE                                24,  2,  8 // OPT_TX_CTLSM_MODE1_EO_PG :: driver segment test mode: all 0 means normal function mode, when this is not 0, segment test begins
#define OPT_TX_FFE_BOOST_EN                                 24, 11,  1 // OPT_TX_CTLSM_MODE1_EO_PG :: driver segment test: to enable boost function of nvlink tx 
#define OPT_TX_SEG_TEST_LEAKAGE_CTRL                        24, 13,  1 // OPT_TX_CTLSM_MODE1_EO_PG :: control txr_txc_sst_ctl_dc in every tx slice. 1 means run segment test in low leakage mode.
#define OPT_TX_PSEG_PRE_EN                                  25,  3,  5 // OPT_TX_CTLSM_CNTL1_EO_PG :: pre bank pseg enable
#define OPT_TX_PSEG_PRE_SEL                                 25,  8,  5 // OPT_TX_CTLSM_CNTL1_EO_PG :: pre bank pseg mode selection
#define OPT_TX_NSEG_PRE_EN                                  26,  3,  5 // OPT_TX_CTLSM_CNTL2_EO_PG :: pre bank nseg enable
#define OPT_TX_NSEG_PRE_SEL                                 26,  8,  5 // OPT_TX_CTLSM_CNTL2_EO_PG :: pre bank nseg mode selection
#define OPT_TX_PSEG_POST_EN                                 33,  1,  7 // OPT_TX_CTLSM_CNTL1_O_PG :: post bank pseg enable
#define OPT_TX_PSEG_POST_SEL                                33,  8,  7 // OPT_TX_CTLSM_CNTL1_O_PG :: post bank pseg mode selection
#define OPT_TX_NSEG_POST_EN                                 34,  1,  7 // OPT_TX_CTLSM_CNTL2_O_PG :: post bank nseg enable
#define OPT_TX_NSEG_POST_SEL                                34,  8,  7 // OPT_TX_CTLSM_CNTL2_O_PG :: post bank nseg mode selection
#define OPT_TX_PSEG_MARGINPU_EN                             27,  0,  8 // OPT_TX_CTLSM_CNTL3_EO_PG :: margin pull-up bank pseg enable
#define OPT_TX_PSEG_MARGINPD_EN                             27,  8,  8 // OPT_TX_CTLSM_CNTL3_EO_PG :: margin pull-down bank pseg enable
#define OPT_TX_NSEG_MARGINPU_EN                             28,  0,  8 // OPT_TX_CTLSM_CNTL4_EO_PG :: margin pull-up bank nseg enable
#define OPT_TX_NSEG_MARGINPD_EN                             28,  8,  8 // OPT_TX_CTLSM_CNTL4_EO_PG :: margin pull-down bank nseg enable
#define OPT_TX_MARGINPU_SEL                                 29,  0,  8 // OPT_TX_CTLSM_CNTL5_EO_PG :: margin pull-up bank mode selection
#define OPT_TX_MARGINPD_SEL                                 29,  8,  8 // OPT_TX_CTLSM_CNTL5_EO_PG :: margin pull-down bank mode selection
#define OPT_TX_PSEG_MAIN_EN                                 30,  3,  7 // OPT_TX_CTLSM_CNTL6_EO_PG :: main bank pseg enable
#define OPT_TX_NSEG_MAIN_EN                                 31,  3,  7 // OPT_TX_CTLSM_CNTL7_EO_PG :: main bank nseg enable
#define OPT_TX_CLR_PAR_ERRS                                 21, 14,  1 // OPT_TX_FIR_RESET_PG :: clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.
#define OPT_TX_FIR_RESET                                    21, 15,  1 // OPT_TX_FIR_RESET_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define OPT_TX_PG_FIR_ERRS_FULL_REG                         19,  0, 16 // OPT_TX_FIR_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.
#define OPT_TX_PG_FIR_ERR_TX_SM_REGS                        19,  0,  1 // OPT_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_GCR_BUFF                          19,  1,  1 // OPT_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.
#define OPT_TX_PG_FIR_ERR_GCRS_LD_SM                        19,  2,  1 // OPT_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_GCRS_UNLD_SM                      19,  3,  1 // OPT_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_CTL_REGS                          19,  4,  1 // OPT_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define OPT_TX_PL_FIR_ERR                                   19, 15,  1 // OPT_TX_FIR_PG :: summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define OPT_TX_PG_FIR_ERR_MASK_FULL_REG                     20,  0, 16 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.
#define OPT_TX_PG_FIR_ERRS_MASK                             20,  0,  5 // OPT_TX_FIR_MASK_PG :: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define OPT_TX_PG_FIR_ERR_MASK_TX_SM_REGS                   20,  0,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_MASK_GCR_BUFF                     20,  1,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr buffer.
#define OPT_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                   20,  2,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                 20,  3,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_MASK_CTL_REGS                     20,  4,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_MASK_BIST                         20,  5,  1 // OPT_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PL_FIR_ERR_MASK                              20, 15,  1 // OPT_TX_FIR_MASK_PG :: fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.
#define OPT_TX_PG_FIR_ERR_INJ_FULL_REG                      22,  0, 16 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.
#define OPT_TX_PG_FIR_ERR_INJ                               22,  0,  5 // OPT_TX_FIR_ERROR_INJECT_PG :: tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define OPT_TX_PG_FIR_ERR_INJ_TX_SM_REGS                    22,  0,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_INJ_GCR_BUFF                      22,  1,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.
#define OPT_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                    22,  2,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                  22,  3,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_INJ_CTL_REGS                      22,  4,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_INJ_BIST                          22,  5,  1 // OPT_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_0                       23,  0,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_1                       23,  1,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_2                       23,  2,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_3                       23,  3,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_4                       23,  4,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_5                       23,  5,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_6                       23,  6,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_7                       23,  7,  1 // OPT_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_TX_ZCAL_REQ                                     35,  1,  1 // OPT_TX_IMPCAL_PB :: impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_DONE                                    35,  2,  1 // OPT_TX_IMPCAL_PB :: impedance calibration sequence complete\r\n\t results are valid when 1.
#define OPT_TX_ZCAL_ERROR                                   35,  3,  1 // OPT_TX_IMPCAL_PB :: impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_BUSY                                    35,  4,  1 // OPT_TX_IMPCAL_PB :: impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define OPT_TX_ZCAL_FORCE_SAMPLE                            35,  5,  1 // OPT_TX_IMPCAL_PB :: impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable
#define OPT_TX_ZCAL_CMP_OUT                                 35,  6,  1 // OPT_TX_IMPCAL_PB :: calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.
#define OPT_TX_ZCAL_SAMPLE_CNT                              35,  7,  9 // OPT_TX_IMPCAL_PB :: calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.
#define OPT_TX_ZCAL_ANS_NOT_FOUND_ERROR                     36,  1,  1 // OPT_TX_IMPCAL2_PB :: impedance calibration sequence answer not found error\r\n\t indicates, independent of tx_zcal_done, no calibration answer was found. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_ANS_RANGE_ERROR                         36,  2,  1 // OPT_TX_IMPCAL2_PB :: impedance calibration sequence range check error\r\n\t indicates, independent of tx_zcal_done, the ans is not in max/min range, only works when tx_zcal_range_check is 1. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_TEST_ENABLE                             36,  5,  1 // OPT_TX_IMPCAL2_PB :: start impedance bist
#define OPT_TX_ZCAL_TEST_STATUS                             36,  6,  1 // OPT_TX_IMPCAL2_PB :: this register stores the result of impedance bist
#define OPT_TX_ZCAL_TEST_DONE                               36,  7,  1 // OPT_TX_IMPCAL2_PB :: this register is set to 1 when impedance bist is finished
#define OPT_TX_ZCAL_N                                       37,  0,  9 // OPT_TX_IMPCAL_NVAL_PB :: calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_ZCAL_P                                       38,  0,  9 // OPT_TX_IMPCAL_PVAL_PB :: calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_ZCAL_P_4X                                    39,  0,  5 // OPT_TX_IMPCAL_P_4X_PB :: calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).
#define OPT_TX_ZCAL_SWO_EN                                  40,  0,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_SWO_CAL_SEGS                            40,  1,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define OPT_TX_ZCAL_SWO_CMP_INV                             40,  2,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define OPT_TX_ZCAL_SWO_CMP_OFFSET                          40,  3,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.
#define OPT_TX_ZCAL_SWO_CMP_RESET                           40,  4,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.
#define OPT_TX_ZCAL_SWO_POWERDOWN                           40,  5,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.
#define OPT_TX_ZCAL_SWO_TCOIL                               40,  6,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration software circuit tcoil\r\n\t
#define OPT_TX_ZCAL_RANGE_CHECK                             40,  7,  1 // OPT_TX_IMPCAL_SWO1_PB :: controls the usage of tx_zcal_sm_min/max_val, 0 means these two registers are used to define the range of zcal. if 1, the calibration range is from 1 to 80, and the min/max registers are only used to check whether the result is in range
#define OPT_TX_ZCAL_CYA_DATA_INV                            40,  8,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.
#define OPT_TX_ZCAL_TEST_OVR_2R                             40,  9,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 2r segment override\r\n\t
#define OPT_TX_ZCAL_TEST_OVR_1R                             40, 10,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 1r segment override\r\n\t
#define OPT_TX_ZCAL_TEST_OVR_4X_SEG                         40, 11,  1 // OPT_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 4x segment override\r\n\t
#define OPT_TX_ZCAL_TEST_CLK_DIV                            40, 12,  1 // OPT_TX_IMPCAL_SWO1_PB :: this register controls the clock for impedance bist. 1 means the clock is divided by 32. when this register is 0, pll bypass mode is needed.
#define OPT_TX_ZCAL_SM_MIN_VAL                              41,  0,  7 // OPT_TX_IMPCAL_SWO2_PB :: impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_ZCAL_SM_MAX_VAL                              41,  7,  7 // OPT_TX_IMPCAL_SWO2_PB :: impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_PB_SPARE_MODE_0                                 42,  0,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_1                                 42,  1,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_2                                 42,  2,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_3                                 42,  3,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_4                                 42,  4,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_5                                 42,  5,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_6                                 42,  6,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_7                                 42,  7,  1 // OPT_SPARE_MODE_PB :: per-bus spare mode latch.
#define OPT_RX_MODE_PL_FULL_REG                             66,  0, 16 // OPT_RX_BIT_MODE1_EO_PL :: alias for entire rx_mode_pl register
#define OPT_RX_LANE_DIG_PDWN                                66,  0,  1 // OPT_RX_BIT_MODE1_EO_PL :: used to power down digital logic for a lane. 
#define OPT_RX_BER_DPIPE_MUX_SEL                            66,  1,  1 // OPT_RX_BIT_MODE1_EO_PL :: diag ber data pipe mux select. when set to a 1 the xor of the main and alt data is muxed onto the main data path feeding the data pipe.
#define OPT_RX_DECOUPLE_EDGE_A                              66,  2,  1 // OPT_RX_BIT_MODE1_EO_PL :: this bit enables a mode where phase rotator a is decoupled from edge. its position is directly equal to the rx_pr_data_a_offset value.
#define OPT_RX_DECOUPLE_EDGE_B                              66,  3,  1 // OPT_RX_BIT_MODE1_EO_PL :: this bit enables a mode where phase rotator b is decoupled from edge. its position is directly equal to the rx_pr_data_b_offset value.
#define OPT_RX_PSAVE_DIG_REQ_DIS                            66,  4,  1 // OPT_RX_BIT_MODE1_EO_PL :: disable digital rx slice power gating from link layer psav_req control
#define OPT_RX_PSAVE_ANA_REQ_DIS                            66,  5,  1 // OPT_RX_BIT_MODE1_EO_PL :: disable analog rx slice power gating from link layer psav_req control
#define OPT_RX_CAL_LANE_SEL                                 69,  0,  1 // OPT_RX_BIT_CNTLX1_EO_PL :: selects which lane to recalibrate.
#define OPT_RX_PIPE_SEL                                     69,  1,  2 // OPT_RX_BIT_CNTLX1_EO_PL :: selects what to mux onto the data pipe bus going to the calibration logic. \r\n\t00: first half main data, second half alt data \r\n\t01: first half main data, second half edge data \r\n\t10: double width deserialized main data \r\n\t11: reserved 
#define OPT_RX_BANK_SEL_A                                   69,  3,  1 // OPT_RX_BIT_CNTLX1_EO_PL :: selects which data bank to select for main data samples and alt data samples. \r\n\t0:(datab) data bank b is selected for main data, and data bank a is selected for alt data \r\n\t1:(dataa) data bank a is selected for main data, and data bank b is selected for alt data. 
#define OPT_RX_PIPE_MARGIN                                  69,  4,  1 // OPT_RX_BIT_CNTLX1_EO_PL :: adds extra cycles of padding on the async data pipe handshake
#define OPT_RX_SCOPE_MODE                                   69,  5,  2 // OPT_RX_BIT_CNTLX1_EO_PL :: adds extra cycles in the asyc crossing for scope mode
#define OPT_RX_BANK_PDWN                                    69,  7,  2 // OPT_RX_BIT_CNTLX1_EO_PL :: selects which of the data banks to power down (lightly) when not being used functionally or being actively recalibrated \r\n\t00: both banks powered up \r\n\t01:bank b only powered down \r\n\t10: bank a only powered down \r\n\t11 both bank a and b powered down 
#define OPT_RX_PL_SPARE_MODE_0                              62,  0,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_1                              62,  1,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_2                              62,  2,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_3                              62,  3,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_4                              62,  4,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_5                              62,  5,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_6                              62,  6,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_7                              62,  7,  1 // OPT_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_0                    80,  0,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_1                    80,  1,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_2                    80,  2,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_3                    80,  3,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_4                    80,  4,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_5                    80,  5,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_6                    80,  6,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_7                    80,  7,  1 // OPT_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_0                     43,  0,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_1                     43,  1,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_2                     43,  2,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_3                     43,  3,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_4                     43,  4,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_5                     43,  5,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_6                     43,  6,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_7                     43,  7,  1 // OPT_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define OPT_RX_BIST_ERR_A                                   81, 13,  1 // OPT_RX_WORK_STAT1_EO_PL :: indicates that rxbist did not find two data eyes of sufficient width while testing bank a.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_BIST_ERR_B                                   81, 14,  1 // OPT_RX_WORK_STAT1_EO_PL :: indicates that rxbist did not find two data eyes of sufficient width while testing bank b.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_BIST_ERR_E                                   81, 15,  1 // OPT_RX_WORK_STAT1_EO_PL :: indicates that rxbist did not find two data eyes of sufficient width while testing bank e.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_A_BAD_DFE_CONV                               82,  0,  1 // OPT_RX_WORK_STAT2_EO_PL :: eye opt step failed dfd convergence on bank a--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define OPT_RX_B_BAD_DFE_CONV                               82,  1,  1 // OPT_RX_WORK_STAT2_EO_PL :: eye opt step failed dfd convergence on bank b--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define OPT_RX_A_H1AP_AT_LIMIT                              82,  2,  1 // OPT_RX_WORK_STAT2_EO_PL :: eye opt h1/ap ratio limit hit bank a--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define OPT_RX_B_H1AP_AT_LIMIT                              82,  3,  1 // OPT_RX_WORK_STAT2_EO_PL :: eye opt h1/ap ratio limit hit bank_b--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define OPT_RX_A_AP                                         82,  4,  8 // OPT_RX_WORK_STAT2_EO_PL :: eye opt stored ap value
#define OPT_RX_A_PATH_OFF_EVEN                              83,  0,  6 // OPT_RX_WORK_STAT3_EO_PL :: eye opt a bank even path offset
#define OPT_RX_A_PATH_OFF_ODD                               83,  6,  6 // OPT_RX_WORK_STAT3_EO_PL :: eye opt a bank odd  path offset
#define OPT_RX_B_PATH_OFF_EVEN                              84,  0,  6 // OPT_RX_WORK_STAT4_EO_PL :: eye opt b bank even path offset
#define OPT_RX_B_PATH_OFF_ODD                               84,  6,  6 // OPT_RX_WORK_STAT4_EO_PL :: eye opt b bank odd  path offset
#define OPT_RX_A_BANK_CONTROLS                              44,  0,  6 // OPT_RX_DAC_CNTL1_EO_PL :: power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_RX_LANE_ANA_PDWN                                44,  6,  1 // OPT_RX_DAC_CNTL1_EO_PL :: lane power down of analog and custom circuits
#define OPT_RX_PRBS_TEST_DATA                               44,  7,  3 // OPT_RX_DAC_CNTL1_EO_PL :: prbs test data
#define OPT_RX_B_BANK_CONTROLS                              44, 10,  6 // OPT_RX_DAC_CNTL1_EO_PL :: power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_RX_A_CONTROLS                                   45,  0,  6 // OPT_RX_DAC_CNTL2_EO_PL :: bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tbit5 disables all the h-dacs when a 1\r\n\tcpg
#define OPT_RX_CM_CNTL                                      45,  6,  3 // OPT_RX_DAC_CNTL2_EO_PL :: bit0 enables integrator common mode cal, used in conjunction with integrator cal enable\r\n\tbit1 is the polarity bit\r\n\tbit 2 is common mode even when 1, odd when 0 /ncpg
#define OPT_RX_PR_HALFRATE_MODE                             45, 10,  1 // OPT_RX_DAC_CNTL2_EO_PL :: sets the rotator into half rate mode
#define OPT_RX_PR_IQ_RES_SEL                                45, 11,  3 // OPT_RX_DAC_CNTL2_EO_PL :: phase rotator iq resistor sellect
#define OPT_RX_A_OFFSET_E0                                  46,  0,  7 // OPT_RX_DAC_CNTL3_EO_PL :: this is the vertical offset of the even low threshold sampling latch.
#define OPT_RX_A_OFFSET_E1                                  46,  8,  7 // OPT_RX_DAC_CNTL3_EO_PL :: this is the vertical offset of the even high threshold sampling latch.
#define OPT_RX_A_OFFSET_O0                                  47,  0,  7 // OPT_RX_DAC_CNTL4_EO_PL :: this is the vertical offset of the odd low threshold sampling latch.
#define OPT_RX_A_OFFSET_O1                                  47,  8,  7 // OPT_RX_DAC_CNTL4_EO_PL :: this is the vertical offset of the odd high threshold sampling latch.
#define OPT_RX_A_INTEG_COARSE_GAIN                          48,  0,  4 // OPT_RX_DAC_CNTL5_EO_PL :: this is integrator coarse gain control used in making common mode adjustments. 
#define OPT_RX_A_EVEN_INTEG_FINE_GAIN                       48,  4,  5 // OPT_RX_DAC_CNTL5_EO_PL :: this is integrator gain control used in making common mode adjustments.
#define OPT_RX_A_ODD_INTEG_FINE_GAIN                        48,  9,  5 // OPT_RX_DAC_CNTL5_EO_PL :: this is integrator gain control used in making common mode adjustments. 
#define OPT_RX_A_CTLE_COARSE                                49,  0,  4 // OPT_RX_DAC_CNTL6_EO_PL :: this is the ctle coarse peak value, only 4 bits currently used thinking future  
#define OPT_RX_A_CTLE_GAIN                                  49,  5,  4 // OPT_RX_DAC_CNTL6_EO_PL :: this is the ctle gain setting           
#define OPT_RX_A_H1E_VAL                                    50,  0,  8 // OPT_RX_DAC_CNTL7_EO_PL :: dfe h1 value for even samplers
#define OPT_RX_A_H1O_VAL                                    50,  8,  8 // OPT_RX_DAC_CNTL7_EO_PL :: dfe h1 value for odd samplers
#define OPT_RX_AMP_VAL                                      51,  0,  8 // OPT_RX_DAC_CNTL8_EO_PL :: rx ampdac value stored as sign magnitude
#define OPT_RX_B_CONTROLS                                   52,  0,  5 // OPT_RX_DAC_CNTL1_O_PL :: bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tcpg
#define OPT_RX_B_OFFSET_E0                                  53,  0,  7 // OPT_RX_DAC_CNTL2_O_PL :: this is the vertical offset of the even low threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_OFFSET_E1                                  53,  8,  7 // OPT_RX_DAC_CNTL2_O_PL :: this is the vertical offset of the even high threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_OFFSET_O0                                  54,  0,  7 // OPT_RX_DAC_CNTL3_O_PL :: this is the vertical offset of the odd low threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_OFFSET_O1                                  54,  8,  7 // OPT_RX_DAC_CNTL3_O_PL :: this is the vertical offset of the odd high threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_INTEG_COARSE_GAIN                          55,  0,  4 // OPT_RX_DAC_CNTL4_O_PL :: this is integrator coarse gain control used in making common mode adjustments. 
#define OPT_RX_B_EVEN_INTEG_FINE_GAIN                       55,  4,  5 // OPT_RX_DAC_CNTL4_O_PL :: this is integrator gain control used in making common mode adjustments        
#define OPT_RX_B_ODD_INTEG_FINE_GAIN                        55,  9,  5 // OPT_RX_DAC_CNTL4_O_PL :: this is integrator gain control used in making common mode adjustments. 
#define OPT_RX_B_CTLE_COARSE                                56,  0,  4 // OPT_RX_DAC_CNTL5_O_PL :: this is the ctle coarse peak value                      
#define OPT_RX_B_CTLE_GAIN                                  56,  4,  4 // OPT_RX_DAC_CNTL5_O_PL :: this is the ctle gain setting           
#define OPT_RX_B_H1E_VAL                                    57,  0,  8 // OPT_RX_DAC_CNTL6_O_PL :: dfe h1 value for even samplers
#define OPT_RX_B_H1O_VAL                                    57,  8,  8 // OPT_RX_DAC_CNTL6_O_PL :: dfe h1 value for odd samplers
#define OPT_RX_E_CONTROLS                                   58,  0,  3 // OPT_RX_DAC_CNTL7_O_PL :: bit0 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit1 enables the amp dac for measurements in this bank/nbit2 enables fence for initloff\r\n\tcpg
#define OPT_RX_E_OFFSET_E                                   59,  0,  7 // OPT_RX_DAC_CNTL8_O_PL :: this is the vertical offset of the even low threshold sampling latch. the step size is vio/256.
#define OPT_RX_E_OFFSET_O                                   59,  8,  7 // OPT_RX_DAC_CNTL8_O_PL :: this is the vertical offset of the odd low threshold sampling latch. the step size is vio/256.
#define OPT_RX_E_INTEG_COARSE_GAIN                          60,  0,  4 // OPT_RX_DAC_CNTL9_O_PL :: this is integrator coarse gain control used in making common mode adjustments. 
#define OPT_RX_E_EVEN_INTEG_FINE_GAIN                       60,  4,  5 // OPT_RX_DAC_CNTL9_O_PL :: this is integrator gain control used in making common mode adjustments        
#define OPT_RX_E_ODD_INTEG_FINE_GAIN                        60,  9,  5 // OPT_RX_DAC_CNTL9_O_PL :: this is integrator gain control used in making common mode adjustments. 
#define OPT_RX_E_CTLE_COARSE                                61,  0,  4 // OPT_RX_DAC_CNTL10_O_PL :: this is the ctle coarse peak value                      
#define OPT_RX_E_CTLE_GAIN                                  61,  4,  4 // OPT_RX_DAC_CNTL10_O_PL :: this is the ctle gain setting           
#define OPT_RX_RUN_LANE                                     77,  0,  1 // OPT_RX_GLBSM_PL_CNTL1_O_PL :: run training and subsequent recalibration on given lane
#define OPT_RX_RUN_DCCAL                                    77,  1,  1 // OPT_RX_GLBSM_PL_CNTL1_O_PL :: run on-die dc training on given lane
#define OPT_RX_RECAL_REQ                                    77,  2,  1 // OPT_RX_GLBSM_PL_CNTL1_O_PL :: request recalibration on given lane
#define OPT_RX_RECAL_ABORT                                  77,  3,  1 // OPT_RX_GLBSM_PL_CNTL1_O_PL :: stop recalibration on given lane
#define OPT_RX_LANE_DISABLED                                77,  4,  1 // OPT_RX_GLBSM_PL_CNTL1_O_PL :: used to set the given lane to be ignored by training logic.  this does not affect powerdown.
#define OPT_RX_INIT_DONE                                    78,  0,  1 // OPT_RX_GLBSM_PL_STAT1_O_PL :: initial training complete on given lane
#define OPT_RX_DCCAL_DONE                                   78,  1,  1 // OPT_RX_GLBSM_PL_STAT1_O_PL :: on-die dc training complete on given lane
#define OPT_RX_LANE_BUSY                                    78,  2,  1 // OPT_RX_GLBSM_PL_STAT1_O_PL :: state machine busy indicator on given lane
#define OPT_RX_RECAL_DONE                                   78,  3,  1 // OPT_RX_GLBSM_PL_STAT1_O_PL :: recalibration done on given lane
#define OPT_RX_SET_RUN_LANE                                 79,  0,  1 // OPT_RX_GLBSM_PL_CNTL1X_O_PL :: set rx_run_lane register bit used by rx_bist_engine
#define OPT_RX_CLR_RUN_LANE                                 79,  1,  1 // OPT_RX_GLBSM_PL_CNTL1X_O_PL :: clear rx_run_lane register bit used by rx_bist_engine
#define OPT_RX_PL_FIR_ERRS_FULL_REG                         63,  0, 16 // OPT_RX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define OPT_RX_PL_FIR_ERRS                                  63,  0,  3 // OPT_RX_FIR_PL :: a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.
#define OPT_RX_PL_FIR_ERR_PL_REGS                           63,  0,  1 // OPT_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_DDC_SM                            63,  1,  1 // OPT_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx ddc state machine.
#define OPT_RX_PL_FIR_ERR_DAC_REGS                          63,  2,  1 // OPT_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx data dac regs.
#define OPT_RX_PL_FIR_ERRS_MASK_FULL_REG                    64,  0, 16 // OPT_RX_FIR_MASK_PL :: iotk alias: fir mask for rx_fir_pl errors.
#define OPT_RX_PL_FIR_ERRS_MASK                             64,  0,  3 // OPT_RX_FIR_MASK_PL :: fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.
#define OPT_RX_PL_FIR_ERR_MASK_PL_REGS                      64,  0,  1 // OPT_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane register parity errors.
#define OPT_RX_PL_FIR_ERR_MASK_DDC_SM                       64,  1,  1 // OPT_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane rx ddc state machine parity error.
#define OPT_RX_PL_FIR_ERR_MASK_DAC_REGS                     64,  2,  1 // OPT_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane rx data dac regs parity error.
#define OPT_RX_PL_FIR_ERR_INJ_FULL_REG                      65,  0, 16 // OPT_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_INJ                               65,  0,  3 // OPT_RX_FIR_ERROR_INJECT_PL :: rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tbit2: rx per-lane data dac regs parity error inject.
#define OPT_RX_PL_FIR_ERR_INJ_PL_REGS                       65,  0,  1 // OPT_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_INJ_DDC_SM                        65,  1,  1 // OPT_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.
#define OPT_RX_PL_FIR_ERR_INJ_DAC_REGS                      65,  2,  1 // OPT_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx data dac regs.
#define OPT_RX_PR_FW_OFF                                    67,  8,  1 // OPT_RX_BIT_MODE2_EO_PL :: removes the flywheel from the pr accumulator.  note, this is different than setting the inertia amount to zero.
#define OPT_RX_PR_FW_INERTIA_AMT                            67,  9,  3 // OPT_RX_BIT_MODE2_EO_PL :: amount to be added or subtracted from flywheel intertia.  note, setting this to zero may not turn off the flywheel if the flywheel accumulator already has a value (as if it were turned off after having run for some time).
#define OPT_RX_PR_PHASE_STEP                                67, 12,  4 // OPT_RX_BIT_MODE2_EO_PL :: amount to be added or subtracted from to phase rotator accumulator on each shift left or right.  0000: decoded as b10000 in logic, so pr will update every 4 shifts; other values will update with every 4*(16/phase_step) shifts.
#define OPT_RX_BER_CFG                                      68,  0,  3 // OPT_RX_BIT_MODE3_EO_PL :: this register controls the bit error rate threshold used for ddc. 
#define OPT_RX_FIFO_DLY_CFG                                 68,  3,  2 // OPT_RX_BIT_MODE3_EO_PL :: this register controls how many parallel clock cycles we wait after every change to the phase rotator before we begin using the data again. 
#define OPT_RX_DDC_CFG                                      68,  5,  2 // OPT_RX_BIT_MODE3_EO_PL :: this register controls how many parallel clock cycles we wait looking for errors as we march further into the edge.
#define OPT_RX_PR_EDGE_TRACK_CNTL                           70,  0,  2 // OPT_RX_BIT_CNTL2_EO_PL :: runs edge tracking on the selected bank.  00: no edge tracking, 01: tracks against a data, 10: tracks against b data, 11: unused.
#define OPT_RX_PR_WOBBLE_A                                  70,  2,  1 // OPT_RX_BIT_CNTL2_EO_PL :: wobbles the pr position for pr a for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_WOBBLE_B                                  70,  3,  1 // OPT_RX_BIT_CNTL2_EO_PL :: wobbles the pr position for pr b for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_WOBBLE_EDGE                               70,  4,  1 // OPT_RX_BIT_CNTL2_EO_PL :: wobbles the pr position for pr edge for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_DDC_A                                     70,  5,  1 // OPT_RX_BIT_CNTL2_EO_PL :: enables ddc state machine to go through its ddc routine on pr a.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges. 
#define OPT_RX_PR_DDC_B                                     70,  6,  1 // OPT_RX_BIT_CNTL2_EO_PL :: enables ddc state machine to go through its ddc routine on pr b.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges. 
#define OPT_RX_PR_BUMP_TO_EDGE_A                            70,  7,  1 // OPT_RX_BIT_CNTL2_EO_PL :: bumps pr a position to the edge => +(16 - clkadj).
#define OPT_RX_PR_BUMP_TO_EDGE_B                            70,  8,  1 // OPT_RX_BIT_CNTL2_EO_PL :: bumps pr b position to the edge. (not supported)
#define OPT_RX_PR_BUMP_SL_1UI                               70,  9,  1 // OPT_RX_BIT_CNTL2_EO_PL :: bumps the pr position of all prs to the next eye by shifting 32-steps. (not supported)
#define OPT_RX_PR_BUMP_SR_1UI                               70, 10,  1 // OPT_RX_BIT_CNTL2_EO_PL :: bumps the pr position to the previous eye by shifting 32-steps. (not supported)
#define OPT_RX_PR_BUMP_SL_1STEP                             70, 11,  1 // OPT_RX_BIT_CNTL2_EO_PL :: rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.
#define OPT_RX_PR_BUMP_SR_1STEP                             70, 12,  1 // OPT_RX_BIT_CNTL2_EO_PL :: rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.
#define OPT_RX_PR_USE_DFE_CLOCK_A                           70, 13,  1 // OPT_RX_BIT_CNTL2_EO_PL :: rx use a-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define OPT_RX_PR_USE_DFE_CLOCK_B                           70, 14,  1 // OPT_RX_BIT_CNTL2_EO_PL :: rx use b-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define OPT_RX_PR_DATA_A_OFFSET                             71,  0,  6 // OPT_RX_BIT_CNTL3_EO_PL :: offset value applied to pr a
#define OPT_RX_PR_DATA_B_OFFSET                             71,  6,  6 // OPT_RX_BIT_CNTL3_EO_PL :: offset value applied to pr b
#define OPT_RX_PR_BIT_LOCK_DONE                             71, 12,  1 // OPT_RX_BIT_CNTL3_EO_PL :: indicates that bit lock is done, used to gate invalid lock in the cdr logic
#define OPT_RX_PR_INVALID_LOCK_FILTER_EN                    71, 13,  1 // OPT_RX_BIT_CNTL3_EO_PL :: enables the filtered invalid_lock phase rotator shift_right. default is on.
#define OPT_RX_PR_INVALID_LOCK_BUMP_SIZE                    71, 14,  2 // OPT_RX_BIT_CNTL3_EO_PL :: sets the size of the invalid_lock_bump\r\n\t00: 0 steps\r\n\t01: 1 step\r\n\t10: 2 steps\r\n\t11: 4 steps
#define OPT_RX_PR_TRACE_DDC_STOP                            72,  0,  1 // OPT_RX_BIT_CNTL4_EO_PL :: enables the trace debug ddc state to stop the state machines.
#define OPT_RX_PR_TRACE_DDC_SM                              72,  1,  5 // OPT_RX_BIT_CNTL4_EO_PL :: determines when to stop the state machine for trace debug.
#define OPT_RX_PR_TRACE_WOBBLE_STOP                         72,  6,  1 // OPT_RX_BIT_CNTL4_EO_PL :: enables the trace debug wobble state to stop the state machines.
#define OPT_RX_PR_TRACE_WOBBLE_SM                           72,  7,  3 // OPT_RX_BIT_CNTL4_EO_PL :: determines when to stop the state machine for trace debug.
#define OPT_RX_PR_RESET                                     72, 14,  1 // OPT_RX_BIT_CNTL4_EO_PL :: set this to reset cdr logic.  power and clocks must be enabled in the slice.
#define OPT_RX_IORESET                                      72, 15,  1 // OPT_RX_BIT_CNTL4_EO_PL :: reset the given rx lane (except the cdr logic)
#define OPT_RX_PR_WOBBLE_A_IP                               74,  2,  1 // OPT_RX_BIT_STAT2_EO_PL :: wobble in progress on pr a.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_WOBBLE_B_IP                               74,  3,  1 // OPT_RX_BIT_STAT2_EO_PL :: wobble in progress on pr b.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_WOBBLE_EDGE_IP                            74,  4,  1 // OPT_RX_BIT_STAT2_EO_PL :: wobble in progress on pr edge.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_DDC_DONE                                  74,  5,  1 // OPT_RX_BIT_STAT2_EO_PL :: dynamic data centering in done on pr a or b.
#define OPT_RX_PR_DDC_FAILED                                74,  6,  1 // OPT_RX_BIT_STAT2_EO_PL :: dynamic data centering in failed on pr a or b.
#define OPT_RX_PR_BUMP_SL_1UI_DONE                          74,  8,  1 // OPT_RX_BIT_STAT2_EO_PL :: bump forward 1-ui into the next eye done.  becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define OPT_RX_PR_BUMP_SR_1UI_DONE                          74,  9,  1 // OPT_RX_BIT_STAT2_EO_PL :: bump minus 1-ui into the next eye done   becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away. 
#define OPT_RX_PR_TRACE_STOPPED                             74, 10,  1 // OPT_RX_BIT_STAT2_EO_PL :: indicates that the trace bus stop command has asserted.
#define OPT_RX_PR_L_R_EDGE_A_ALIAS                          75,  0, 12 // OPT_RX_BIT_STAT3_EO_PL :: rx phase rotator a bank leftand right edge alias
#define OPT_RX_PR_LEFT_EDGE_A                               75,  0,  6 // OPT_RX_BIT_STAT3_EO_PL :: rx phase rotator a bank left edge
#define OPT_RX_PR_RIGHT_EDGE_A                              75,  6,  6 // OPT_RX_BIT_STAT3_EO_PL :: rx phase rotator a bankright edge
#define OPT_RX_A_PR_DFE_CLKADJ                              75, 12,  4 // OPT_RX_BIT_STAT3_EO_PL :: tweak value in phase rotator steps for the bank a clock offset when doing dfe calibration
#define OPT_RX_PR_L_R_EDGE_B_ALIAS                          76,  0, 12 // OPT_RX_BIT_STAT1_O_PL :: rx phase rotator b bank left and right edge alias
#define OPT_RX_PR_LEFT_EDGE_B                               76,  0,  6 // OPT_RX_BIT_STAT1_O_PL :: rx phase rotator b bank left edge
#define OPT_RX_PR_RIGHT_EDGE_B                              76,  6,  6 // OPT_RX_BIT_STAT1_O_PL :: rx phase rotator b bank right edge
#define OPT_RX_B_PR_DFE_CLKADJ                              76, 12,  4 // OPT_RX_BIT_STAT1_O_PL :: tweak value in phase rotator steps for the bank b clock offset when doing dfe calibration
#define OPT_RX_PG_SPARE_MODE_0                              85,  0,  1 // OPT_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_1                              85,  1,  1 // OPT_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_2                              85,  2,  1 // OPT_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_3                              85,  3,  1 // OPT_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_4                              85,  4,  1 // OPT_RX_SPARE_MODE_PG :: chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.
#define OPT_RX_CLKDIST_PDWN                                 87,  0,  3 // OPT_RX_CTL_MODE1_EO_PG :: used to disable the rx group clocks and put them into a low power state. \r\n\t bit 0 disables slices 0-7 \r\n\t bit 1 disables slices 8-15 \r\n\t bit 2 disables slices 16-23
#define OPT_RX_BIST_MIN_EYE_WIDTH                           87,  3,  6 // OPT_RX_CTL_MODE1_EO_PG :: rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass.
#define OPT_RX_A_BIST_EN                                    87,  9,  1 // OPT_RX_CTL_MODE1_EO_PG :: bist enable pin
#define OPT_RX_B_BIST_EN                                    87, 10,  1 // OPT_RX_CTL_MODE1_EO_PG :: bist enable pin
#define OPT_RX_E_BIST_EN                                    87, 11,  1 // OPT_RX_CTL_MODE1_EO_PG :: bist enable pin
#define OPT_RX_BISTCLK_EN                                   87, 12,  2 // OPT_RX_CTL_MODE1_EO_PG :: bist clock enable pins
#define OPT_RX_DISABLE_BANK_PDWN                            87, 14,  1 // OPT_RX_CTL_MODE1_EO_PG :: used to disable powerdown of unused (functionally) bank
#define OPT_RX_DFE_CA_CFG                                   88,  0,  2 // OPT_RX_CTL_MODE2_EO_PG :: rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 8\r\n\t01 - 10\r\n\t10 - 12\r\n\t11 - 14\r\n\t  lab testing will be required to determine the proper value of k.
#define OPT_RX_SCOPE_CONTROL                                88,  2,  4 // OPT_RX_CTL_MODE2_EO_PG :: 4 bit value telling which scope bit we are capturing, valid values 0 through 9
#define OPT_RX_RECAL_REQ_DL_MASK                            88,  7,  1 // OPT_RX_CTL_MODE2_EO_PG :: mask rx_recal_req_dl primary inputs from data layer
#define OPT_RX_RECAL_DONE_DL_MASK                           88,  8,  1 // OPT_RX_CTL_MODE2_EO_PG :: mask rx_recal_done_dl primary inputs from data layer
#define OPT_RX_RUN_LANE_DL_MASK                             88,  9,  1 // OPT_RX_CTL_MODE2_EO_PG :: mask rx_run_lane_dl primary inputs from data layer
#define OPT_RX_RECAL_ABORT_DL_MASK                          88, 10,  1 // OPT_RX_CTL_MODE2_EO_PG :: mask rx_recal_abort_dl primary inputs from data layer
#define OPT_RX_INIT_DONE_DL_MASK                            88, 11,  1 // OPT_RX_CTL_MODE2_EO_PG :: mask rx_init_done_dl primary outputs to data layer
#define OPT_RX_DATA_PIPE_CLR_ON_READ_MODE                   88, 12,  1 // OPT_RX_CTL_MODE2_EO_PG :: data pipe capture on read mode.  when set, reading rx_data_pipe_16_31 will automatically capture new data.  otherwise rx_data_pipe_capture must be written.
#define OPT_RX_INT_RETURN                                  142, 13,  1 // OPT_RX_GLBSM_CNTL1_EO_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define OPT_RX_CLR_PAR_ERRS                                142, 14,  1 // OPT_RX_GLBSM_CNTL1_EO_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define OPT_RX_FIR_RESET                                   142, 15,  1 // OPT_RX_GLBSM_CNTL1_EO_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.
#define OPT_RX_BUS_ID                                       86,  0,  6 // OPT_RX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.
#define OPT_RX_MINIKERF                                    135,  0, 16 // OPT_RX_CTL_MODE1_O_PG :: rx minikerf control bits.\r\n\t  bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) only for centaur. all other buses use the tx_minikerf_pb\r\n\t (0:2)=011 - rx cleanup pll atst on pad_io_p. pad_io_n=0. \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - reserved. \r\n\t (0:2)=110 - rx cleanup pll clk on c4 pads. \r\n\t (0:2)=111 - reserved
#define OPT_RX_TRACKING_TIMEOUT_SEL                         89,  8,  4 // OPT_RX_CTL_MODE5_EO_PG :: time to wait for phase tracking to lock on the edge before proceding in the state machine (see workbook table 4.3 for timer settings)
#define OPT_RX_ABORT_CHECK_TIMEOUT_SEL                      91,  0,  4 // OPT_RX_CTL_MODE7_EO_PG :: selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define OPT_RX_POLLING_TIMEOUT_SEL                          91,  4,  4 // OPT_RX_CTL_MODE7_EO_PG :: selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define OPT_RX_DFE_CONVERGED_CNT_MAX                       104,  0,  4 // OPT_RX_CTL_MODE20_EO_PG :: number of iterations through dfe h1 and kh1ap adjust before ending dfe unless ended by rx_ap110ap010_delta criteria met\r\n\trjr
#define OPT_RX_AP110_AP010_DELTA_MAX                       104,  4,  4 // OPT_RX_CTL_MODE20_EO_PG :: maximum delta between apx110 and apx010 measurements to end dfe h1 and kh1ap adjust unless ended by dfe_converged_cnt_max\r\n\trjr
#define OPT_RX_EO_CONVERGED_END_COUNT                       90,  0,  4 // OPT_RX_CTL_MODE6_EO_PG :: rx eye optimization covergence counter end value\r\n\trjr
#define OPT_RX_HIST_MIN_EYE_WIDTH_MODE                      90,  4,  2 // OPT_RX_CTL_MODE6_EO_PG :: rx historic eye width and height minimum measurement mode \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_width_lane and  rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define OPT_RX_HIST_MIN_EYE_HEIGHT_MODE                     90,  6,  2 // OPT_RX_CTL_MODE6_EO_PG :: rx historic eye height minimum measurement mode--inoperative on naples dd1 hardware--use the rx_hist_min_eye_width_mode control instead--set both the width and height_mode controls to the same value in test routines to maintain compatibiliy \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define OPT_RX_AMP_GAIN_CNT_MAX                             90,  8,  4 // OPT_RX_CTL_MODE6_EO_PG :: maximum number of attempts to adjust vga gain before giving up. \r\n\t0000:1 \r\n\t0001: 2 \r\n\t0010:3  \r\n\t0011: 4 \r\n\t0100: 5 \r\n\t0101: 6 \r\n\t0110:7 \r\n\t0111:8  \r\n\t1000:9  \r\n\t1001:10  \r\n\t1010:11  \r\n\t1011:12  \r\n\t1100:13 \r\n\t1101:14 \r\n\t1110:15 \r\n\t1111:16 \r\n\trjr
#define OPT_RX_RC_SLOWDOWN_TIMEOUT_SEL                      90, 12,  4 // OPT_RX_CTL_MODE6_EO_PG :: selects recal  slowdown      timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 0   ui or   0us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define OPT_RX_RECAL_CNT                                   144,  0, 16 // OPT_RX_GLBSM_STAT2_EO_PG :: number of times bus has been recalibrated since initialization
#define OPT_RX_DACTEST_ISGT                                145,  0,  1 // OPT_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is greater than
#define OPT_RX_DACTEST_ISLT                                145,  1,  1 // OPT_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is lesser than
#define OPT_RX_DACTEST_ISEQ                                145,  2,  1 // OPT_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is equal to
#define OPT_RX_DACTEST_DIFF                                145,  3,  9 // OPT_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : difference 
#define OPT_RX_INT_REQ                                     146,  0, 16 // OPT_RX_GLBSM_STAT4_EO_PG :: rx interrupt request isolation latch
#define OPT_RX_PG_GLBSM_SPARE_MODE_0                       136,  0,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_1                       136,  1,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_2                       136,  2,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_3                       136,  3,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_4                       136,  4,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_5                       136,  5,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_6                       136,  6,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_7                       136,  7,  1 // OPT_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_FIR1_ERRS_FULL_REG                       137,  0, 16 // OPT_RX_FIR1_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define OPT_RX_PG_FIR_ERR_PG_REGS                          137,  0,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rxctl registers.
#define OPT_RX_PG_FIR_ERR_GCR_BUFF                         137,  1,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.
#define OPT_RX_PG_FIR_ERR_GCRS_LD_SM                       137,  2,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr load state machine.
#define OPT_RX_PG_FIR_ERR_GCRS_UNLD_SM                     137,  3,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr unload state machine.
#define OPT_RX_PG_FIR_ERR_GLBSM_REGS                       137,  4,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_GLBSM_REGRW                      137,  5,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_DATASM_REGS                      137,  6,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_DATASM_REGRW                     137,  7,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_EYEOPT_SM                        137,  8,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_BIST_MAIN_STATE                  137,  9,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_BIST_INIT_STATE                  137, 10,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_RX_SERVO_SM                      137, 11,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_WORK_REGS                        137, 12,  1 // OPT_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rx work regs.
#define OPT_RX_PL_FIR_ERR                                  137, 13,  1 // OPT_RX_FIR1_PG :: summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define OPT_FIR1_ERRS_MASK_FULL_REG                        138,  0, 16 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for rx_fir1_pg errors.
#define OPT_RX_PG_FIR1_ERRS_MASK                           138,  0, 13 // OPT_RX_FIR1_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.
#define OPT_FIR_ERR_MASK_PG_REGS                           138,  0,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl register checker.
#define OPT_FIR_ERR_MASK_GCR_BUFF                          138,  1,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr buffer.
#define OPT_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                  138,  2,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr load state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                138,  3,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GLBSM_REGS                  138,  4,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GLBSM_REGRW                 138,  5,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_DATASM_REGS                 138,  6,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_DATASM_REGRW                138,  7,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_EYEOPT_SM                   138,  8,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_BIST_MAIN_STATE             138,  9,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_BIST_INIT_STATE             138, 10,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_RX_SERVO_SM                 138, 11,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_WORK_REGS                   138, 12,  1 // OPT_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl work regs checker.
#define OPT_RX_PL_FIR_ERR_MASK                             138, 13,  1 // OPT_RX_FIR1_MASK_PG :: fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.
#define OPT_RX_PG_FIR1_ERR_INJ_FULL_REG                    139,  0, 16 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define OPT_RX_PG_FIR1_ERR_INJ                             139,  0, 13 // OPT_RX_FIR1_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.
#define OPT_RX_PG_FIR_ERR_INJ_PG_REGS                      139,  0,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GCR_BUFF                     139,  1,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.
#define OPT_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                   139,  2,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 139,  3,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GLBSM_REGS                   139,  4,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GLBSM_REGRW                  139,  5,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_DATASM_REGS                  139,  6,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_DATASM_REGRW                 139,  7,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_EYEOPT_SM                    139,  8,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_BIST_MAIN_STATE              139,  9,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_BIST_INIT_STATE              139, 10,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_RX_SERVO_SM                  139, 11,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_WORK_REGS                    139, 12,  1 // OPT_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl work regs checker.
#define OPT_RX_CAL_LANE_PG_PHY_GCRMSG                      116,  8,  5 // OPT_RX_CTL_CNTLX7_EO_PG :: encoded calibration lane in relation to the local, physical group.
#define OPT_RX_QUAD_SEL                                    107,  0,  2 // OPT_RX_CTL_MODE23_EO_PG :: select 1 of 4 possible phases for the deserialized rx io clock to send along with the data for integration flexibility and tuning for slack into the rx digital logic.
#define OPT_RX_IREF_RES_DAC                                107,  2,  3 // OPT_RX_CTL_MODE23_EO_PG :: twos complement control vector for setting magnitude of output current of res outputs.
#define OPT_RX_IREF_BYPASS                                 107,  9,  1 // OPT_RX_CTL_MODE23_EO_PG :: chicken-switch for bypassing closed loop controller for an open loop bias.
#define OPT_RX_IREF_PDWN_B                                 107, 10,  1 // OPT_RX_CTL_MODE23_EO_PG :: iref power down control (active low)
#define OPT_RX_DACTEST_LLMT                                120,  0,  9 // OPT_RX_CTL_CNTL11_EO_PG :: rx dactest control register : lower threshold limit
#define OPT_RX_DACTEST_RESET                               120,  9,  1 // OPT_RX_CTL_CNTL11_EO_PG :: rx dactest control register : reset
#define OPT_RX_DACTEST_START                               120, 10,  1 // OPT_RX_CTL_CNTL11_EO_PG :: rx dactest control register : start
#define OPT_RX_DACTEST_HLMT                                121,  0,  9 // OPT_RX_CTL_CNTL12_EO_PG :: rx dactest control register : higher threshold limit
#define OPT_RX_EYE_OPT_STATE                               143,  0, 12 // OPT_RX_GLBSM_STAT1_EO_PG :: eye optimizaton state machine current state 
#define OPT_RX_EO_ENABLE_INTEG_LATCH_OFFSET_CAL            105,  0,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization latch offset adjustment enable with integrator-based disable
#define OPT_RX_EO_ENABLE_CTLE_COARSE_CAL                   105,  1,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization coarse ctle/peakin enable
#define OPT_RX_EO_ENABLE_DAC_H1_CAL                        105,  2,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization h! dac calibration to reference
#define OPT_RX_EO_ENABLE_VGA_CAL                           105,  3,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization vga gainand offset adjust enable
#define OPT_RX_EO_ENABLE_DFE_H1_CAL                        105,  4,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization dfe h1  adjust enable
#define OPT_RX_EO_ENABLE_H1AP_TWEAK                        105,  5,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization h1/an pr adjust enable
#define OPT_RX_EO_ENABLE_DDC                               105,  6,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization dynamic data centering enable
#define OPT_RX_EO_ENABLE_CM_COARSE_CAL                     105,  9,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization common mode coarse calibration enable
#define OPT_RX_EO_ENABLE_CM_FINE_CAL                       105, 10,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization common mode fine calibration enable
#define OPT_RX_EO_ENABLE_VGA_EDGE_OFFSET_CAL               105, 13,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization edge offset calibration enable during vga calibration\r\n\trjr
#define OPT_RX_EO_ENABLE_CTLE_EDGE_OFFSET_CAL              105, 14,  1 // OPT_RX_CTL_MODE21_EO_PG :: rx eye optimization edge offset calibration enable during ctle calibration\r\n\trjr
#define OPT_RX_EO_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         128,  0,  1 // OPT_RX_CTL_MODE26_EO_PG :: rx eye optimization first latch offsett adjustment enable with ctle-based disable
#define OPT_RX_EO_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         128,  1,  1 // OPT_RX_CTL_MODE26_EO_PG :: rx eye optimization second latch offsett adjustment enable with ctle-based disable
#define OPT_RX_EO_ENABLE_VGA_AMAX_MODE                     128, 14,  1 // OPT_RX_CTL_MODE26_EO_PG :: rx eye optimization vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define OPT_RX_RC_ENABLE_INTEG_LATCH_OFFSET_CAL            106,  0,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    latch offset adjustment enable with integrator-based disable
#define OPT_RX_RC_ENABLE_CTLE_COARSE_CAL                   106,  1,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    coarse ctle/peakin enable
#define OPT_RX_RC_ENABLE_DAC_H1_CAL                        106,  2,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    h! dac calibration to reference
#define OPT_RX_RC_ENABLE_VGA_CAL                           106,  3,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    vga gainand offset adjust enable
#define OPT_RX_RC_ENABLE_DFE_H1_CAL                        106,  4,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    dfe h1  adjust enable
#define OPT_RX_RC_ENABLE_H1AP_TWEAK                        106,  5,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    h1/an pr adjust enable
#define OPT_RX_RC_ENABLE_DDC                               106,  6,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    dynamic data centering enable
#define OPT_RX_RC_ENABLE_CM_COARSE_CAL                     106,  9,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    common mode coarse calibration enable
#define OPT_RX_RC_ENABLE_CM_FINE_CAL                       106, 10,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    common mode fine calibration enable
#define OPT_RX_RC_ENABLE_VGA_EDGE_OFFSET_CAL               106, 13,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    edge offset calibration enable during vga calibration\r\n\trjr
#define OPT_RX_RC_ENABLE_CTLE_EDGE_OFFSET_CAL              106, 14,  1 // OPT_RX_CTL_MODE22_EO_PG :: rx recalibration    edge offset calibration enable during ctle calibration\r\n\trjr
#define OPT_RX_RC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         129,  0,  1 // OPT_RX_CTL_MODE27_EO_PG :: rx recalibration    first latch offsett adjustment enable with ctle-based disable
#define OPT_RX_RC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         129,  1,  1 // OPT_RX_CTL_MODE27_EO_PG :: rx recalibratoin    second latch offsett adjustment enable with ctle-based disable
#define OPT_RX_RC_ENABLE_VGA_AMAX_MODE                     129, 14,  1 // OPT_RX_CTL_MODE27_EO_PG :: rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define OPT_RX_RC_ENABLE_AUTO_RECAL                        129, 15,  1 // OPT_RX_CTL_MODE27_EO_PG :: rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define OPT_RX_DC_ENABLE_CM_COARSE_CAL                     130,  0,  1 // OPT_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization common mode coarse calibration enable
#define OPT_RX_DC_ENABLE_CM_FINE_CAL                       130,  1,  1 // OPT_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization common mode fine calibration enable
#define OPT_RX_DC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         130,  2,  1 // OPT_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done prior to ctle
#define OPT_RX_DC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         130,  3,  1 // OPT_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done after to ctle
#define OPT_RX_DC_ENABLE_INTEG_LATCH_OFFSET_CAL            130,  6,  1 // OPT_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done prior to integrator
#define OPT_RX_AMAX_HIGH                                   101,  0,  8 // OPT_RX_CTL_MODE17_EO_PG :: rx amax high target in amplitude dac steps (as measured by 2ap-amin method) default d120
#define OPT_RX_AMAX_LOW                                    101,  8,  8 // OPT_RX_CTL_MODE17_EO_PG :: rx amax low target in amplitude dac steps (as measured by 2ap-amin method)  defaulot d80
#define OPT_RX_APX111_HIGH                                 109,  0,  8 // OPT_RX_CTL_MODE29_EO_PG :: rx amax high target in amplitude dac steps (as measured by ap_x111 and an_x000) default d102
#define OPT_RX_APX111_LOW                                  109,  8,  8 // OPT_RX_CTL_MODE29_EO_PG :: rx amax low target in amplitude dac steps (as measured by ap_x111 and an_x000)  default d68
#define OPT_RX_CTLE_GAIN_MAX                               103,  0,  4 // OPT_RX_CTL_MODE19_EO_PG :: rx ctle (vga) gain maximum allowable gain value
#define OPT_RX_AMP_START_VAL                               103,  8,  8 // OPT_RX_CTL_MODE19_EO_PG :: rx amp start value, used when making amplitude measurements as the starting point
#define OPT_RX_TRC_MODE                                    111,  0,  4 // OPT_RX_CTL_CNTL2_EO_PG :: rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd
#define OPT_RX_MIN_EYE_WIDTH                                93,  2,  6 // OPT_RX_CTL_MODE9_EO_PG :: minimum acceptable eye width used during init or recal results checking--edi or ei4
#define OPT_RX_MIN_EYE_HEIGHT                               93,  8,  8 // OPT_RX_CTL_MODE9_EO_PG :: minimum acceptable eye height used during init or recal results checking--edi only
#define OPT_RX_INT_MODE                                    112,  0,  4 // OPT_RX_CTL_CNTL3_EO_PG :: rx interrupt mode setting
#define OPT_RX_INT_CURRENT_STATE                           112,  4, 12 // OPT_RX_CTL_CNTL3_EO_PG :: rx interrupt current state to stop on
#define OPT_RX_INT_ENABLE_ENC                              113,  0,  4 // OPT_RX_CTL_CNTL4_EO_PG :: rx interrupt encoded enable
#define OPT_RX_INT_NEXT_STATE                              113,  4, 12 // OPT_RX_CTL_CNTL4_EO_PG :: rx interrupt next state to stop on
#define OPT_RX_INT_GOTO_STATE                              114,  4, 12 // OPT_RX_CTL_CNTL5_EO_PG :: rx interrupt state to go to upon interrupt trigger
#define OPT_RX_INT_RETURN_STATE                            115,  4, 12 // OPT_RX_CTL_CNTL6_EO_PG :: rx interrupt state to go to upon return from interrupt code
#define OPT_RX_AMP_INIT_TIMEOUT                             98,  0,  4 // OPT_RX_CTL_MODE14_EO_PG :: rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.3 for timer settings)
#define OPT_RX_AMP_RECAL_TIMEOUT                            98,  4,  4 // OPT_RX_CTL_MODE14_EO_PG :: rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.3 for timer settings)
#define OPT_RX_PEAK_INIT_TIMEOUT                            98,  8,  4 // OPT_RX_CTL_MODE14_EO_PG :: rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.3 for timer settings)
#define OPT_RX_PEAK_RECAL_TIMEOUT                           98, 12,  4 // OPT_RX_CTL_MODE14_EO_PG :: rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.3 for timer settings)
#define OPT_RX_OFF_INIT_TIMEOUT                             99,  0,  4 // OPT_RX_CTL_MODE15_EO_PG :: rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.3 for timer settings)
#define OPT_RX_OFF_RECAL_TIMEOUT                            99,  4,  4 // OPT_RX_CTL_MODE15_EO_PG :: rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.3 for timer settings)
#define OPT_RX_CM_TIMEOUT                                   99,  8,  4 // OPT_RX_CTL_MODE15_EO_PG :: rx_cm_timeout            used for common mode measurements         (see workbook table 4.3 for timer settings)
#define OPT_RX_AMIN_TIMEOUT                                 99, 12,  4 // OPT_RX_CTL_MODE15_EO_PG :: rx_amin_timeout        used for amin masurements                   (see workbook table 4.3 for timer settings)
#define OPT_RX_AMP_TIMEOUT                                 100,  0,  4 // OPT_RX_CTL_MODE16_EO_PG :: rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.3 for timer settings)
#define OPT_RX_USERDEF_TIMEOUT                             100,  4,  4 // OPT_RX_CTL_MODE16_EO_PG :: rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.3 for timer settings)
#define OPT_RX_BER_TIMEOUT                                 100,  8,  4 // OPT_RX_CTL_MODE16_EO_PG :: rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.3 for timer settings)
#define OPT_RX_SPARE4_TIMEOUT                              100, 12,  4 // OPT_RX_CTL_MODE16_EO_PG :: rx_spare4_timeout just a spare for now                              (see workbook table 4.3 for timer settings)
#define OPT_RX_AMP_INIT_CFG                                 94,  0,  3 // OPT_RX_CTL_MODE10_EO_PG :: rx_amp_init_cfg   this register controls the servo filter for amplitude measurements during init. see workbook table 4.4 for settings
#define OPT_RX_AMP_RECAL_CFG                                94,  3,  3 // OPT_RX_CTL_MODE10_EO_PG :: rx_amp_recal_cfg      this register controls the servo filter for amplitude measurements during recal. see workbook table 4.4 for settings
#define OPT_RX_PEAK_INIT_CFG                                94,  6,  3 // OPT_RX_CTL_MODE10_EO_PG :: rx_peak_init_cfg  this register controls the servo filter for peaking during init. see workbook table 4.4 for settings
#define OPT_RX_PEAK_RECAL_CFG                               94,  9,  3 // OPT_RX_CTL_MODE10_EO_PG :: rx_peak_recal_cfg      this register controls the servo filter for peaking during recal. see workbook table 4.4 for settings
#define OPT_RX_AMP_CFG                                      94, 12,  4 // OPT_RX_CTL_MODE10_EO_PG :: rx_amp_cfg   this register controls the servo filter for rx_amp_0 and rx_amp_1 servo ops. see workbook table 4.4 for settings
#define OPT_RX_OFF_INIT_CFG                                 95,  0,  3 // OPT_RX_CTL_MODE11_EO_PG :: rx_off_init_cfg   this register controls the servo filter for offset measurements during init. see workbook table 4.4 for settings
#define OPT_RX_OFF_RECAL_CFG                                95,  3,  3 // OPT_RX_CTL_MODE11_EO_PG :: rx_off_recal_cfg  this register controls the servo filter for offset measurements during recal. see workbook table 4.4 for settings
#define OPT_RX_CM_CFG                                       95,  6,  3 // OPT_RX_CTL_MODE11_EO_PG :: rx_cm_cfg          this register controls the servo during common mode measurement. see workbook table 4.4 for settings
#define OPT_RX_AMIN_CFG                                     95,  9,  3 // OPT_RX_CTL_MODE11_EO_PG :: rx_amin_cfg        this register controls the servo filtering used for amin measuremnts. see workbook table 4.4 for settings
#define OPT_RX_USERDEF_CFG                                  95, 12,  4 // OPT_RX_CTL_MODE11_EO_PG :: rx_user_cfg      this register controls the servo filtering when running the user defined servo ops table 4.4 for settings
#define OPT_RX_H1AP_CFG                                    108,  0,  2 // OPT_RX_CTL_MODE24_EO_PG :: this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. \r\n\t00:.5 \r\n\t01:.625 \r\n\t10:.25 \r\n\t11:.375
#define OPT_RX_CTLE_UPDATE_MODE                            108,  2,  1 // OPT_RX_CTL_MODE24_EO_PG :: controls updating of ctle_coarse (peaking) values: \r\n\t0: update edge and a or b peaking values while servoing \r\n\t1: update a or b peaking values after edge bank servoing complete
#define OPT_RX_USER_FILTER_MASK                            108,  8,  8 // OPT_RX_CTL_MODE24_EO_PG :: rx_user_filter_mask   this register controls the filter and mask for user defined servo ops.
#define OPT_RX_AMP0_FILTER_MASK                            102,  0,  8 // OPT_RX_CTL_MODE18_EO_PG :: rx_amp_0_filter_mask   this register controls the filter and mask for the amp_0 servo ops.
#define OPT_RX_AMP1_FILTER_MASK                            102,  8,  8 // OPT_RX_CTL_MODE18_EO_PG :: rx_amp_1_filter_mask   this register controls the filter and mask for the amp_1 servo ops.
#define OPT_RX_SERVO_CHG_CFG                                96,  0,  4 // OPT_RX_CTL_MODE12_EO_PG :: this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point. 
#define OPT_RX_DAC_BO_CFG                                   96,  4,  3 // OPT_RX_CTL_MODE12_EO_PG :: this register controls the time of the dac black out time.  see workbook dfe section
#define OPT_RX_FILTER_MODE                                  96,  7,  2 // OPT_RX_CTL_MODE12_EO_PG :: servo filter mode. 00 means normal filter duirng entire op. 01 means use the 1/4-1/2 mode, 10 means 1/8-1/4 mode and 11 means the automatic convergence detect mode
#define OPT_RX_MISC_CFG                                     96,  9,  2 // OPT_RX_CTL_MODE12_EO_PG :: per group rx misc configureation bits, bit 0 is chicken bit to re-enable the progressive filter mode for peaking, bit 1 when a 1 will enable the clearing of h1 during the amp0, amp1, and usrdef servo ops
#define OPT_RX_DISABLE_H1_CLEAR                             96, 11,  1 // OPT_RX_CTL_MODE12_EO_PG :: per group when set will disable the clearing when running servo ops which normally clear and restore the h1 registers
#define OPT_RX_VOFF_CFG                                     96, 12,  3 // OPT_RX_CTL_MODE12_EO_PG :: per group configuration regiseter for setting the filter value when running the vref version of offset on edge latches
#define OPT_RX_LOFF_AMP_EN                                  96, 15,  1 // OPT_RX_CTL_MODE12_EO_PG :: when set to a 1 the amp dac will be enabled during the loff versions of local latch offset cancellation
#define OPT_RX_CM_OFFSET_VAL                                97,  1,  7 // OPT_RX_CTL_MODE13_EO_PG :: value used to offset the amp dac when running common mode
#define OPT_RX_SERVO_THRESH1                                97,  8,  4 // OPT_RX_CTL_MODE13_EO_PG :: value used as threshold of when to switch to normal filtering mode
#define OPT_RX_SERVO_THRESH2                                97, 12,  4 // OPT_RX_CTL_MODE13_EO_PG :: value used as threshold of when we think the servo has converged
#define OPT_RX_BIST_EN                                     118,  0,  1 // OPT_RX_CTL_CNTL9_EO_PG :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define OPT_RX_BIST_EXT_START_MODE                         118,  1,  1 // OPT_RX_CTL_CNTL9_EO_PG :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define OPT_RX_BIST_INIT_DISABLE                           118,  2,  3 // OPT_RX_CTL_CNTL9_EO_PG :: each bit disables an individual step of the rx bist init state machine when raised; bit 0 disables the cu pll lock, bit 1 disables the rx fifo init, and bit 2 disables eye opt/training
#define OPT_RX_BIST_CUPLL_LOCK_CHECK_EN                    118,  5,  1 // OPT_RX_CTL_CNTL9_EO_PG :: this bit enables the cu pll lock check mode of the rx bist init state machine. when set high, the test will check for the pll lock signal and set an error if it is not present.
#define OPT_RX_BIST_STORE_EYES_LANE_SEL                    118,  6,  6 // OPT_RX_CTL_CNTL9_EO_PG :: this register selects which lane to store rx bist eye width data from. the data is stored in the rx_bist_eye_a_width and rx_bist_eye_b_width registers.
#define OPT_RX_BIST_STORE_EYES_BANK_SEL                    118, 12,  2 // OPT_RX_CTL_CNTL9_EO_PG :: this register selects which bank to store rx bist eye width data from. \r\n\t00:(bank_a) store bank a widths\r\n\t01:(bank_b) store bank b widths\r\n\t10:(bank_e) store bank e widths\r\n\t11:(unused) unused
#define OPT_RX_BIST_LL_TEST_EN                             118, 14,  1 // OPT_RX_CTL_CNTL9_EO_PG :: this bit enables the link test portion of rx bist
#define OPT_RX_PERVASIVE_CAPT                              118, 15,  1 // OPT_RX_CTL_CNTL9_EO_PG :: this bit latches glb_ctl and jtag_bndy pervasive signals in iocrc_pervasive_capt when set high. ro reg bit rx_prvcpt_change_det goes high when latched values differ from pervasive inputs.
#define OPT_RX_BIST_PRBS_TEST_TIME                         119,  0,  4 // OPT_RX_CTL_CNTL10_EO_PG :: controls how long rx bist will test the prbs7 data for errors. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define OPT_RX_BIST_BUS_DATA_MODE                          119,  4,  1 // OPT_RX_CTL_CNTL10_EO_PG :: this bit enables a mode where rx bist tests data from the bus
#define OPT_RX_BIST_PRBS_PROP_TIME                         119,  5,  4 // OPT_RX_CTL_CNTL10_EO_PG :: controls how long rx bist waits between incrementing a phaserot and begining to test the prbs data. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define OPT_RX_BIST_INIT_DONE                              126,  0,  1 // OPT_RX_CTL_STAT2_EO_PG :: this bit signals completion of the rx bist init state machine.
#define OPT_RX_BIST_DONE                                   126,  1,  1 // OPT_RX_CTL_STAT2_EO_PG :: this bit signals completion of the entire rx bist procedure.
#define OPT_RX_BIST_LL_ERR                                 126,  2,  1 // OPT_RX_CTL_STAT2_EO_PG :: this bit indicates an error was detected during the link layer test portion of rx bist.
#define OPT_RX_BIST_NO_EDGE_DET                            126,  3,  1 // OPT_RX_CTL_STAT2_EO_PG :: this bit indicates that one eye was counted to be significantly large (over 60 phase rotator steps).
#define OPT_RX_BIST_EYE_A_WIDTH                            126,  4,  6 // OPT_RX_CTL_STAT2_EO_PG :: this register holds the counted eye a width of one particular lane.
#define OPT_RX_BIST_EYE_B_WIDTH                            126, 10,  6 // OPT_RX_CTL_STAT2_EO_PG :: this register holds the counted eye b width of one particular lane.
#define OPT_RX_BER_COUNT_CLR                               148,  1,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define OPT_RX_BER_TIMER_CLR                               148,  2,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: diag ber timer clear pulse. when written to a 1 the timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define OPT_RX_SCOPE_CAPTURE                               148,  3,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: when written to a 1 it will cause the scope capture register to copy the current main input
#define OPT_RX_DATA_PIPE_CAPTURE                           148,  4,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define OPT_RX_RESET_SERVO_STATUS                          148,  5,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define OPT_RX_BER_RESET                                   148,  6,  1 // OPT_RX_DATASM_CNTLX1_EO_PG :: diag ber reset pulse. when written to a 1 it will clear both the error counter and timer.
#define OPT_RX_BER_EN                                      110,  0,  1 // OPT_RX_CTL_CNTL1_EO_PG :: diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.
#define OPT_RX_BER_TIMER_FREEZE_EN                         110,  1,  1 // OPT_RX_CTL_CNTL1_EO_PG :: diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the timer is frozen when any lane error count saturates in that pack.
#define OPT_RX_BER_COUNT_FREEZE_EN                         110,  2,  1 // OPT_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.
#define OPT_RX_BER_COUNT_SEL                               110,  3,  4 // OPT_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t0000:(1) 1\r\n\t0001:(2) 2\r\n\t0010:(4) 4\r\n\t0011:(8) 8\r\n\t0100:(16) 16\r\n\t0101:(32) 32\r\n\t0110:(64) 64\r\n\t0111:(128) 128\r\n\t1000: (256) 256\r\n\t1001: (512) 512\r\n\t1010: (1024) 1024\r\n\t1011: (unused1) unused1\r\n\t1100: (unused2) unused2\r\n\t1101: (unused3) unused3\r\n\t1110: (unused4) unused4\r\n\t1111: (unused5) unused5
#define OPT_RX_BER_TIMER_SEL                               110,  8,  3 // OPT_RX_CTL_CNTL1_EO_PG :: diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t000:(2tothe31st) 2^31\r\n\t001:(2tothe27th) 2^27\r\n\t010:(2tothe23rd) 2^23\r\n\t011:(2tothe19th) 2^19\r\n\t100:(2tothe17th) 2^17\r\n\t101:(2tothe13th) 2^13\r\n\t110:(2tothe9th) 2^9\r\n\t111:(2tothe5th) 2^5
#define OPT_RX_BER_CLR_COUNT_ON_READ_EN                    110, 11,  1 // OPT_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.
#define OPT_RX_BER_CLR_TIMER_ON_READ_EN                    110, 12,  1 // OPT_RX_CTL_CNTL1_EO_PG :: diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes timer when it is read from any lane in the pack.
#define OPT_RX_DATA_PIPE_0_15                              152,  0, 16 // OPT_RX_DATASM_STAT4_EO_PG :: data pipe captured output bits 0-15.
#define OPT_RX_DATA_PIPE_16_31                             153,  0, 16 // OPT_RX_DATASM_STAT5_EO_PG :: data pipe captured output bits 16-31.
#define OPT_RX_SERVO_OP                                    117,  0, 15 // OPT_RX_CTL_CNTL8_EO_PG :: servo operation code, written by global training state machine
#define OPT_RX_SERVO_DONE                                  117, 15,  1 // OPT_RX_CTL_CNTL8_EO_PG :: servo op completed, read by global training state machine
#define OPT_RX_SERVO_RESULT                                125,  0,  8 // OPT_RX_CTL_STAT1_EO_PG :: servo op result, read by global training state machine
#define OPT_RX_HIST_MIN_EYE_WIDTH_VALID                    122,  0,  1 // OPT_RX_CTL_CNTL13_EO_PG :: rx historic eye width minimum value and lane are valid.
#define OPT_RX_HIST_MIN_EYE_WIDTH_LANE                     122,  1,  5 // OPT_RX_CTL_CNTL13_EO_PG :: rx historic eye width lane number
#define OPT_RX_HIST_MIN_EYE_WIDTH                          122,  6,  8 // OPT_RX_CTL_CNTL13_EO_PG :: rx historic eye width minimum value.
#define OPT_RX_HIST_MIN_EYE_HEIGHT_VALID                   123,  0,  1 // OPT_RX_CTL_CNTL14_EO_PG :: rx historic eye height minimum value and lane are valid.
#define OPT_RX_HIST_MIN_EYE_HEIGHT_LANE                    123,  1,  5 // OPT_RX_CTL_CNTL14_EO_PG :: rx historic eye height lane number.
#define OPT_RX_HIST_MIN_EYE_HEIGHT                         123,  6,  8 // OPT_RX_CTL_CNTL14_EO_PG :: rx historic eye height minimum value (peak-to-peak).
#define OPT_RX_SERVO_STATUS                                154,  0, 16 // OPT_RX_DATASM_STAT6_EO_PG :: per group servo status. , bits 0-10 are the servo op captured, bits 11-15 are the lane captured. no error if bits 0 to 10 are all zeroes
#define OPT_RX_SERVO_CHG_CNT                               155,  0,  4 // OPT_RX_DATASM_STAT7_EO_PG :: per group servo status. 4 bit value of the number of times the accumulator reversed directions during op, value is fluid except when bit 0 of servo_status is a 1.
#define OPT_RX_IREF_PARITY_CHK                             155, 11,  4 // OPT_RX_DATASM_STAT7_EO_PG :: iref control parity observation bits
#define OPT_RX_PRVCPT_CHANGE_DET                           155, 15,  1 // OPT_RX_DATASM_STAT7_EO_PG :: read only bit that signals when a change has been detected in the captured pervasive signals in iocrc_pervasive_capt
#define OPT_RX_SCAN_P_0_15                                 156,  0, 16 // OPT_RX_DATASM_STAT8_EO_PG :: rx boundary scan ovservation : p  0 to 15
#define OPT_RX_SCAN_P_16_23                                157,  0,  9 // OPT_RX_DATASM_STAT9_EO_PG :: rx boundary scan ovservation : p 16 to 23
#define OPT_RX_SCAN_N_16_23                                158,  8,  8 // OPT_RX_DATASM_STAT10_EO_PG :: rx boundary scan ovservation : n 16 to 23
#define OPT_RX_SCAN_N_0_15                                 159,  0, 16 // OPT_RX_DATASM_STAT11_EO_PG :: rx boundary scan ovservation : n  0 to 15
#define OPT_RX_BER_COUNT                                   149,  0, 11 // OPT_RX_DATASM_STAT1_EO_PG :: per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.
#define OPT_RX_BER_COUNT_SATURATED                         149, 11,  1 // OPT_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter saturation indicator. when 1 indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.
#define OPT_RX_BER_COUNT_FROZEN_BY_ERR_CNT                 149, 12,  1 // OPT_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter and or pp timer has been frozen by another lanes error counter being saturated.
#define OPT_RX_BER_COUNT_FROZEN_BY_TIMER                   149, 13,  1 // OPT_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter has been frozen by a diag ber timer becoming saturated.
#define OPT_RX_BER_TIMER_SATURATED                         149, 14,  1 // OPT_RX_DATASM_STAT1_EO_PG :: pl diag ber timer saturation indicator. when 1 indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.
#define OPT_RX_BER_TIMER_VALUE_0_15                        150,  0, 16 // OPT_RX_DATASM_STAT2_EO_PG :: pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.
#define OPT_RX_BER_TIMER_VALUE_16_31                       151,  0, 16 // OPT_RX_DATASM_STAT3_EO_PG :: pl diag ber timer value, bits 16-31.
#define OPT_RX_PG_DATASM_SPARE_MODE_0                      147,  0,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_1                      147,  1,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_2                      147,  2,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_3                      147,  3,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_4                      147,  4,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_5                      147,  5,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_6                      147,  6,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_7                      147,  7,  1 // OPT_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define OPT_RX_INTR_MSG                                    164,  0, 16 // OPT_RX_INTR_MSG_PB :: dummy intr gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define OPT_RX_FIR_MSG                                     165,  0,  8 // OPT_RX_FIR_MSG_PB :: dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define OPT_RX_PB_CLR_PAR_ERRS                             160, 14,  1 // OPT_RX_FIR_RESET_PB :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.
#define OPT_RX_PB_FIR_RESET                                160, 15,  1 // OPT_RX_FIR_RESET_PB :: fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.
#define OPT_RX_PB_FIR_ERRS_FULL_REG                        161,  0, 10 // OPT_RX_FIR_PB :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.
#define OPT_RX_PB_FIR_ERRS                                 161,  0, 10 // OPT_RX_FIR_PB :: a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_PB_REGS                          161,  0,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF0                        161,  1,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr buffer.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF1                        161,  2,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF2                        161,  3,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM0                      161,  4,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM1                      161,  5,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM2                      161,  6,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM0                    161,  7,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM1                    161,  8,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM2                    161,  9,  1 // OPT_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.
#define OPT_RX_PB_FIR_ERRS_MASK_FULL_REG                   162,  0, 10 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for rx_fir_pb errors.
#define OPT_RX_PB_FIR_ERRS_MASK                            162,  0, 10 // OPT_RX_FIR_MASK_PB :: fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_MASK_PB_REGS                     162,  0,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF0                   162,  1,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr buffer.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF1                   162,  2,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF2                   162,  3,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                 162,  4,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                 162,  5,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                 162,  6,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0               162,  7,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1               162,  8,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2               162,  9,  1 // OPT_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.
#define OPT_RX_PB_FIR_ERRS_INJ_FULL_REG                    163,  0, 10 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define OPT_RX_PB_FIR_ERRS_INJ                             163,  0, 10 // OPT_RX_FIR_ERROR_INJECT_PB :: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_INJ_PB_REGS                      163,  0,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_INJ_GCR_BUFF0                    163,  1,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr buffer.
#define OPT_RX_PB_FIR_ERR_INJ_GCR_BUFF1                    163,  2,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1.
#define OPT_RX_PB_FIR_ERR_INJ_GCR_BUFF2                    163,  3,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                  163,  4,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                  163,  5,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                  163,  6,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0                163,  7,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1                163,  8,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2                163,  9,  1 // OPT_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.
#define OPT_GCR_TEST_MODE                                  166,  0,  1 // OPT_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define OPT_ENABLE_GCR_OFL_BUFF                            166,  1,  1 // OPT_SCOM_MODE_PB :: enables 2nd gcr overflow buffer, one is used by default.
#define OPT_IORESET_HARD_BUS0                              166,  2,  1 // OPT_SCOM_MODE_PB :: io hard reset per-bus and gcr reset
#define OPT_MMIO_PG_REG_ACCESS                             166,  3,  1 // OPT_SCOM_MODE_PB :: mmio pg register access is blocked by default. setting this bit high grants mmio access to the pg regs.
#define OPT_SCOM_MODE_PB_SPARES1                           166,  4,  4 // OPT_SCOM_MODE_PB :: scom mode reg spares.
#define OPT_GCR_HANG_DET_SEL                               166,  8,  3 // OPT_SCOM_MODE_PB :: gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 63 cycles\r\n\t010: 127 cycles\r\n\t011: 255 cycles\r\n\t100: 511 cycles\r\n\t101: 1023 cycles\r\n\t110: 2047 cycles\r\n\t111: 4096 cycles.
#define OPT_GCR_BUFFER_ENABLED                             166, 11,  1 // OPT_SCOM_MODE_PB :: flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.
#define OPT_GCR_HANG_ERROR_MASK                            166, 12,  1 // OPT_SCOM_MODE_PB :: mask for gcr hang error when 2nd buffer is enabled.
#define OPT_GCR_HANG_ERROR_INJ                             166, 13,  1 // OPT_SCOM_MODE_PB :: inject for gcr hang error.
#define OPT_PPE_GCR_MODE                                   166, 14,  1 // OPT_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define OPT_CHAN_FAIL_MASK                                 166, 15,  8 // OPT_SCOM_MODE_PB :: scom mode reg spares.
#define OPT_SCOM_MODE_PB_SPARES2                           166, 23,  8 // OPT_SCOM_MODE_PB :: scom mode reg spares.
#define OPT_SCOM_PPE_XCR_NONE_0_63                         176,  0, 64 // OPT_SCOM_PPE_XCR_NONE :: ppe register
#define OPT_SCOM_PPE_XCR_SPRG0_0_63                        177,  0, 64 // OPT_SCOM_PPE_XCR_SPRG0 :: ppe register
#define OPT_SCOM_PPE_IR_SPRG0_0_63                         178,  0, 64 // OPT_SCOM_PPE_IR_SPRG0 :: ppe register
#define OPT_SCOM_PPE_XSR_SPRG0_0_63                        179,  0, 64 // OPT_SCOM_PPE_XSR_SPRG0 :: ppe register
#define OPT_SCOM_PPE_IR_EDR_0_63                           180,  0, 64 // OPT_SCOM_PPE_IR_EDR :: ppe register
#define OPT_SCOM_PPE_XSR_IAR_0_63                          181,  0, 64 // OPT_SCOM_PPE_XSR_IAR :: ppe register
#define OPT_SCOM_PPE_MEM_ARB_CSAR_0_63                     182,  0, 64 // OPT_SCOM_PPE_MEM_ARB_CSAR :: ppe register
#define OPT_SCOM_PPE_MEM_ARB_CSDR_0_63                     183,  0, 64 // OPT_SCOM_PPE_MEM_ARB_CSDR :: ppe register
#define OPT_SCOM_PPE_MEM_ARB_SCR_0_63                      184,  0, 64 // OPT_SCOM_PPE_MEM_ARB_SCR :: ppe register
#define OPT_SCOM_PPE_IORESET                               185,  0,  1 // OPT_SCOM_PPE_CNTL :: ppe register
#define OPT_SCOM_PPE_PDWN                                  185,  1,  1 // OPT_SCOM_PPE_CNTL :: ppe register
#define OPT_SCOM_PPE_INTERRUPT                             185,  2,  1 // OPT_SCOM_PPE_CNTL :: ppe register
#define OPT_SCOM_PPE_ARB_ECC_INJECT_ERR                    185,  3,  1 // OPT_SCOM_PPE_CNTL :: ppe register
#define OPT_SCOM_PPE_SPARES                                185,  4, 12 // OPT_SCOM_PPE_CNTL :: ppe register
#define OPT_SCOM_PPE_WORK1                                 186,  0, 32 // OPT_SCOM_PPE_WORK_REG1 :: ppe register
#define OPT_SCOM_PPE_WORK2                                 187,  0, 32 // OPT_SCOM_PPE_WORK_REG2 :: ppe register
#define OPT_SCOM_PPE_FLAGS                                 188,  0, 16 // OPT_SCOM_PPE_FLAGS_REG :: ppe register
#define OPT_SCOM_PPE_FLAGS_SET                             189,  0, 16 // OPT_SCOM_PPE_FLAGS_SET_REG :: ppe register
#define OPT_SCOM_PPE_FLAGS_CLR                             190,  0, 16 // OPT_SCOM_PPE_FLAGS_CLR_REG :: ppe register
#define EDI_TX_MODE_PL_FULL_REG                            191,  0, 16 // EDI_TX_MODE_PL :: iotk alias: for entire tx_mode_pl register
#define EDI_TX_LANE_PDWN                                   191,  0,  1 // EDI_TX_MODE_PL :: used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (tx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers tx_lane_disabled_vec_0_15 and tx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane drive inhibited (tristated) and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_TX_LANE_INVERT                                 191,  1,  1 // EDI_TX_MODE_PL :: used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.\r\n\tmbs
#define EDI_TX_LANE_QUIESCE_P                              191,  2,  2 // EDI_TX_MODE_PL :: used to force the output of the positive differential leg of a lane to a particular value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.\r\n\tmbs
#define EDI_TX_LANE_QUIESCE_N                              191,  4,  2 // EDI_TX_MODE_PL :: used to force the output of the negative differential leg of a lane to a particular value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.\r\n\tmbs
#define EDI_TX_LANE_SCRAMBLE_DISABLE                       191,  6,  1 // EDI_TX_MODE_PL :: used to disable the tx scrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EDI_TX_FIFO_ERR                                    192,  0,  1 // EDI_TX_CNTL_STAT_PL :: indicates an error condition in the tx fifo.\r\n\trgr
#define EDI_TX_PDWN_LITE_GCRMSG                            203,  0,  1 // EDI_TX_CNTL_GCRMSG_PL :: gcr message: when set, gates tx data path (post fifo) to 0s on unused spare lanes when not being recalibrated.\r\n\tsmr
#define EDI_TX_PL_SPARE_MODE_0                             193,  0,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_1                             193,  1,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_2                             193,  2,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_3                             193,  3,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_4                             193,  4,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_5                             193,  5,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_6                             193,  6,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_7                             193,  7,  1 // EDI_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_LANE_BIST_ERR                               194,  0,  1 // EDI_TX_BIST_STAT_PL :: indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.\r\n\tjgr
#define EDI_TX_LANE_BIST_DONE                              194,  1,  1 // EDI_TX_BIST_STAT_PL :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running.\r\n\tjgr
#define EDI_TX_PL_FIR_ERRS_FULL_REG                        198,  0, 16 // EDI_TX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EDI_TX_PL_FIR_ERRS                                 198,  0,  1 // EDI_TX_FIR_PL :: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_PL_REGS                          198,  0,  1 // EDI_TX_FIR_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EDI_TX_PL_FIR_ERRS_MASK_FULL_REG                   199,  0, 16 // EDI_TX_FIR_MASK_PL :: iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\tpmt
#define EDI_TX_PL_FIR_ERRS_MASK                            199,  0,  1 // EDI_TX_FIR_MASK_PL :: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_MASK_PL_REGS                     199,  0,  1 // EDI_TX_FIR_MASK_PL :: iotk alias: fir mask for the per-lane tx register checker.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_INJ_FULL_REG                     200,  0, 16 // EDI_TX_FIR_ERROR_INJECT_PL :: iotk alias: for tx_fir_error_inject_pl register.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_INJ                              200,  0,  1 // EDI_TX_FIR_ERROR_INJECT_PL :: tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - tx_pl_fir_err_inj_from_regs.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_INJ_PL_REGS                      200,  0,  1 // EDI_TX_FIR_ERROR_INJECT_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EDI_TX_PRBS_TAP_ID                                 195,  0,  3 // EDI_TX_PRBS_MODE_PL :: tx per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with rx_prbs_tap_id.  see data scrambling workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EDI_TX_DRV_DATA_PATTERN_GCRMSG                     196,  0,  4 // EDI_TX_DATA_CNTL_GCRMSG_PL :: gcr message: tx per data lane drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id) (\r\n\t0110:(drv_red_prbs) prbs reduced density scramble pattern (see tx_prbs_tap_id and tx_reduced_scramble_mode)\r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_ei3_iap) ei-3 busy iap pattern (ei4 only)\r\n\t1001:(unused_e) unused\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(k28_5) drives 20-bit k28.5 pattern - padded to 32 bits\r\n\t1100:(unused_a) unused\r\n\t1101:(unused_b) unused\r\n\t1110:(unused_c) unused\r\n\t1111:(unused_d) unused\r\n\trjr
#define EDI_TX_SLS_LANE_SEL_GCRMSG                         196,  5,  1 // EDI_TX_DATA_CNTL_GCRMSG_PL :: gcr message: sls commands & recalibration\r\n\t0:(sls_gated) sls commands & recalibration data gated\r\n\t1:(snd_sls) send sls command or recalibration data\r\n\tsmr
#define EDI_TX_DRV_SYNC_PATT_GCRMSG                        197,  1,  1 // EDI_TX_SYNC_PATTERN_GCRMSG_PL :: sync pattern command\r\n\t used to reset the tx prbs register and send a 1111 1111 1111 sync pattern followed by changing tx_drv_data_pattern_gcrmsg to send full prbs (code 0101).  the rx prbs register is then reset after seeing the twelve ones if the rx_prbs_check_sync bit is set.  normally this is set by the training machine after sending the deskew pattern.  note that most prbs patterns have twelve ones so this operation could not be done after prbs is already started.  \r\n\t0:(sync_gated) sync pattern gated\r\n\t1:(snd_sync) send sync pattern
#define EDI_TX_ERR_INJECT                                  201,  0,  4 // EDI_TX_MODE_FAST_PL :: software-only controlled register to inject one or more errors for one deserialized clock pulse on one or more specified beats on this lane.  set bit position x to inject on beat x of a cycle.  bits 0:3 are used in edi and 0:1 are used in ei4. \r\n\tmbs
#define EDI_TX_ERR_INJ_A_ENABLE                            201,  4,  1 // EDI_TX_MODE_FAST_PL :: control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane. \r\n\tmbs
#define EDI_TX_ERR_INJ_B_ENABLE                            201,  5,  1 // EDI_TX_MODE_FAST_PL :: control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane. \r\n\tmbs
#define EDI_TX_TDR_CAPT_VAL                                202,  0,  1 // EDI_TX_TDR_STAT_PL :: value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.\r\n\tdmb
#define EDI_TX_CLK_PDWN                                    204,  0,  1 // EDI_TX_CLK_MODE_PG :: used to disable the tx clock and put it into a low power state.\r\n\t0:(clk_enable) clk enabled (default)\r\n\t1:(clk_disable) clk disabled.\r\n\tmbs
#define EDI_TX_CLK_INVERT                                  204,  1,  1 // EDI_TX_CLK_MODE_PG :: used to invert the polarity of the clock.\r\n\t0:(normal_clk) normal clk polarity (default)\r\n\t1:(invert_clk) invert clk.\r\n\tmbs
#define EDI_TX_CLK_QUIESCE_P                               204,  2,  2 // EDI_TX_CLK_MODE_PG :: used to force the output of the positive differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EDI_TX_CLK_QUIESCE_N                               204,  4,  2 // EDI_TX_CLK_MODE_PG :: used to force the output of the negative differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EDI_TX_CLK_DDR_MODE                                204,  6,  1 // EDI_TX_CLK_MODE_PG :: used to select tx clock qdr mode or ddr mode. \r\n\t0:(qdr) qdr mode (default)\r\n\t1:(ddr) ddr mode.\r\n\tmbs
#define EDI_TX_PG_SPARE_MODE_0                             205,  0,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_1                             205,  1,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_2                             205,  2,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_3                             205,  3,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_4                             205,  4,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_5                             205,  5,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_6                             205,  6,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_7                             205,  7,  1 // EDI_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_TX_CLK_BIST_ERR                                209,  1,  1 // EDI_TX_BIST_STAT_PG :: indicates a txbist clock side error occurred.\r\n\t0:(no_error) no error\r\n\t1:(error) a clock side error has has been found\r\n\tjgr
#define EDI_TX_CLK_BIST_DONE                               209,  3,  1 // EDI_TX_BIST_STAT_PG :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EDI_TX_FIFO_INIT                                   206,  1,  1 // EDI_TX_CNTL_STAT_PG :: used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.\r\n\tthis bit is write-only and as such writing a 1 to this bit will generate a pulse signal. there is no need to write this bit back to a 0.\r\n\trjr
#define EDI_TX_MAX_BAD_LANES                               207,  0,  5 // EDI_TX_MODE_PG :: static repair, dynamic repair & recal max number of bad lanes per tx bus (note: should match rx side)\r\n\tsmr
#define EDI_TX_MSBSWAP                                     207,  5,  1 // EDI_TX_MODE_PG :: used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode\r\n\tmbs
#define EDI_TX_PDWN_LITE_DISABLE                           207,  6,  1 // EDI_TX_MODE_PG :: disables the power down lite feature of unused spare lanes (generally should match rx_pdwn_lite_disable)\r\n\tsmr
#define EDI_TX_RESET_CFG_ENA                               208,  0,  1 // EDI_TX_RESET_ACT_PG :: enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EDI_TX_CLR_PAR_ERRS                                208, 14,  1 // EDI_TX_RESET_ACT_PG :: clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.\r\n\tpmt
#define EDI_TX_FIR_RESET                                   208, 15,  1 // EDI_TX_RESET_ACT_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.\r\n\tpmt
#define EDI_TX_PG_FIR_ERRS_FULL_REG                        210,  0, 16 // EDI_TX_FIR_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.\r\n\tpmt
#define EDI_TX_PG_FIR_ERRS                                 210,  0,  8 // EDI_TX_FIR_PG :: a per-group txctl register or state machine parity error has occurred.\r\n\tbit0 - par_err_txctl_regs\r\n\tbit1: par_err_gcr_buff\r\n\tbit2 - reserved.\r\n\tbit3: par_err_tx_stt_rpr_snd_msg_state.\r\n\tbit4 - par_err_gcrs_ld_state\r\n\tbit5 - par_err_gcrs_unld_state\r\n\tbit6 - reserved.\r\n\tbit7 - reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_PG_REGS                          210,  0,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_GCR_BUFF                         210,  1,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              210,  3,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_GCRS_LD_SM                       210,  4,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_GCRS_UNLD_SM                     210,  5,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_PP_REGS                          210,  6,  1 // EDI_TX_FIR_PG :: iotk alias: parity error has occurred in the per-pack register space.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR                                  210, 15,  1 // EDI_TX_FIR_PG :: summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_FULL_REG                    211,  0, 16 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tpmt
#define EDI_TX_PG_FIR_ERRS_MASK                            211,  0,  8 // EDI_TX_FIR_MASK_PG :: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_PG_REGS                     211,  0,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_GCR_BUFF                    211,  1,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr buffer.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         211,  3,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                  211,  4,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                211,  5,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_PP_REGS                     211,  6,  1 // EDI_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group per-pack register space.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_MASK                             211, 15,  1 // EDI_TX_FIR_MASK_PG :: fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_FULL_REG                     212,  0, 16 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ                              212,  0,  8 // EDI_TX_FIR_ERROR_INJECT_PG :: tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_PG_REGS                      212,  0,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_GCR_BUFF                     212,  1,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          212,  3,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                   212,  4,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 212,  5,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_PP_REGS                      212,  6,  1 // EDI_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group per-pack register space.\r\n\tpmt
#define EDI_TX_BUS_ID                                      213,  0,  6 // EDI_TX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EDI_TX_GROUP_ID                                    213,  7,  6 // EDI_TX_ID1_PG :: this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EDI_TX_LAST_GROUP_ID                               214,  0,  6 // EDI_TX_ID2_PG :: this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EDI_TX_START_LANE_ID                               215,  1,  7 // EDI_TX_ID3_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_TX_END_LANE_ID                                 215,  9,  7 // EDI_TX_ID3_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_TX_DRV_CLK_PATTERN_GCRMSG                      216,  0,  2 // EDI_TX_CLK_CNTL_GCRMSG_PG :: tx clock drive patterns\r\n\t00:(drv_0s) drive all 0s pattern\r\n\t01:(drv_wt) drive wiretest pattern\r\n\t10:(drv_c4) drive clock pattern\r\n\t11:(unused) unused\r\n\tdmb
#define EDI_TX_WT_EN_ALL_CLK_SEGS_GCRMSG                   224,  0,  1 // EDI_TX_WT_SEG_ENABLE_PG :: tx clock wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EDI_TX_WT_EN_ALL_DATA_SEGS_GCRMSG                  224,  1,  1 // EDI_TX_WT_SEG_ENABLE_PG :: tx data  wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EDI_TX_FFE_TEST_MODE                               217,  2,  2 // EDI_TX_FFE_MODE_PG :: driver segment test mode\r\n\t00:(normal) mission mode enable\r\n\t01:(seg_test) driver output test mode\r\n\t10:(unused1) reserved\r\n\t11:(unused2) reserved\r\n\tjfg
#define EDI_TX_FFE_TEST_OVERRIDE1R                         217,  6,  1 // EDI_TX_FFE_MODE_PG :: driver segment test 1r override\r\n\t0:(normal) test 1r segments individually\r\n\t1:(override_1r) test 1r segments in pairs\r\n\tjfg
#define EDI_TX_FFE_TEST_OVERRIDE2R                         217,  7,  1 // EDI_TX_FFE_MODE_PG :: driver segment test 2r override\r\n\t0:(normal) test 2r segments individually\r\n\t1:(override_2r) test 2r segments with all 1r enabled\r\n\tjfg
#define EDI_TX_FFE_MAIN_P_ENC                              218,  1,  7 // EDI_TX_FFE_MAIN_PG :: tbd\r\n\tjfg
#define EDI_TX_FFE_MAIN_N_ENC                              218,  9,  7 // EDI_TX_FFE_MAIN_PG :: tbd\r\n\tjfg
#define EDI_TX_FFE_POST_P_ENC                              219,  3,  5 // EDI_TX_FFE_POST_PG :: tbd this field is updated during tx bist by logic temporarily\r\n\tjfg
#define EDI_TX_FFE_POST_N_ENC                              219, 11,  5 // EDI_TX_FFE_POST_PG :: tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_P_ENC                            220,  3,  5 // EDI_TX_FFE_MARGIN_PG :: tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_N_ENC                            220, 11,  5 // EDI_TX_FFE_MARGIN_PG :: tbd\r\n\tjfg
#define EDI_TX_BAD_LANE1_GCRMSG                            221,  0,  7 // EDI_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane one in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_BAD_LANE2_GCRMSG                            221,  7,  7 // EDI_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane two in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_BAD_LANE_CODE_GCRMSG                        221, 14,  2 // EDI_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: tx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_TX_SLS_LANE_GCRMSG                             223,  0,  7 // EDI_TX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: encoded sls lane in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_SLS_LANE_VAL_GCRMSG                         223,  7,  1 // EDI_TX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: tx sls lane valid\r\n\tsmr
#define EDI_TX_LANE_DISABLED_VEC_0_15                      225,  0, 16 // EDI_TX_LANE_DISABLED_VEC_0_15_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EDI_TX_LANE_DISABLED_VEC_16_31                     226,  0, 16 // EDI_TX_LANE_DISABLED_VEC_16_31_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EDI_TX_SLS_LANE_SHDW_GCRMSG                        227,  0,  1 // EDI_TX_SLS_LANE_MUX_GCRMSG_PG :: gcr message: sls lane shadowing or unshadowing functional data (used to set up tx mux controls)\r\n\tsmr
#define EDI_TX_SLS_HNDSHK_STATE                            228,  0,  5 // EDI_TX_DYN_RPR_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for tx_sls_hndshk_state\r\n\t smr
#define EDI_TX_SLV_MV_SLS_SHDW_REQ_GCRMSG                  229,  0,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_SHDW_RPR_REQ_GCRMSG              229,  1,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_UNSHDW_REQ_GCRMSG                229,  2,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_UNSHDW_RPR_REQ_GCRMSG            229,  3,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_BUS_WIDTH                                   229,  4,  7 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: tx bus width\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_RPR_REQ_GCRMSG                   229, 11,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_SLS_LANE_SEL_LG_GCRMSG                      229, 12,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: sets the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EDI_TX_SLS_LANE_UNSEL_LG_GCRMSG                    229, 13,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: clears the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EDI_TX_SPR_LNS_PDWN_LITE_GCRMSG                    229, 14,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: signals the tx side to power down lite (data gate) unused spare lanes at the end of static repair\r\n\tsmr
#define EDI_TX_SLV_LGL_RPR_REQ_GCRMSG                      229, 15,  1 // EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to set bad lane register to last good lane of the bus (during recal bad lane scenarios)\r\n\tsmr
#define EDI_TX_WT_PATTERN_LENGTH                           230,  0,  2 // EDI_TX_WIRETEST_PP :: tx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EDI_TX_REDUCED_SCRAMBLE_MODE                       231,  0,  2 // EDI_TX_MODE_PP :: enables/disables and sets reduced density of scramble pattern. this must be set consistent with rx_reduced_scramble_mode.  \r\n\t00:(disable_0) full density \r\n\t01:(disable_1) full density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div4) enable div4 reduced density (div4 is edi only).\r\n\trjr
#define EDI_TX_PRBS_SCRAMBLE_MODE                          231,  2,  2 // EDI_TX_MODE_PP :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by tx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDI_TX_FIFO_L2U_DLY                                231,  4,  3 // EDI_TX_MODE_PP :: this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define EDI_TX_BIST_EN                                     236,  0,  1 // EDI_TX_BIST_CNTL_PP :: this bit enables the tx bist state machine to begin testing.\r\n\tjgr
#define EDI_TX_SND_SLS_CMD_GCRMSG                          232,  0,  1 // EDI_TX_SLS_GCRMSG_PP :: gcr message: send sls command or recalibration data\r\n\tsmr
#define EDI_TX_DYN_RECAL_TSR_IGNORE_GCRMSG                 232,  1,  1 // EDI_TX_SLS_GCRMSG_PP :: gcr message: send dynamic recal sls commands all the time (not just during the status reporting interval)\r\n\tsmr
#define EDI_TX_SLS_CMD_GCRMSG                              232,  2,  6 // EDI_TX_SLS_GCRMSG_PP :: gcr message: tx sls command\r\n\tsmr
#define EDI_TX_SND_SLS_CMD_PREV_GCRMSG                     232,  8,  1 // EDI_TX_SLS_GCRMSG_PP :: gcr message: revert to sending previous sls command or recalibration data after recovery repair made\r\n\tsmr
#define EDI_TX_SND_SLS_USING_REG_SCRAMBLE                  232,  9,  1 // EDI_TX_SLS_GCRMSG_PP :: gcr message: send sls command using normal scramble pattern instead of calibration or 9th pattern\r\n\trjr
#define EDI_TX_ERR_INJ_A_RAND_BEAT_DIS                     233,  0,  1 // EDI_TX_BER_CNTL_A_PP :: used to disable randomization of error inject on different beats of data for pattern a.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EDI_TX_ERR_INJ_A_FINE_SEL                          233,  1,  3 // EDI_TX_BER_CNTL_A_PP :: random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EDI_TX_ERR_INJ_A_COARSE_SEL                        233,  4,  4 // EDI_TX_BER_CNTL_A_PP :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EDI_TX_ERR_INJ_A_BER_SEL                           233, 10,  6 // EDI_TX_BER_CNTL_A_PP :: used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EDI_TX_ERR_INJ_B_RAND_BEAT_DIS                     234,  0,  1 // EDI_TX_BER_CNTL_B_PP :: used to disable randomization of error inject on different beats of data for pattern b.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EDI_TX_ERR_INJ_B_FINE_SEL                          234,  1,  3 // EDI_TX_BER_CNTL_B_PP :: random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EDI_TX_ERR_INJ_B_COARSE_SEL                        234,  4,  4 // EDI_TX_BER_CNTL_B_PP :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EDI_TX_ERR_INJ_B_BER_SEL                           234, 10,  6 // EDI_TX_BER_CNTL_B_PP :: used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_MODE                            237,  0,  1 // EDI_TX_BER_CNTL_SLS_PP :: used to set the random bit error injection for pattern a to work during sls transmission only. \r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_ALL_CMD                         237,  1,  1 // EDI_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on all sls command transmissions. \r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_RECAL                           237,  2,  1 // EDI_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on the calibration lane only when not sending an sls command. see workbook for details.\r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_CMD                             237, 10,  6 // EDI_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on only this sls command transmission. see workbook for sls command codes.\r\n\tmbs
#define EDI_TX_DYN_RECAL_INTERVAL_TIMEOUT_SEL              235,  1,  3 // EDI_TX_DYN_RECAL_TIMEOUTS_PP :: tx dynamic recalibration interval timeout selects\r\n\t000:(tap0) 1024ui or 106.5ns very small value for sim only\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_TX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL            235,  4,  2 // EDI_TX_DYN_RECAL_TIMEOUTS_PP :: tx dynamic recalibration status reporting timeout selects\r\n\t00:(tap0) 512ui or 53.2ns very small value for sim only\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\t(note that the first 1/4 and last 1/4 of this time are actually sending the prbs pattern, so the actual time the sls command is on the lane is 1/2 of this value.  for more info see figure 2.4 eye-opening initialization step/recalibration timing description in the workbook.)\r\n\tsmr
#define EDI_TX_ENABLE_REDUCED_SCRAMBLE                     238,  0,  1 // EDI_TX_CNTL_PP :: enables reduced density of scramble pattern. normally this is set automatically in the functional mode training state.  users should use tx_reduced_scramble_mode to throttle density.  \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the tx_reduced_scramble_mode setting.\r\n\trjr
#define EDI_TX_RESET_CFG_HLD                               239,  0, 16 // EDI_TX_RESET_CFG_PP :: reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via tx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EDI_TX_TDR_DAC_CNTL                                240,  0,  8 // EDI_TX_TDR_CNTL1_PP :: controls variable threshold receiver for tdr function\r\n\tdmb
#define EDI_TX_TDR_PHASE_SEL                               240,  9,  1 // EDI_TX_TDR_CNTL1_PP :: controls phase select for tdr function, 0 is for _n leg, 1 is for _p leg.\r\n\tdmb
#define EDI_TX_TDR_PULSE_OFFSET                            241,  0, 12 // EDI_TX_TDR_CNTL2_PP :: offset value for tdr pulse.\r\n\tdmb
#define EDI_TX_TDR_PULSE_WIDTH                             242,  0, 12 // EDI_TX_TDR_CNTL3_PP :: width of tdr pulse.\r\n\tdmb
#define EDI_TX_ZCAL_REQ                                    243,  1,  1 // EDI_TX_IMPCAL_PB :: impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_DONE                                   243,  2,  1 // EDI_TX_IMPCAL_PB :: impedance calibration sequence complete\r\n\t results are valid when 1.\r\n\tjfg
#define EDI_TX_ZCAL_ERROR                                  243,  3,  1 // EDI_TX_IMPCAL_PB :: impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.\r\n\tjfg
#define EDI_TX_ZCAL_BUSY                                   243,  4,  1 // EDI_TX_IMPCAL_PB :: impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.\r\n\tjfg
#define EDI_TX_ZCAL_FORCE_SAMPLE                           243,  5,  1 // EDI_TX_IMPCAL_PB :: impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable\r\n\tjfg
#define EDI_TX_ZCAL_CMP_OUT                                243,  6,  1 // EDI_TX_IMPCAL_PB :: calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.\r\n\tjfg
#define EDI_TX_ZCAL_SAMPLE_CNT                             243,  7,  9 // EDI_TX_IMPCAL_PB :: calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.\r\n\tjfg
#define EDI_TX_ZCAL_N                                      244,  0,  9 // EDI_TX_IMPCAL_NVAL_PB :: calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_ZCAL_P                                      245,  0,  9 // EDI_TX_IMPCAL_PVAL_PB :: calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_ZCAL_P_4X                                   246,  0,  5 // EDI_TX_IMPCAL_P_4X_PB :: calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).\r\n\tjfg
#define EDI_TX_ZCAL_SWO_EN                                 247,  0,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CAL_SEGS                           247,  1,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_INV                            247,  2,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_OFFSET                         247,  3,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_RESET                          247,  4,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_POWERDOWN                          247,  5,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.\r\n\tjfg
#define EDI_TX_ZCAL_CYA_DATA_INV                           247,  6,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.\r\n\tjfg
#define EDI_TX_ZCAL_TEST_OVR_2R                            247,  7,  1 // EDI_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 2r segment override\r\n\t override 2r segment enable. see documentation.(default)\r\n\t0:(false) no override\r\n\t1:(true) override.\r\n\tjfg
#define EDI_TX_ZCAL_DEBUG_MODE                             247, 14,  2 // EDI_TX_IMPCAL_SWO1_PB :: calibration circuit debug mode select\r\n\t this enables outputs for use with the minikerf but does not enable the minikerf. please reference tx_minikerf.\r\n\t(default)\r\n\t00:(disabled00) debug mode disabled\r\n\t01:(filters) probea=rcin_p, probeb=rcin_n observe filter input nodes, rcin_n is off-chip.\r\n\t10:(comparators) probea=comp_in_p, probeb=comp_in_n  observe comparator inputs.\r\n\t11:(disabled11) debug mode disabled\r\n\tjfg
#define EDI_TX_ZCAL_SM_MIN_VAL                             248,  0,  7 // EDI_TX_IMPCAL_SWO2_PB :: impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).\r\n\tjfg
#define EDI_TX_ZCAL_SM_MAX_VAL                             248,  7,  7 // EDI_TX_IMPCAL_SWO2_PB :: impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).\r\n\tjfg
#define EDI_TX_IREF_BC                                     249,  0,  3 // EDI_TX_ANALOG_IREF_PB :: bias code for the iref macros on the tx side. all eight 3 bit codes enable current out. the cml voltage swings of the output current will vary with this code.\r\n\tsmc
#define EDI_TX_MINIKERF                                    250,  0, 16 // EDI_TX_MINIKERF_PB :: tx minikerf cntl reg: \r\n\t bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) except on centaur which uses rx_minikerf_pg \r\n\t (0:2)=011 - reserved \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - tx tank pll clk on c4 pads except in centaur case, which has dedicated c4 pads from the clk_4t1sst_drvr. \r\n\t (0:2)=110 - reserved. \r\n\t (0:2)=111 - reserved\r\n\tsmc
#define EDI_TX_INIT_VERSION                                251,  0, 16 // EDI_TX_INIT_VERSION_PB :: initfile version\r\n\tthis field is used to hold the initfile version for debug purposes.\r\n\tpmt
#define EDI_TX_SCRATCH_REG                                 252,  0, 16 // EDI_TX_SCRATCH_REG_PB :: scratch register\r\n\tthis field is used to enable fw procedures to communicate.\r\n\tpmt
#define EDI_RX_MODE_PL_FULL_REG                            253,  0, 16 // EDI_RX_MODE_PL :: alias for entire rx_mode_pl register\r\n\tpmt
#define EDI_RX_LANE_PDWN                                   253,  0,  1 // EDI_RX_MODE_PL :: used to receive inhibit and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (rx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers rx_lane_disabled_vec_0_15 and rx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane receive inhibited and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_RX_LANE_SCRAMBLE_DISABLE                       253,  6,  1 // EDI_RX_MODE_PL :: used to disable the rx descrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EDI_RX_BLOCK_LOCK_LANE                             254,  0,  1 // EDI_RX_CNTL_PL :: enables rotation and checking for block lock. \r\n\t0:(disabled) disable checking (forces block_locked_b to 1)\r\n\t1:(enabled) enable checking and run block lock.\r\n\trjr
#define EDI_RX_CHECK_SKEW_LANE                             254,  1,  1 // EDI_RX_CNTL_PL :: per-lane initialization controls. checks skew request\r\n\trjr
#define EDI_RX_PDWN_LITE                                   254,  2,  1 // EDI_RX_CNTL_PL :: gcr message: when set, partially powers down unused spare lanes when not being recalibrated\r\n\tsmr
#define EDI_RX_OFFCAL_MODE                                 254,  3,  1 // EDI_RX_CNTL_PL :: when set, put this lanes front end into offset cancellation mode. only needed as an override since running offset cancellation does this automatically.\r\n\tjfg
#define EDI_RX_PL_SPARE_MODE_0                             255,  0,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_1                             255,  1,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_2                             255,  2,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_3                             255,  3,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_4                             255,  4,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_5                             255,  5,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_6                             255,  6,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_7                             255,  7,  1 // EDI_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_BIST_ERR                                    257,  0,  1 // EDI_RX_BIST_STAT_PL :: indicates that rxbist did not find two data eyes of sufficient width.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist\r\n\tjgr
#define EDI_RX_BIST_DONE                                   257,  1,  1 // EDI_RX_BIST_STAT_PL :: indicates a rxbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EDI_RX_OFFSET_EVEN_SAMP1                           258,  1,  7 // EDI_RX_OFFSET_EVEN_PL :: this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_EVEN_SAMP0                           258,  9,  7 // EDI_RX_OFFSET_EVEN_PL :: this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_ODD_SAMP1                            259,  1,  7 // EDI_RX_OFFSET_ODD_PL :: this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_ODD_SAMP0                            259,  9,  7 // EDI_RX_OFFSET_ODD_PL :: this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_AMP_PEAK                                    260,  0,  4 // EDI_RX_AMP_VAL_PL :: this is the vertical offset of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_GAIN                                    260,  4,  4 // EDI_RX_AMP_VAL_PL :: this is the gain setting of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_OFFSET                                  260, 10,  6 // EDI_RX_AMP_VAL_PL :: this is the peaking setting of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_ADJ_DONE                                261,  0,  1 // EDI_RX_AMP_CNTL_PL :: vga adjust is complete for this lane\r\n\trjr
#define EDI_RX_AMP_ADJ_ALL_DONE_B                          261,  1,  1 // EDI_RX_AMP_CNTL_PL :: vga adjust is complete for all valid lanves-asserted (low) if the lane *_done is asserted or the lane is disabled or the lane is bad--intended for global reading using the dot-or nature of the bus to see that all valid lanes are done when low \r\n\trjr
#define EDI_RX_FIFO_L2U_DLY                                265,  0,  4 // EDI_RX_FIFO_STAT_PL :: rx fifo load-to-unload delay, initailed during fifo init and modified thereafter by the deskew machine.  for setting x, the latency is 4*x to 4*x+4 ui.  default is 20-24 ui\r\n\trjr
#define EDI_RX_FIFO_INIT                                   265,  4,  1 // EDI_RX_FIFO_STAT_PL :: initializes the fifo unload counter with the load counter and initializes the fifo load to unload delay\r\n\trjr
#define EDI_RX_FIFO_INC_L2U_DLY                            279,  0,  1 // EDI_RX_FIFO_CNTL_PL :: increment existing fifo load-to-unload delay register\r\n\trjr
#define EDI_RX_FIFO_DEC_L2U_DLY                            279,  1,  1 // EDI_RX_FIFO_CNTL_PL :: decrement existing fifo load-to-unload delay register\r\n\trjr
#define EDI_RX_CLR_SKEW_VALID                              279,  2,  1 // EDI_RX_FIFO_CNTL_PL :: clear skew valid registers\r\n\trjr
#define EDI_RX_BAD_BLOCK_LOCK                              273,  0,  1 // EDI_RX_DESKEW_STAT_PL :: deskew step block lock not established--lane marked bad\r\n\trjr
#define EDI_RX_BAD_SKEW                                    273,  1,  1 // EDI_RX_DESKEW_STAT_PL :: deskew step skew value not detected--lane marked bad\r\n\trjr
#define EDI_RX_BAD_DESKEW                                  273,  2,  1 // EDI_RX_DESKEW_STAT_PL :: deskew step deskew value\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_BER                             293,  0,  1 // EDI_RX_EYE_OPT_STAT_PL :: eye opt step failed ber test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_WIDTH                           293,  1,  1 // EDI_RX_EYE_OPT_STAT_PL :: eye opt step failed width test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_HEIGHT                          293,  2,  1 // EDI_RX_EYE_OPT_STAT_PL :: eye opt step failed height test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_DDC                             293,  3,  1 // EDI_RX_EYE_OPT_STAT_PL :: eye opt step failed dynamic data centering--lane marked bad\r\n\trjr
#define EDI_RX_AP_EVEN_SAMP                                266,  0,  8 // EDI_RX_AP_PL :: average value of a 1 in the even sampler\r\n\trjr
#define EDI_RX_AP_ODD_SAMP                                 266,  8,  8 // EDI_RX_AP_PL :: average value of a 1 in the  odd sampler\r\n\trjr
#define EDI_RX_AN_EVEN_SAMP                                267,  0,  8 // EDI_RX_AN_PL :: average value of a 0 in the even sampler\r\n\trjr
#define EDI_RX_AN_ODD_SAMP                                 267,  8,  8 // EDI_RX_AN_PL :: average value of a 0 in the  odd sampler\r\n\trjr
#define EDI_RX_DFE_CLKADJ                                  290,  0,  4 // EDI_RX_DFE_CLKADJ_PL :: tweak value for the clock offset when doing dfe calibration\r\n\tthis is a per lane register which contains the distance in pr steps that the correct spot to position the clock is to the left of the center as defined by edge tracking.\r\n\tprior to running dfe we must have our clock positioned in the correct spot. with dfe applied the center of the data eye is shifted left. the greater the ratio of ap and h1, the further to the left this becomes. when running ctle we do not apply the h1 coefficients so we are tracking the edge of the non adjusted eye. so if we take the edge of the eye, the center of the fuzz, and move over 1/2ui or 16 phase rotator steps we will not be in the center of the dfe adjusted eye. this is compensated for by the h1/ap adjust. this is exactly as implied except there is a constant thrown in. the actual equation is h1/ap * k where k is selectable to be 10, 12, 14, or 16. and stored in a 2 bit register rx_dfe_ca_cfg where we encode the value of k.\r\n\tthe value of the clock adjust may be written manually and will remain that value as long as the servo op h1ap_adjust is not executed. every time the init_sm says h1ap_adjust we do the math to see if the register value matches the calculated value. if not we inc/dec some filtering logic which will actually change the clkadj register when it over/under flows. you can set this register but if the init_sm says to update the clk_adj it just might inc/dec one step.\r\n\tcpg
#define EDI_RX_AMIN_EVEN                                   268,  0,  8 // EDI_RX_AMIN_PL :: lowest value of a 1 in the even sampler\r\n\trjr
#define EDI_RX_AMIN_ODD                                    268,  8,  8 // EDI_RX_AMIN_PL :: lowest value of a 1 in the  odd sampler\r\n\trjr
#define EDI_RX_H1_EVEN_SAMP1                               269,  1,  7 // EDI_RX_H1_EVEN_PL :: dfe h1 value for even sampler 1\r\n\trjr
#define EDI_RX_H1_EVEN_SAMP0                               269,  9,  7 // EDI_RX_H1_EVEN_PL :: dfe h1 value for even sampler 0\r\n\trjr
#define EDI_RX_H1_ODD_SAMP1                                270,  1,  7 // EDI_RX_H1_ODD_PL :: dfe h1 value for odd  sampler 1\r\n\trjr
#define EDI_RX_H1_ODD_SAMP0                                270,  9,  7 // EDI_RX_H1_ODD_PL :: dfe h1 value for odd  sampler 0\r\n\trjr
#define EDI_RX_PL_FIR_ERRS_FULL_REG                        274,  0, 16 // EDI_RX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EDI_RX_PL_FIR_ERRS                                 274,  0,  2 // EDI_RX_FIR_PL :: a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_PL_REGS                          274,  0,  1 // EDI_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_DDC_SM                           274,  1,  1 // EDI_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx ddc state machine.\r\n\tpmt
#define EDI_RX_PL_FIR_ERRS_MASK_FULL_REG                   275,  0, 16 // EDI_RX_FIR_MASK_PL :: iotk alias: fir mask for rx_fir_pl errors.\r\n\tpmt
#define EDI_RX_PL_FIR_ERRS_MASK                            275,  0,  2 // EDI_RX_FIR_MASK_PL :: fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK_PL_REGS                     275,  0,  1 // EDI_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane register parity errors.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK_DDC_SM                      275,  1,  1 // EDI_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane rx ddc state machine parity error.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ_FULL_REG                     276,  0, 16 // EDI_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ                              276,  0,  2 // EDI_RX_FIR_ERROR_INJECT_PL :: rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ_PL_REGS                      276,  0,  1 // EDI_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ_DDC_SM                       276,  1,  1 // EDI_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.\r\n\tpmt
#define EDI_RX_PRBS_TAP_ID                                 271,  0,  3 // EDI_RX_PRBS_MODE_PL :: per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with tx_prbs_tap_id.  see data descramble workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EDI_RX_SOME_BLOCK_LOCKED                           272,  0,  1 // EDI_RX_STAT_PL :: per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane not block locked.\r\n\t1:(high) lane block locked\r\n\trjr
#define EDI_RX_ALL_BLOCK_LOCKED_B                          272,  1,  1 // EDI_RX_STAT_PL :: per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane block locked\r\n\t1:(high) lane not block locked.\r\n\trjr
#define EDI_RX_SOME_SKEW_VALID                             272,  2,  1 // EDI_RX_STAT_PL :: per-lane deskew pattern b detect indicator\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern not detected.\r\n\t1:(high) pattern detected\r\n\trjr
#define EDI_RX_ALL_SKEW_VALID_B                            272,  3,  1 // EDI_RX_STAT_PL :: per-lane deskew pattern b detect indicator (active low)\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern detected\r\n\t1:(high) pattern not detected.\r\n\trjr
#define EDI_RX_SOME_PRBS_SYNCED                            272,  4,  1 // EDI_RX_STAT_PL :: per-lane prbs synchronization indicator\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized on any lane in a pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EDI_RX_PRBS_SYNCED_B                               272,  5,  1 // EDI_RX_STAT_PL :: per-lane prbs synchronization indicator (active low)\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized or there are no valid or good lanes in the pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EDI_RX_SKEW_VALUE                                  272,  6,  6 // EDI_RX_STAT_PL :: per-lane prbs synchronization count\r\n\tvalue of the free-running counter when the marker pattern of deskew pattern b is detected\r\n\trjr
#define EDI_RX_SLS_LANE_SEL                                277,  0,  1 // EDI_RX_SLS_PL :: selects which lane to receive sls commands and recalibration data on\r\n\tsmr
#define EDI_RX_9TH_PATTERN_EN                              277,  1,  1 // EDI_RX_SLS_PL :: sets rx descrabmler to use calibration or 9th scramble pattern\r\n\tsmr
#define EDI_RX_WT_LANE_DISABLED                            278,  0,  1 // EDI_RX_WT_STATUS_PL :: wiretest has disabled this lane\r\n\trjr
#define EDI_RX_WT_LANE_INVERTED                            278,  1,  1 // EDI_RX_WT_STATUS_PL :: wiretest lane inverted ( or _n and _p swapped)\r\n\t0--not inverted if rx_wt_lane_bad_code = 000 \r\n\t1--inverted if rx_wt_lane_bad_code = 000\r\n\t see rx_wt_lane_bad_code descriptions  for meaning if rx_wt_lane_bad_code not = 000\r\n\trjr
#define EDI_RX_WT_LANE_BAD_CODE                            278,  2,  3 // EDI_RX_WT_STATUS_PL :: wiretest lane bad code concatenate rx_wt_lane_inverted with rx_wt_lane_bad_code to get a full status: \r\n\t0000--good lane--not inverted (edi and ei-4)\r\n\t0001--bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010--bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011--bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100--bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101--bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110--bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111--bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000--good lane--inverted (edi and ei-4) \r\n\t1001--bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010--bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011--bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100--bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101--bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110--bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111--bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_WT_LANE_STATUS_ALIAS                        278,  1,  4 // EDI_RX_WT_STATUS_PL :: alias for rx_wt_lane_inverted concatenated with rx_wt_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_EXT_SR                                      264,  4,  1 // EDI_RX_PROT_CNTL_PL :: rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.\r\n\tcpg
#define EDI_RX_EXT_SL                                      264,  5,  1 // EDI_RX_PROT_CNTL_PL :: rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.\r\n\tcpg
#define EDI_RX_PHASEROT_OFFSET                             263,  2,  6 // EDI_RX_PROT_MODE_PL :: rx phase rotator fixed offset from learned value\r\n\tthis is different than what happens in ei4, it does not just add an offset to the rotator. edi has one rotator which is used for everything. we retain the idea of a fixed offset which is derived from learning but it is applied in a much differant way. during most operations we must know exactly where the rotator is at. but after running ddc we may find that that is not the spot that gives us the best bit error rate. \r\n\tduring ddc we search and find both edges of the eye. at the end we are at the right edge of the eye and we do math to find out where the middle is. at this point we march back to the left until we are at the average of the two points. the value of this register is added to that value before we shift left to the middle. this does present some possible problem or limitations. the value of this register must be such that the sum of this register and the average of the left and right edge must be to the left of the right edge. \r\n\tit is possible to put a value in this register that will really get you messed up so great care must be given.\r\n\tcpg
#define EDI_RX_PHASEROT_VAL                                262,  2,  6 // EDI_RX_PROT_STATUS_PL :: rx phase rotator current value\r\n\trjr
#define EDI_RX_PHASEROT_DDC_COMPLETE                       262,  8,  1 // EDI_RX_PROT_STATUS_PL :: rx ddc state machine completion indicator\r\n\trjr
#define EDI_RX_PHASEROT_BLOCK_LOCK_ERR                     262,  9,  1 // EDI_RX_PROT_STATUS_PL :: rx ddc state machine block lock error indicator\r\n\trjr
#define EDI_RX_PHASEROT_LEFT_EDGE                          256,  2,  6 // EDI_RX_PROT_EDGE_STATUS_PL :: rx phase rotator left edge\r\n\trjr
#define EDI_RX_PHASEROT_RIGHT_EDGE                         256,  8,  6 // EDI_RX_PROT_EDGE_STATUS_PL :: rx phase rotator right edge\r\n\trjr
#define EDI_RX_EYE_WIDTH                                   288,  2,  6 // EDI_RX_EYE_WIDTH_STATUS_PL :: rx current eye width (in pr steps).\r\n\tdmb
#define EDI_RX_HIST_MIN_EYE_WIDTH_VALID                    288,  8,  1 // EDI_RX_EYE_WIDTH_STATUS_PL :: rx historic eye minimum is valid for this lane.\r\n\tdmb
#define EDI_RX_HIST_MIN_EYE_WIDTH                          288, 10,  6 // EDI_RX_EYE_WIDTH_STATUS_PL :: rx historic eye minimum--per-pack register valid for this lane if rx_hist_eye_min_valid is asserted for this lane.\r\n\tdmb
#define EDI_RX_RESET_HIST_EYE_WIDTH_MIN                    289,  0,  1 // EDI_RX_EYE_WIDTH_CNTL_PL :: rx historic eye minimum reset--reset historic min to maximum value and clears valid bits.\r\n\tdmb
#define EDI_RX_BER_COUNT                                   280,  0,  8 // EDI_RX_BER_STATUS_PL :: per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.\r\n\tpmt
#define EDI_RX_BER_COUNT_SATURATED                         280,  8,  1 // EDI_RX_BER_STATUS_PL :: pl diag ber error counter saturation indicator. when '1' indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.\r\n\tpmt
#define EDI_RX_BER_COUNT_FROZEN_BY_LANE                    280,  9,  1 // EDI_RX_BER_STATUS_PL :: pl diag ber error counter and or pp timer has been frozen by another lane's error counter being saturated.\r\n\tpmt
#define EDI_RX_BER_COUNT_FROZEN_BY_TIMER                   280, 10,  1 // EDI_RX_BER_STATUS_PL :: pl diag ber error counter has been frozen by a diag ber timer becoming saturated.\r\n\tpmt
#define EDI_RX_BER_TIMER_SATURATED                         280, 11,  1 // EDI_RX_BER_STATUS_PL :: pl diag ber timer saturation indicator. when '1' indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.\r\n\tpmt
#define EDI_RX_BER_TIMER_VALUE_0_15                        281,  0, 16 // EDI_RX_BER_TIMER_0_15_PL :: pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.\r\n\tpmt
#define EDI_RX_BER_TIMER_VALUE_16_31                       282,  0, 16 // EDI_RX_BER_TIMER_16_31_PL :: pl diag ber timer value, bits 16-31.\r\n\tpmt
#define EDI_RX_BER_TIMER_VALUE_32_39                       283,  0,  8 // EDI_RX_BER_TIMER_32_39_PL :: pl diag ber timer value, bits 32-39.\r\n\tpmt
#define EDI_RX_SERVO_OP_DONE                               284,  0,  1 // EDI_RX_SERVO_CNTL_PL :: servo op completed\r\n\trjr
#define EDI_RX_SERVO_OP_ALL_DONE_B                         284,  1,  1 // EDI_RX_SERVO_CNTL_PL :: servo op code on all lanes-asserted (low) if the lane *_done is asserted or the lane is disabled or the lane is bad--intended for global reading using the dot-or nature of the bus to see that all valid lanes are done when low \r\n\trjr
#define EDI_RX_SERVO_OP                                    284,  2,  5 // EDI_RX_SERVO_CNTL_PL :: servo operation code \r\n\t00000: c_nop \r\n\t00001: c_offcal_0 \r\n\t00010: c_offcal_1 \r\n\t00011: c_ctle \r\n\t00100: c_vref \r\n\t00101: c_blocklock \r\n\t00110: c_edgetrack \r\n\t00111: c_ddc \r\n\t01000: c_ap_noh \r\n\t01001: c_an_noh \r\n\t01010: c_amin_noh \r\n\t01011: unused \r\n\t01100: unused \r\n\t01101: unused \r\n\t01110: c_eye_track \r\n\t01111: c_dcd_adj \r\n\t10000: c_dfe_ape \r\n\t10001: c_dfe_ane \r\n\t10010: c_dfe_apo \r\n\t10011: c_dfe_ano \r\n\t10100: c_dfe_amin \r\n\t10101: unused \r\n\t10110: unused \r\n\t10111: unused \r\n\t11000: c_bump_left \r\n\t11001: c_bump_right \r\n\t11010: c_bump1 \r\n\t11011: c_bump2 \r\n\t11100: c_h1ap_adjust \r\n\t11101: c_ber_test \r\n\t11110: unused \r\n\t11111: unused  \r\n\trjr
#define EDI_RX_FIFO_OUT_0_15                               285,  0, 16 // EDI_RX_FIFO_DIAG_0_15_PL :: diag capture: fifo entries 0 to 15\r\n\tdmb
#define EDI_RX_FIFO_OUT_16_31                              286,  0, 16 // EDI_RX_FIFO_DIAG_16_31_PL :: diag capture: fifo entries 16 to 31\r\n\tdmb
#define EDI_RX_FIFO_OUT_32_47                              287,  0, 16 // EDI_RX_FIFO_DIAG_32_47_PL :: diag capture: fifo entries 32 to 47\r\n\tdmb
#define EDI_RX_LN_TRC_EN                                   291,  0,  1 // EDI_RX_TRACE_PL :: enable tracing of this lane.\r\n\tsmr
#define EDI_RX_SERVO_BER_COUNT                             292,  0, 12 // EDI_RX_SERVO_BER_COUNT_PL :: servo-based bit error count.\r\n\trjr
#define EDI_RX_CLK_PDWN                                    294,  0,  1 // EDI_RX_CLK_MODE_PG :: used to disable the rx clock and put it into a low power state.\r\n\t0:(enabled) clk enabled (default)\r\n\t1:(disabled) clk disabled
#define EDI_RX_CLK_INVERT                                  294,  1,  1 // EDI_RX_CLK_MODE_PG :: used to invert the polarity of the clock.\r\n\t0:(normal) normal clk polarity (default)\r\n\t1:(inverted) clk inverted
#define EDI_RX_PG_SPARE_MODE_0                             295,  0,  1 // EDI_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_1                             295,  1,  1 // EDI_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_2                             295,  2,  1 // EDI_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_3                             295,  3,  1 // EDI_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_4                             295,  4,  1 // EDI_RX_SPARE_MODE_PG :: chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.\r\n\tsmr
#define EDI_RX_SLS_EXTEND_SEL                              295,  5,  3 // EDI_RX_SPARE_MODE_PG :: how long to extend sending of the tx sls command (i.e. delay the gcr_wrt_done to the sending sm).\r\n\t(times based on edi slow clk of 833ps)\r\n\t000:(tap1) 0.833ns\r\n\t001:(tap2) 53.3ns\r\n\t010:(tap3) 106.6ns\r\n\t011:(tap4) 213.2ns\r\n\t100:(tap5) 426.5ns\r\n\t101:(tap6) 853.0ns\r\n\t110:(tap7) 1.7us\r\n\t111:(tap8) 3.4us\r\n\tsmr
#define EDI_RX_MASTER_MODE                                 297,  0,  1 // EDI_RX_MODE_PG :: master mode\r\n\tused to set a chip bus as the master side of the interface. the master side of the interface is where training is kicked off and coordinated in the logic.\r\n\t0:(slave) slave\r\n\t1:(master) master\r\n\trjr
#define EDI_RX_DISABLE_FENCE_RESET                         297,  1,  1 // EDI_RX_MODE_PG :: set to disable clearing of the rx and tx fence controls at the end of training. \r\n\t0:(enable) clear the fence bit (default) \r\n\t1:(disable) leave the fence in its current state \r\n\tmbs
#define EDI_RX_PDWN_LITE_DISABLE                           297,  2,  1 // EDI_RX_MODE_PG :: disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)\r\n\tsmr
#define EDI_RX_USE_SLS_AS_SPR                              297,  3,  1 // EDI_RX_MODE_PG :: determines whether the rx sls lane can be used as a spare lane on the bus to repair bad lanes (note: if yes, recal is disabled once the sls lane has been used as a spare lane.)\r\n\t(note: applies to tx side as well)\r\n\tsmr
#define EDI_RX_BUMP_BEFORE_PRBS_SYNC                       297,  4,  1 // EDI_RX_MODE_PG :: chicken switch: determines whether a 1/2 bit bump occurs before or after prbs sync on edi buses:\r\n\t0:(after_prbs) after prbs sync (default)\r\n\t1:(before_prbs) before prbs sync (original mode)\r\n\trjr
#define EDI_RX_RESET_CFG_ENA                               300,  0,  1 // EDI_RX_RESET_ACT_PG :: enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EDI_RX_CLR_PAR_ERRS                                300, 14,  1 // EDI_RX_RESET_ACT_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.\r\n\tpmt
#define EDI_RX_FIR_RESET                                   300, 15,  1 // EDI_RX_RESET_ACT_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_RX_BUS_ID                                      301,  0,  6 // EDI_RX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EDI_RX_GROUP_ID                                    301,  7,  6 // EDI_RX_ID1_PG :: this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EDI_RX_LAST_GROUP_ID                               302,  0,  6 // EDI_RX_ID2_PG :: this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EDI_RX_START_LANE_ID                               303,  1,  7 // EDI_RX_ID3_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_RX_END_LANE_ID                                 303,  9,  7 // EDI_RX_ID3_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_RX_MINIKERF                                    304,  0, 16 // EDI_RX_MINIKERF_PG :: rx minikerf control bits.\r\n\t  bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) only for centaur. all other buses use the tx_minikerf_pb\r\n\t (0:2)=011 - rx cleanup pll atst on pad_io_p. pad_io_n=0. \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - reserved. \r\n\t (0:2)=110 - rx cleanup pll clk on c4 pads. \r\n\t (0:2)=111 - reserved\r\n\tsmc
#define EDI_RX_SLS_DISABLE                                 306,  0,  1 // EDI_RX_SLS_MODE_PG :: disables receiving & decoding of sls commands\r\n\tsmr
#define EDI_TX_SLS_DISABLE                                 306,  1,  1 // EDI_RX_SLS_MODE_PG :: if set, the sls command being sent will always just be a nop.  to truly disable the full sls logic path, also do some combination of the following (depending on what exactly you are trying to do): set the rx_sls_disable, manually override the tx_snd_sls_cmd_gcrmsg per pack registers (if you do not also disable the various sending sms, though, this will eventually get overwritten), set tx_sls_lane_val_gcrmsg to 0 (if there is no valid tx sls lane, no sls command will get sent on it), and/or disable the recal, repair, recovery sms (rx_dyn_recal_suspend, rx_dyn_rpr_disable, rx_sls_rcvy_disable) that initiate the sending of sls commands\r\n\tsmr
#define EDI_RX_SLS_CNTR_TAP_PTS                            306,  2,  2 // EDI_RX_SLS_MODE_PG :: how long the sls rx command needs to be stable for.\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 16 c8 clks; ei4 - 32 c4 clks\r\n\t01:(tap2) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t10:(tap3) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t11:(tap4) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\tsmr
#define EDI_RX_NONSLS_CNTR_TAP_PTS                         306,  4,  2 // EDI_RX_SLS_MODE_PG :: how long a non-sls rx command needs to be stable for (to know we have switched from an sls command to data).\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t01:(tap2) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t10:(tap3) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\t11:(tap4) edi - 256 c8 clks; ei4 - 512 c4 clks\r\n\tsmr
#define EDI_RX_SLS_ERR_CHK_RUN                             306,  6,  1 // EDI_RX_SLS_MODE_PG :: run sls error check counter\r\n\tsmr
#define EDI_RX_FINAL_NOP_CS                                306,  7,  1 // EDI_RX_SLS_MODE_PG :: hw210823 chicken switch.  0: allows receiver of final nop to accept either sls_nop or sls_*_req to exit the handshake sm; 1: reverts to original dd1.0 logic to only accept nop to exit the handshake sm. \r\n\tsmr
#define EDI_RX_SR_FINAL_NOP_TIMEOUT_SEL                    306,  8,  3 // EDI_RX_SLS_MODE_PG :: hw232404: for ei4 in the case of 2 bad lanes, so no sls lane, how long to wait for final nop during static repair. \r\n\t000:(tap0) 0.8ns (one cycle chicken switch) \r\n\t001:(tap1) 1.7us \r\n\t010:(tap2) 3.4us \r\n\t011:(tap3) 6.8us \r\n\t100:(tap4) 13.6us \r\n\t101:(tap5) 27.2us \r\n\t110:(tap6) 54.6us \r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_RX_SLS_EXCEPTION2_CS                           306, 11,  1 // EDI_RX_SLS_MODE_PG :: hw235842: added chicken switch for new sls exception2 command.  need to set this when mixing allv3 and later logic with logic previous to allv3\r\n\tif set to 1, should set rx_sls_timeout_sel > 4x recal_overall_timeout_sel so avoid sending exception on sr interval and seeing false exception resmr
#define EDI_RX_START_WDERF_ALIAS                           307,  0,  5 // EDI_RX_TRAINING_START_PG :: alias for rx_start_* bits\r\n\tpmt
#define EDI_RX_START_WIRETEST                              307,  0,  1 // EDI_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the wiretest portion of the training states.\r\n\trjr
#define EDI_RX_START_DESKEW                                307,  1,  1 // EDI_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the deskew portion of the training states.\r\n\trjr
#define EDI_RX_START_EYE_OPT                               307,  2,  1 // EDI_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the data eye optimization portion of the training states.\r\n\trjr
#define EDI_RX_START_REPAIR                                307,  3,  1 // EDI_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the static lane repair portion of the training states.\r\n\trjr
#define EDI_RX_START_FUNC_MODE                             307,  4,  1 // EDI_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the transition to functional data portion of the training states.\r\n\trjr
#define EDI_RX_START_BIST                                  307,  5,  1 // EDI_RX_TRAINING_START_PG :: set bit to run bist and perform the required tx fifo init, rx cu pll lock, rx fifo init, and offset calibration in the bist helper state machine. the rx bist state machine is enabled through a gcr message to the rx_bist_en register field. \r\n\t0: (idle) idle \r\n\t1: (en_rx_bist) start rx bist \r\n\tjgr
#define EDI_RX_START_OFFSET_CAL                            307,  6,  1 // EDI_RX_TRAINING_START_PG :: set bit to run offset cal and the required tx fifo init, rx cu pll lock, and rx fifo init through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (ocal) start offset cal \r\n\tjgr
#define EDI_RX_START_WT_BYPASS                             307,  7,  1 // EDI_RX_TRAINING_START_PG :: set bit to run wiretest bypass and the required tx fifo initialization through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (wtbyp) start wiretest bypass \r\n\tjgr
#define EDI_RX_WDERF_DONE_ALIAS                            308,  0,  5 // EDI_RX_TRAINING_STATUS_PG :: alias for rx_*_done bits\r\n\tpmt
#define EDI_RX_WIRETEST_DONE                               308,  0,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the wiretest training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_DESKEW_DONE                                 308,  1,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the deskew training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_EYE_OPT_DONE                                308,  2,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the eye optimization training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_REPAIR_DONE                                 308,  3,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the static lane repair training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_FUNC_MODE_DONE                              308,  4,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the transition to functional data training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_BIST_STARTED                                308,  5,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx bist helper initializations have completed and a gcr enable message has been sent to rx bist. \r\n\tjgr
#define EDI_RX_OFFSET_CAL_DONE                             308,  6,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, offset cal has completed. \r\n\tjgr
#define EDI_RX_WT_BYPASS_DONE                              308,  7,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, wiretest bypass has completed. \r\n\tjgr
#define EDI_RX_WDERF_FAILED_ALIAS                          308,  8,  5 // EDI_RX_TRAINING_STATUS_PG :: alias for rx_*_failed bits\r\n\tpmt
#define EDI_RX_WIRETEST_FAILED                             308,  8,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the wiretest training state encountered an error.\r\n\trjr
#define EDI_RX_DESKEW_FAILED                               308,  9,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the deskew training state encountered an error.\r\n\trjr
#define EDI_RX_EYE_OPT_FAILED                              308, 10,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the eye optimization training state encountered an error.\r\n\trjr
#define EDI_RX_REPAIR_FAILED                               308, 11,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the static lane repair training state encountered an error.\r\n\trjr
#define EDI_RX_START_BIST_FAILED                           308, 13,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock and bist was not started. (this bit is set along with rx_wt_bypass_failed and rx_offset_cal_failed)\r\n\tjgr
#define EDI_RX_OFFSET_CAL_FAILED                           308, 14,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock and offset cal was not performed. (this bit is set along with rx_wt_bypass_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_WT_BYPASS_FAILED                            308, 15,  1 // EDI_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock. wiretest bypass did not complete. (this bit is set along with rx_offset_cal_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_RECAL_STATUS                                309,  0, 16 // EDI_RX_RECAL_STATUS_PG :: no longer used--remove for dd2 design\r\n\trjr
#define EDI_RX_WT_CHECK_COUNT                              355,  0,  5 // EDI_RX_WT_CONFIG_PG :: selects number of extra times the wiretest pattern is checked for a good lane \r\n\trjr
#define EDI_RX_WT_CHECK_LANES                              355,  5,  2 // EDI_RX_WT_CONFIG_PG :: selects number of lanes that are checked during all-ones or all-zeroes check during wiretest:\r\n\t00:check all good lanes \r\n\t01:check majority of good lanes\r\n\t10:check half of good lanes\r\n\t11:check good lanes-2\r\n\trjr
#define EDI_RX_SLS_TIMEOUT_SEL                             310,  0,  4 // EDI_RX_TIMEOUT_SEL_PG :: selects spare lane signalling timeout value (how long to wait for a sls handshake command)\r\n\t0000:(tap0) 6.8us very small value for sim only\r\n\t0001:(tap1) 54.6us \r\n\t0010:(tap2) 109.2us \r\n\t0011:(tap3) 218.4us \r\n\t0100:(tap4) 436.7us \r\n\t0101:(tap5) 873.5us \r\n\t0110:(tap6) 1.7ms \r\n\t0111:(tap7) 3.5ms \r\n\t1000:(tap8) 7.0ms \r\n\t1001:(tap9) 14.0ms \r\n\t1010:(tap10) 28.0ms \r\n\t1011:(tap11) 55.9ms \r\n\t1100:(tap12) 111.8ms \r\n\t1101:(tap13) 447.2ms \r\n\t1110:(tap14) 1.8 s \r\n\t1111:(tap15) infinite\r\n\tnote: value must be 4x larger than tx_dyn_recal_interval_timeout_sel when doing recal aborts, and should really be 4x rx_dyn_recal_overall_timeout_sel.\r\n\tsmr
#define EDI_RX_DS_BL_TIMEOUT_SEL                           310,  4,  3 // EDI_RX_TIMEOUT_SEL_PG :: selects deskew block lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_CL_TIMEOUT_SEL                              310,  7,  3 // EDI_RX_TIMEOUT_SEL_PG :: selects clock lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_WT_TIMEOUT_SEL                              310, 10,  3 // EDI_RX_TIMEOUT_SEL_PG :: selects wiretest timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_DS_TIMEOUT_SEL                              310, 13,  3 // EDI_RX_TIMEOUT_SEL_PG :: selects deskew  timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_OFFSET_TIMEOUT_SEL                       322,  0,  3 // EDI_RX_TIMEOUT_SEL1_PG :: selects latch offset timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_AMP_TIMEOUT_SEL                          322,  3,  3 // EDI_RX_TIMEOUT_SEL1_PG :: selects  amplitude measurement watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_CTLE_TIMEOUT_SEL                         322,  6,  3 // EDI_RX_TIMEOUT_SEL1_PG :: selects  ctle ajdust watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_H1AP_TIMEOUT_SEL                         322,  9,  3 // EDI_RX_TIMEOUT_SEL1_PG :: selects  h1ap ajdust watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_DDC_TIMEOUT_SEL                          322, 12,  3 // EDI_RX_TIMEOUT_SEL1_PG :: selects  ddc watchdog timeout (edi only). \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_TIMEOUT_SEL                    322, 15,  1 // EDI_RX_TIMEOUT_SEL1_PG :: selects final load to unload delay qualification time per step. \r\n\t0:(tap0) 4k ui or 0.425us \r\n\t1:(tap1) 64k ui or 6.8us\r\n\tmbs
#define EDI_RX_FUNC_MODE_TIMEOUT_SEL                       342,  0,  3 // EDI_RX_TIMEOUT_SEL2_PG :: selects functional mode wait timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_RC_SLOWDOWN_TIMEOUT_SEL                     342,  3,  3 // EDI_RX_TIMEOUT_SEL2_PG :: selects recal  slowdown      timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 0   ui or   0us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_PUP_LITE_WAIT_SEL                           342,  6,  2 // EDI_RX_TIMEOUT_SEL2_PG :: how long to wait for analog logic to power up an unused spare lane for recal and repair\r\n\t00:(tap0) 833ps (for sim use only)\r\n\t01:(tap1) 107ns (default value)\r\n\t10:(tap2) 213ns\r\n\t11:(tap3) 427ns\r\n\tsmr
#define EDI_RX_EO_L2U_WD_TIMEOUT_SEL                       342,  9,  3 // EDI_RX_TIMEOUT_SEL2_PG :: selects final load to unload delay watchdog timeout.\r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_VGA_WD_TIMEOUT_SEL                       342, 12,  4 // EDI_RX_TIMEOUT_SEL2_PG :: selects watchdog timeout for vga adjustment. \r\n\t0000:(tap0) 1.7us \r\n\t0001:(tap1) 54.6 us \r\n\t0010:(tap2) 109.2us \r\n\t0011:(tap3) 218.4us \r\n\t0100:(tap4) 436.7us \r\n\t0101:(tap5) 873.4us \r\n\t0110:(tap6) 1.7ms \r\n\t0111:(tap7) 3.5ms \r\n\t1000:(tap8) 7.0ms \r\n\t1001:(tap9) 13.9ms \r\n\t1010:(tap10) 27.9ms \r\n\t1011:(tap11) 55.9ms \r\n\t1100:(tap12) 111.7ms \r\n\t1101:(tap13) 447.2ms \r\n\t1110:(tap14) 1.7 sec \r\n\t1111:(tap15) infinite\r\n\trjr
#define EDI_RX_FIFO_INITIAL_L2U_DLY                        311,  0,  4 // EDI_RX_FIFO_MODE_PG :: rx fifo initial load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 16-20 ui\r\n\trjr
#define EDI_RX_FIFO_FINAL_L2U_DLY                          311,  4,  4 // EDI_RX_FIFO_MODE_PG :: rx fifo final load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 8-12 ui\r\n\trjr
#define EDI_RX_FIFO_FINAL_L2U_MIN_ERR_THRESH               311, 12,  2 // EDI_RX_FIFO_MODE_PG :: rx fifo error threshold used to qualify the minimum load to unload delay as bad, which is used as the point of reference for adjusting to the final load to unload delay. note that the errors are accumulated across the entire clock group for a length of time selected by rx_eo_final_l2u_timeout_sel. \r\n\t00:(tap0) 8 errors \r\n\t01:(tap1) 16 errors \r\n\t10:(tap2) 128 errors \r\n\t11:(tap3) 255 errors\r\n\tmbs
#define EDI_RX_SLS_CMD_VAL                                 312,  0,  1 // EDI_RX_SLS_STATUS_PG :: current sls command valid\r\n\tsmr
#define EDI_RX_SLS_CMD_ENCODE                              312,  2,  6 // EDI_RX_SLS_STATUS_PG :: current sls command\r\n\t000000:(nop) null operation\r\n\t000001:(shadow_request) driven by the rx side to request shadowing of its receive lane from lane n-1 to lane n\r\n\t000010:(shadow_done) driven by the rx side to signal now receiving lane n-1s data on lane n\r\n\t000011:(shadow_repair_request) driven by the rx side to request shadowing and repair of its receive lane from lane n-1 to n.\r\n\t000100:(shadow_repair_done) driven by the rx side to signal lane n-1 is repaired.\r\n\t000101:(unshadow_request) driven by the rx side to request shadowing of receive lane from lane n+1 to lane n.\r\n\t000110:(unshadow_done) driven by the rx side to signal now receiving lane n+1 data on lane n\r\n\t000111:(unshadow_repair_request) driven by the rx side to request unshadowing and repair of its receive lane from lane n+1 to lane n.\r\n\t001000:(unshadow_repair_done) driven by the rx side to signal lane n+1 is repaired.\r\n\t001001:(sls_exception) driven by the rx side to indicate to the other side of the bus its rx sls lane is broken.\r\n\t001010:(init_done) driven to signal the ctle/dfe/offset (re-)calibration operations have completed (not currently used).\r\n\t001011:(recal_request) driven on recalibration lane x to request a recalibration of its receive recalibration lane y.\r\n\t001100:(recal_running) driven during the status reporting interval of recalibration to indicate recalibration has not completed\r\n\t001101:(recal_done) driven to indicate its recalibration is complete.\r\n\t001110:(recal_failed) driven to indicate recalibration has failed on its receive recalibration lane\r\n\t001111:(recal_abort) abort recalibration.\r\n\t010000:(reserved2) reserved.010001:(reserved3) reserved.\r\n\t010010:(reserved4) reserved.\r\n\t010011:(reserved5) reserved.\r\n\t010100:(reserved6) reserved.\r\n\t010101:(reserved7) reserved.\r\n\t010110:(reserved8) reserved.\r\n\t010111:(reserved9) reserved.\r\n\t011000:(reserved10) reserved.\r\n\t\n011001:(init_ack_done) driven in response to an init_done (not currently used).\r\n\t011010:(reserved11) reserved.\r\n\t011011:(recal_ack) driven on recalibration lane y in response to a recal_request on its receive recalibration lane x\r\n\t011100:(reserved12) reserved.\r\n\t011101:(reserved13) reserved.\r\n\t011110:(reserved14) reserved.\r\n\t011111:(recal_abort_ack) abort recalibration acknowledge.\r\n\t1cdddd: transmits four bits of data dddd command each time clock c toggles.\r\n\tsmr
#define EDI_RX_SLS_ERR_CHK_CNT                             312,  8,  8 // EDI_RX_SLS_STATUS_PG :: error count result for sls error checking mode\r\n\tsmr
#define EDI_RX_PG_FIR_TRAINING_ERROR                       320,  0,  1 // EDI_RX_FIR_TRAINING_PG :: this field is now defunct and is permanently masked in the rx_fir_training_mask_pg fir isolation register.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_SPARE_DEPLOYED                320,  1,  1 // EDI_RX_FIR_TRAINING_PG :: a spare lane has been deployed during training to heal a lane that was detected as bad. rx_static_spare_deployed (ssd) will be set after the repair training step if during training either wiretest, deskew, eyeopt or repair has detected one or more bad lanes have been detected. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed and the rx_bad_lane.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED           320,  2,  1 // EDI_RX_FIR_TRAINING_PG :: a lane has been detected as bad during training but there are no spare lanes available to heal it. this fir will not be set until the repair training step has been run. this is a catastrophic failure for the bus when in mission mode but all training steps will still be run on whatever good lanes there are. rx_static_max_spares_exceeded will be set if wiretest, deskew, eyeopt or repair find the excessive number of bad lanes.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_REPAIR_ERROR                 320,  3,  1 // EDI_RX_FIR_TRAINING_PG :: a dynamic repair error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED               320,  4,  1 // EDI_RX_FIR_TRAINING_PG :: a spare lane has been deployed by ecc/crc logic to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED          320,  5,  1 // EDI_RX_FIR_TRAINING_PG :: a lane has been detected as bad by ecc/crc logic but there are no spare lanes to heal it. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_ERROR                          320,  6,  1 // EDI_RX_FIR_TRAINING_PG :: a recalibration error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_SPARE_DEPLOYED                 320,  7,  1 // EDI_RX_FIR_TRAINING_PG :: a spare lane has been deployed during recal to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED            320,  8,  1 // EDI_RX_FIR_TRAINING_PG :: a lane has been detected as bad during recal but there are no spare lanes to heal it. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_PG_FIR_TOO_MANY_BUS_ERRORS                  320,  9,  1 // EDI_RX_FIR_TRAINING_PG :: more than one lane has been detected as having too many errors during functional operation. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_PG_FIR_TRAINING_ERROR_MASK                  321,  0,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_training_error.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_SPARE_DEPLOYED_MASK           321,  1,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED_MASK      321,  2,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_max_spares_exceeded\r\n\tpmt.
#define EDI_RX_PG_FIR_DYNAMIC_REPAIR_ERROR_MASK            321,  3,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_repair_error\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED_MASK          321,  4,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED_MASK     321,  5,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_max_spares_exceeded.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_ERROR_MASK                     321,  6,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_error.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_SPARE_DEPLOYED_MASK            321,  7,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED_MASK       321,  8,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_max_spares_exceeded.\r\n\tpmt
#define EDI_RX_PG_FIR_TOO_MANY_BUS_ERRORS_MASK             321,  9,  1 // EDI_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_too_many_bus_errors.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERRS_FULL_REG                       314,  0, 16 // EDI_RX_FIR1_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERRS                                314,  0, 14 // EDI_RX_FIR1_PG :: a per-group rxctl register or state machine parity error has occurred.\r\n\tbit0: (par_err_rxctl_regs) rxctl register parity error.\r\n\tbit1: reserved\r\n\tbit2: reserved\r\n\tbit3: (par_err_gcrs_ld_state) rxctl gcr load state machine parity error.\r\n\tbit4: (par_err_gcrs_unld_state) rxctl gcr unload state machine parity error.\r\n\tbit5: (par_err_snd_msg_state)\r\n\tbit6: (par_err_rx_main_init_state) rxctl main init sm parity error.\r\n\tbit7: (par_err_rx_wtm_state) rxctl wiretest main sm parity error.\r\n\tbit8: (par_err_rx_wtr_state)\r\n\tbit9: (par_err_rx_wtl_state)\r\n\tbit10: (par_err_rx_rpr_state)\r\n\tbit11: (par_err_rx_eyeopt_state)\r\n\tbit12: (par_err_dsm_state)\r\n\tbit13: (par_err_rxdsm_state)\r\n\tbit14:(channel_fail) dmi-only\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_PG_REGS                          314,  0,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rxctl registers.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GCR_BUFF                         314,  1,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_GCRS_LD_SM                       314,  3,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr load state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GCRS_UNLD_SM                     314,  4,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr unload state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GLB_INIT_SND_MSG_SM              314,  5,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MAIN_INIT_SM                     314,  6,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main init state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTM_SM                           314,  7,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTR_SM                           314,  8,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group receiver wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTL_SM                           314,  9,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group lane wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RPR_SM                           314, 10,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group repair state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_EYEOPT_SM                        314, 11,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DSM_SM                           314, 12,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main deskew state machine.the deskew main state machines function is to control both the driver and receiver sub-machines during block lock, deskew, and prbs scrambler/descrambler synchronization.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RXDSM_SM                         314, 13,  1 // EDI_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rx deskew state machine.\r\n\tpmt
#define EDI_RX_PG_CHAN_FAIL_RSVD                           314, 14,  1 // EDI_RX_FIR1_PG :: iotk alias: reserved.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR                                  314, 15,  1 // EDI_RX_FIR1_PG :: summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS_FULL_REG                       315,  0,  9 // EDI_RX_FIR2_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS                                315,  0,  9 // EDI_RX_FIR2_PG :: a per-group register or state machine parity error has occurred.\r\n\tbit0: (err_dyn_rpr_sm) rxctl dynamic repair sm parity error.\r\n\tbit1: (err_sls_hndshk_sm) rxctl sls handshake sm parity error.\r\n\tbit2: (err_rpr_snd_msg_sm) rxctl repair send message sm parity error.\r\n\tbit3: (err_recal_sm) rxctl recal state machine parity error.\r\n\tbit4: reserved.\r\n\tbit5: reserved.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DYN_RPR_SM                       315,  0,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_SLS_HNDSHK_SM                    315,  1,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic sls state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DYN_RPR_SND_MSG_SM               315,  2,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RECAL_SM                         315,  3,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_SLS_ENC_SND_MSG_SM               315,  4,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_GLB_CAL_SND_MSG_SM               315,  5,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group global cal gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              315,  6,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_SLS_RCVY_SM                      315,  7,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair sls recovery state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_PP_REGS                          315,  8,  1 // EDI_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-pack registers.\r\n\tdmb
#define EDI_RX_PG_FIR1_ERRS_MASK_FULL_REG                  316,  0, 16 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for rx_fir1_pg errors.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERRS_MASK                           316,  0, 14 // EDI_RX_FIR1_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_PG_REGS                     316,  0,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl register checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GCR_BUFF                    316,  1,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr buffer.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                  316,  3,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr load state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                316,  4,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GLB_INIT_SND_MSG_SM         316,  5,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl repair state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_MAIN_INIT_SM                316,  6,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr send message state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTM_SM                      316,  7,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl main init state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTR_SM                      316,  8,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl main wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTL_SM                      316,  9,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl receiver wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RPR_SM                      316, 10,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl lane wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_EYEOPT_SM                   316, 11,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DSM_SM                      316, 12,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group main deskew state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RXDSM_SM                    316, 13,  1 // EDI_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rx deskew state machine.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK                             316, 15,  1 // EDI_RX_FIR1_MASK_PG :: fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS_MASK_FULL_REG                  317,  0,  9 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for rx_fir2_pg errors.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS_MASK                           317,  0,  9 // EDI_RX_FIR2_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_dyn_rpr_sm) rxctl dynamic repair sm parity error mask.\r\n\tbit1: (mask_sls_hndshk_sm) rxctl sls handshake sm parity error mask.\r\n\tbit2: (mask_rpr_snd_msg_sm) rxctl repair send message sm parity error mask.\r\n\tbit3: (mask_recal_sm) rxctl recal state machine parity error mask.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DYN_RPR_SM                  317,  0,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_SLS_HNDSHK_SM               317,  1,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group lane repair logic sls state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DYN_RPR_SND_MSG_SM          317,  2,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RECAL_SM                    317,  3,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_SLS_ENC_SND_MSG_SM          317,  4,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_GLB_CAL_SND_MSG_SM          317,  5,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group global cal gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         317,  6,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_SLS_RCVY_SM                 317,  7,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls recovery state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_PP_REGS                     317,  8,  1 // EDI_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group per-pack registers.\r\n\tdmb
#define EDI_RX_PG_FIR1_ERR_INJ_FULL_REG                    318,  0, 16 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERR_INJ                             318,  0, 14 // EDI_RX_FIR1_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_PG_REGS                      318,  0,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GCR_BUFF                     318,  1,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                   318,  3,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 318,  4,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GLB_INIT_SND_MSG_SM          318,  5,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_MAIN_INIT_SM                 318,  6,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main init state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTM_SM                       318,  7,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTR_SM                       318,  8,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTL_SM                       318,  9,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RPR_SM                       318, 10,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_EYEOPT_SM                    318, 11,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl eye opt state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DSM_SM                       318, 12,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RXDSM_SM                     318, 13,  1 // EDI_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERR_INJ_FULL_REG                    319,  0,  9 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERR_INJ                             319,  0,  9 // EDI_RX_FIR2_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_dyn_rpr_sm) rxctl dynamic repair sm parity error inject.\r\n\tbit1: (inj_sls_hndshk_sm) rxctl sls handshake sm parity error inject.\r\n\tbit2: (inj_rpr_snd_msg_sm) rxctl repair send message sm parity error inject.\r\n\tbit3: (inj_recal_sm) rxctl recal state machine parity error inject.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DYN_RPR_SM                   319,  0,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on per-group lane repair logic state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_SLS_HNDSHK_SM                319,  1,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group lane repair logic sls state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DYN_RPR_SND_MSG_SM           319,  2,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group dynamic lane repair logic gcr send message state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RECAL_SM                     319,  3,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_SLS_ENC_SND_MSG_SM           319,  4,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls encode gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_GLB_CAL_SND_MSG_SM           319,  5,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group global cal gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          319,  6,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group stat repair gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_SLS_RCVY_SM                  319,  7,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls recovery state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_PP_REGS                      319,  8,  1 // EDI_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group per pack register checker.\r\n\tdmb
#define EDI_RX_LANE_BAD_VEC_0_15                           323,  0, 16 // EDI_RX_LANE_BAD_VEC_0_15_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).to be clear, the bad_lane vector is only updated during training.  it will not reflect bad lanes found post training during dynamic repair or dynamic recal.  for that, you need to read the [rx,tx]_bad_lane[1,2]_gcrmsg registers.  to calculate what you want to know, you need five registers:\r\n\t rx_bad_lane1_gcrmsg\r\n\t rx_bad_lane2_gcrmsg\r\n\t rx_bad_lane_code_gcrmsg\r\n\t rx_sls_lane_gcrmsg\r\n\t rx_wtr_max_bad_lanes\r\n\tin general, if the spares deployed fir goes on, and the bad_lane_code is a 1, then the newly spared lane resides in the rx_bad_lane1_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 2, then the newly spared lane resides in the rx_bad_lane2_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 3, then the newly spared lane resides in the rx_sls_lane_gcrmsg register. that might be enough information for what you want to know, trying to keep the answer very general.  at the moment, this case where both the spare deployed and max spares exceeded both come on at the same time, is for the edi where a third bad lane has been found and we have chosen to use the sls lane as a third spare. edi normally only has two spare lanes. in that case, i first set the spare deployed fir as the sls lane is being used as a third spare. but then a few cycles later, i set the max spares exceeded because i no longer have an sls lane and cant finish my sls repair handshake.\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_16_31                          324,  0, 16 // EDI_RX_LANE_BAD_VEC_16_31_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_0_15                      325,  0, 16 // EDI_RX_LANE_DISABLED_VEC_0_15_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_16_31                     326,  0, 16 // EDI_RX_LANE_DISABLED_VEC_16_31_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_SWAPPED_VEC_0_15                       327,  0, 16 // EDI_RX_LANE_SWAPPED_VEC_0_15_PG :: wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EDI_RX_LANE_SWAPPED_VEC_16_31                      328,  0, 16 // EDI_RX_LANE_SWAPPED_VEC_16_31_PG :: wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EDI_RX_MAIN_INIT_STATE                             329,  0,  4 // EDI_RX_INIT_STATE_PG :: main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused\r\n\trjr
#define EDI_RX_WTM_STATE                                   330,  0,  5 // EDI_RX_WIRETEST_STATE_PG :: main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail \r\n\trjr
#define EDI_RX_WTR_STATE                                   330,  5,  4 // EDI_RX_WIRETEST_STATE_PG :: receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused\r\n\trjr
#define EDI_RX_WTL_STATE                                   330, 11,  5 // EDI_RX_WIRETEST_STATE_PG :: lane wiretest sub state machine current state (rjr)\r\n\tx00: idle\r\n\tx01: wait 1st long transition\r\n\tx02: wait 2nd long transition\r\n\tx03: wait short transition\r\n\tx04: wait transition from pn=01\r\n\tx05: wait transition from 10\r\n\tx06: wait transition from 00\r\n\tx07: wait transition from 11\r\n\tx10: good-no swap\r\n\tx11: bad-n=1-no swap\r\n\tx12: bad-n=0-no swap\r\n\tx13: bad-p=1-no swap\r\n\tx14: bad-p=0-no swap\r\n\tx15: bad-p or n floating\r\n\tx16: bad-pn=00\r\n\tx17: bad-pn=11\r\n\tx18: good--swapped\r\n\tx19: bad-n=1-swapped\r\n\tx1a: bad-n=0-swapped\r\n\tx1b: bad-p=1-swapped\r\n\tx1c: bad-p=0-swapped\r\n\tx1d: bad-pn=10\r\n\tx1e: bad-pn=01\r\n\tx1f: bad-unknown failure\r\n\trjr
#define EDI_RX_WTL_DONE_ALIAS                              330, 11,  1 // EDI_RX_WIRETEST_STATE_PG :: iotk alias: wiretest lane state machine done indication(rjr):\r\n\t0: idling or running.\r\n\t1: done\r\n\trjr
#define EDI_RX_WTL_P_N_SWAP_ALIAS                          330, 12,  1 // EDI_RX_WIRETEST_STATE_PG :: iotk alias: for wiretest lane state machine p/n wire swap indication(rjr):\r\n\t0: lane p/n wires not swapped.\r\n\t1: lane p/n wires swapped\r\n\t:may have different meaning if fault code is non-zero\r\n\trjr
#define EDI_RX_WTL_FAULT_CODE_ALIAS                        330, 13,  3 // EDI_RX_WIRETEST_STATE_PG :: iotk alias: for wiretest lane state machine fault code(rjr):\r\n\t000: lane good.\r\n\t001: lane n wire stuck at 1.\r\n\t010: lane n wire stuck at 0.\r\n\t011: lane p wire stuck at 1\r\n\t100: lane p wire stuck at 0\r\n\t101: lane n or p wire floating: swap status invalid.\r\n\t110: lane p and n stuck--00 if swap=0, 10 if swap=1, swap status invalid.\r\n\t111: p and n stuck at 1 if swap=0 unknown failure if swap=1.\r\n\trjr
#define EDI_RX_WTR_CUR_LANE                                331,  0,  5 // EDI_RX_WIRETEST_LANEINFO_PG :: wiretest current lane under test\r\n\trjr
#define EDI_RX_WTR_MAX_BAD_LANES                           331,  5,  5 // EDI_RX_WIRETEST_LANEINFO_PG :: wiretest max number of bad lanes allowed per clk group\r\n\trjr\r\n\talso static repair, dynamic repair & recal max number of bad lanes per rx bus (note: should match tx side)\r\n\tsmr
#define EDI_RX_WTR_BAD_LANE_COUNT                          331, 11,  5 // EDI_RX_WIRETEST_LANEINFO_PG :: wiretest current number of bad lanes in this clk group\r\n\trjr
#define EDI_RX_WT_PREV_DONE_GCRMSG                         332,  0,  1 // EDI_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has completed wiretest\r\n\tjfg
#define EDI_RX_WT_ALL_DONE_GCRMSG                          332,  1,  1 // EDI_RX_WIRETEST_GCRMSG_PG :: gcr message: all clk groups have completed wiretest\r\n\tjfg
#define EDI_RX_CD_PREV_DONE_GCRMSG                         332,  2,  1 // EDI_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has finished sending & receiving 4 clk/data sls commands\r\n\tsmr
#define EDI_RX_CD_ALL_DONE_GCRMSG                          332,  3,  1 // EDI_RX_WIRETEST_GCRMSG_PG :: gcr message: all clk groups have completed sending & receiving 4 clk/data sls commands.  in the case of the slave side, also the final nop has been received.\r\n\tsmr
#define EDI_RX_CNTLS_PREV_LDED_GCRMSG                      332,  4,  1 // EDI_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has finished updating rx sls/bad lane & repair controls\r\n\tsmr
#define EDI_RX_WT_CU_PLL_PGOOD                             357,  0,  1 // EDI_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_RESET                             357,  1,  1 // EDI_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing\r\n\tjfg
#define EDI_RX_WT_CU_PLL_PGOODDLY                          357,  2,  3 // EDI_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll pgood delay selects length of reset period after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking period \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_LOCK                              357,  5,  1 // EDI_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll locked\r\n\tjfg
#define EDI_RX_WT_PLL_REFCLKSEL                            357,  6,  1 // EDI_RX_WIRETEST_PLL_CNTL_PG :: select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock\r\n\tdmb
#define EDI_RX_PLL_REFCLKSEL_SCOM_EN                       357,  7,  1 // EDI_RX_WIRETEST_PLL_CNTL_PG :: selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock\r\n\tdmb
#define EDI_RX_DESKEW_SEQ_GCRMSG                           333,  0,  3 // EDI_RX_DESKEW_GCRMSG_PG :: gcr message: rx deskew sequencer gcr messages\r\n\t000:(dsprevdeskewed) indicate prior group deskewed.\r\n\t001:(dsalldeskewed) indicate all groups deskewed.\r\n\t010:(dsprevdone) indicate prior group completed deskew.\r\n\t011:(dsalldone) indicate all groups completed deskew.\r\n\t100:(dsprevskew) transmit skew values from prior group.\r\n\t101:(dsmaxskew) transmit max skew values to all groups.\r\n\t110:(unused) unused.\r\n\t111:(dsnomsg) no message.\r\n\trjr
#define EDI_RX_DESKEW_SKMIN_GCRMSG                         333,  4,  6 // EDI_RX_DESKEW_GCRMSG_PG :: gcr message: min skew value for deskew sequence.\r\n\trjr
#define EDI_RX_DESKEW_SKMAX_GCRMSG                         333, 10,  6 // EDI_RX_DESKEW_GCRMSG_PG :: gcr message: max skew value for deskew sequence.\r\n\trjr
#define EDI_RX_DSM_STATE                                   334,  2,  6 // EDI_RX_DESKEW_STATE_PG :: main deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init tx fifo\r\n\tx02: master driver patt b\r\n\tx03:block lock\r\n\tx04: check skew\r\n\tx05:send skew to other groups\r\n\tx06: wait for max skew message\r\n\tx07: check max skew\r\n\tx08: deskew group\r\n\tx09: send deskewed message\r\n\tx0a: wait for all deskewd message\r\n\tx0b: deskew group\r\n\tx0c: drive prbs sync\r\n\tx0d: wait for prbs synced\r\n\tx0e: send done message\r\n\tx0f: wait for all done message\r\n\tx10: slave drive patt a\r\n\tx11: enable prbs sync checking\r\n\t:x12-x1e: unused\r\n\tx1f: deskew done\r\n\tx20-x22: unused\r\n\tx23: block lock failed\r\n\tx24: group skew measure fail--timeout\r\n\tx25: group skew fail-rxdsm fail\r\n\tx25: bus deskew fail\r\n\tx27: max skew in group fail\r\n\tx28: group deskew timeout fail\r\n\tx29: unused\r\n\tx2a: bus deskew timeout fail\r\n\tx2b-x2c: unused\r\n\tx2d: wait prbs sync timeout fail\r\n\tx2e: timeout while sending done message fail\r\n\tx2f: timeout waiting for bus deskew all done message fail\r\n\tx30-x3f: unused\r\n\trjr
#define EDI_RX_RXDSM_STATE                                 334,  9,  7 // EDI_RX_DESKEW_STATE_PG :: rx deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init rx fifo\r\n\tx02: start block lock\r\n\tx03:read block lock status\r\n\tx04: check block lock status\r\n\tx05:check lane valid\r\n\tx06: check max lane count\r\n\tx07: lane block lock status\r\n\tx08: write bad lane block lock\r\n\tx09: block lock done\r\n\tx0a: start check skew\r\n\tx0b: read skew status\r\n\tx0c: check skew status\r\n\tx0d: check valid lanes for skew\r\n\tx0e: check max lane count\r\n\tx0f: read first valid lane skew status\r\n\tx10: write bad skew status\r\n\tx11: check lane count\r\n\t:x12: check other lanes valid\r\n\tx13: read lane skew status\r\n\tx14: write lane bad skew stus\r\n\tx15: send rx skew valid to main deskew machine\r\n\tx16: check lane valid for deskew\r\n\tx17: read skew for deskewing\r\n\tx18:  write new rx fifo load-unload delay\r\n\tx19: write bad skew status\r\n\tx1a check last lane for done\r\n\tx1bb: clear skew status\r\n\tx1c: read global skew status\r\n\tx1d: check global skew status\r\n\tx1e: check lane valid for deskew check\r\n\tx1f: read lane deskew status\r\n\tx20: check lane count for done\r\n\tx21: stop checking skew\r\n\tx22: wait for check prbs sync signal\r\n\tx23: read prbs sync status\r\n\tx24: check prbs sync status\r\n\tx25: prbs synced/deskew done\r\n\tx26: clear deskew control\r\n\tx27: write bad deskew status\r\n\tx28-4d: unused\r\n\tx4e: skew error oddbadd fail\r\n\tx4f-7f: unused\r\n\trjr
#define EDI_RX_DESKEW_MAX_LIMIT                            335,  0,  6 // EDI_RX_DESKEW_MODE_PG :: maximum deskewable skew fail threshold \r\n\t000000:   0 ui \r\n\t000001:   2 ui \r\n\t000010:   4 ui \r\n\t000011:   6 ui \r\n\t000100:   8 ui \r\n\t000101:  10 ui \r\n\t000110:  12 ui \r\n\t000111:  14 ui \r\n\t001000:  16 ui \r\n\t001001:  18 ui \r\n\t001010:  20 ui \r\n\t001011:  22 ui > ei-4 max \r\n\t001100:  24 ui > ei-4 max \r\n\t001101:  26 ui > ei-4 max \r\n\t001110:  28 ui > ei-4 max \r\n\t001111:  30 ui > ei-4 max \r\n\t010000:  32 ui > ei-4 max \r\n\t010001:  34 ui > ei-4 max \r\n\t010010:  36 ui > ei-4 max \r\n\t010011:  38 ui > ei-4 max \r\n\t010100:  40 ui > ei-4 max \r\n\t010101:  42 ui > ei-4 max \r\n\t010110:  44 ui > ei-4 max \r\n\t010111:  46 ui > ei-4 & edi max \r\n\t011000:  48 ui > ei-4 & edi max \r\n\t011001:  50 ui > ei-4 & edi max \r\n\t011010:  52 ui > ei-4 & edi max \r\n\t011011:  54 ui > ei-4 & edi max \r\n\t011100:  56 ui > ei-4 & edi max \r\n\t011101:  58 ui > ei-4 & edi max \r\n\t011110:  60 ui > ei-4 & edi max \r\n\t011111:  62 ui > ei-4 & edi max \r\n\t100000:  64 ui > ei-4 & edi max \r\n\t100001:  66 ui > ei-4 & edi max \r\n\t100010:  68 ui > ei-4 & edi max \r\n\t100011:  70 ui > ei-4 & edi max \r\n\t100100:  72 ui > ei-4 & edi max \r\n\t100101:  74 ui > ei-4 & edi max \r\n\t100110:  76 ui > ei-4 & edi max \r\n\t100111:  78 ui > ei-4 & edi max \r\n\t101000:  80 ui > ei-4 & edi max \r\n\t101001:  82 ui > ei-4 & edi max \r\n\t101010:  84 ui > ei-4 & edi max \r\n\t101011:  86 ui > ei-4 & edi max \r\n\t101100:  88 ui > ei-4 max \r\n\t101101:  90 ui > ei-4 max \r\n\t101110:  92 ui > ei-4 max \r\n\t101111:  94 ui > ei-4 max \r\n\t110000:  96 ui > ei-4 max \r\n\t110001:  98 ui > ei-4 max \r\n\t110010: 100 ui > ei-4 max \r\n\t110011: 102 ui > ei-4 max \r\n\t110100: 104 ui > ei-4 max \r\n\t110101: 106 ui > ei-4 max \r\n\t110110: 108 ui > ei-4 max \r\n\t110111: 110 ui > ei-4 max \r\n\t111000: 112 ui > ei-4 & edi max \r\n\t111001: 114 ui > ei-4 & edi max \r\n\t111010: 116 ui > ei-4 & edi max \r\n\t111011: 118 ui > ei-4 & edi max \r\n\t111100: 120 ui > ei-4 & edi max \r\n\t111101: 122 ui > ei-4 & edi max \r\n\t111110: 124 ui > ei-4 & edi max \r\n\t111111: 126 ui > ei-4 & edi max \r\n\trjr
#define EDI_RX_DESKEW_MINSKEW_GRP                          336,  0,  6 // EDI_RX_DESKEW_STATUS_PG :: deskew per-group raw skew min\r\n\trjr
#define EDI_RX_DESKEW_MAXSKEW_GRP                          336,  6,  6 // EDI_RX_DESKEW_STATUS_PG :: deskew per-group raw skew max\r\n\trjr
#define EDI_RX_BAD_LANE1_GCRMSG                            337,  0,  7 // EDI_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane one in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE2_GCRMSG                            337,  7,  7 // EDI_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane two in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE_CODE_GCRMSG                        337, 14,  2 // EDI_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_RX_RPR_STATE                                   338,  0,  6 // EDI_RX_STATIC_REPAIR_STATE_PG :: static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state\r\n\tsmr
#define EDI_RX_FUNC_MODE_STATE                             376,  0,  4 // EDI_RX_FUNC_STATE_PG :: functional mode state machine(rjr):\r\n\trjr
#define EDI_RX_TX_BUS_WIDTH                                339,  0,  7 // EDI_RX_TX_BUS_INFO_PG :: tx bus width\r\n\tsmr
#define EDI_RX_RX_BUS_WIDTH                                339,  7,  7 // EDI_RX_TX_BUS_INFO_PG :: rx bus width\r\n\tsmr
#define EDI_RX_SLS_LANE_GCRMSG                             340,  0,  7 // EDI_RX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: encoded sls lane in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_SLS_LANE_VAL_GCRMSG                         340,  7,  1 // EDI_RX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: rx sls lane valid\r\n\tsmr
#define EDI_RX_FENCE                                       341,  0,  1 // EDI_RX_FENCE_PG :: rx & tx fence bit\r\n\t0:(unfenced) functional data is being driven to & front nest logic\r\n\t1:(fenced) functional data is gated to zeroes to & from nest logic. also indicates that link training not yet complete.\r\n\tsmr
#define EDI_RX_C4_SEL                                      343,  0,  2 // EDI_RX_MISC_ANALOG_PG :: select 1 of 4 possible phases for the c4 clock to send along with the data for integration flexibility and tuning for slack into the rx fifo.\r\n\tcpg
#define EDI_RX_NEGZ_EN                                     343,  2,  1 // EDI_RX_MISC_ANALOG_PG :: turns on a gyrator stage in the ctle pushing up the high freq corner\r\n\tcpg
#define EDI_RX_PROT_SPEED_SLCT                             343,  3,  1 // EDI_RX_MISC_ANALOG_PG :: tbd (enable the flux capacitor?)\r\n\tcpg
#define EDI_RX_IREF_BC                                     343,  4,  3 // EDI_RX_MISC_ANALOG_PG :: bias code for the iref macros on the rx side. all eight 3 bit codes enable current out. the cml voltage swings of the output current will vary with this code.\r\n\tcpg
#define EDI_RX_DYN_RPR_STATE                               344,  2,  6 // EDI_RX_DYN_RPR_PG :: dynamic repair main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_rpr_state\r\n\tsmr
#define EDI_RX_SLS_HNDSHK_STATE                            344,  8,  8 // EDI_RX_DYN_RPR_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_hndshk_state\r\n\tsmr
#define EDI_RX_DYN_RPR_REQ_GCRMSG                          345,  0,  1 // EDI_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc tallying logic has a dynamic repair request\r\n\tsmr
#define EDI_RX_DYN_RPR_LANE2RPR_GCRMSG                     345,  1,  7 // EDI_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc tallying logic bad lane to repair\r\n\tsmr
#define EDI_RX_DYN_RPR_IP_GCRMSG                           345,  8,  1 // EDI_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc bad lane repair in progress\r\n\tsmr
#define EDI_RX_DYN_RPR_COMPLETE_GCRMSG                     345,  9,  1 // EDI_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc bad lane repaired\r\n\tsmr
#define EDI_RX_DYN_RPR_BAD_LANE_MAX                        346,  0,  7 // EDI_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: max number of times a lane can be found bad before repaired\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_CNTR1_DURATION                  346,  7,  4 // EDI_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: duration the lane error counter1 can run before being cleared (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EDI_RX_DYN_RPR_CLR_ERR_CNTR1                       346, 11,  1 // EDI_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: firmware-based clear of lane error counter1 register\r\n\tsmr
#define EDI_RX_DYN_RPR_DISABLE                             346, 12,  1 // EDI_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: when set, disables dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2)\r\n\tsmr
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_WIDTH             346, 13,  3 // EDI_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: width of the enc_bad_data_lane vector used to determine number of 1s in clear code\r\n\tsmr
#define EDI_RX_SERVO_RECAL_IP                              352,  0,  1 // EDI_RX_DYN_RECAL_PG :: rx servo lane calibration in progress\r\n\tsmr
#define EDI_RX_DYN_RECAL_MAIN_STATE                        352,  2,  6 // EDI_RX_DYN_RECAL_PG :: dynamic recalibration main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_main_state\r\n\tsmr
#define EDI_RX_DYN_RECAL_HNDSHK_STATE                      352,  9,  7 // EDI_RX_DYN_RECAL_PG :: dynamic recalibration handshake state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_hndshk_state\r\n\tsmr
#define EDI_RX_EYE_OPT_STATE                               374,  0,  8 // EDI_RX_EO_RECAL_PG :: common edi/ei4 eye optimizaton state machine \r\n\t00000000: idle \r\n\t00000001: init latch offset cal done \r\n\t00000010: vref/dcd cal done \r\n\t00000011: vga done \r\n\t00000100: unused \r\n\t00000101: unused \r\n\t00000110: unused \r\n\t00000111: ctle done \r\n\t00001000: h1ap adjust done \r\n\t00001001: ddc done \r\n\t00001010: measure eye width done \r\n\t00001011: final l2u adjust done \r\n\t00001100: unused \r\n\t00001101: results check done \r\n\t00001110: eye opt all done \r\n\t00001111: unused \r\n\t00010000: start latch offset cal \r\n\t00010001: start latch offset cal 0 \r\n\t00010010: read latch offset cal 0 status \r\n\t00010011: check latch offset cal 0 status \r\n\t00010100: start latch offset cal 1 \r\n\t00010101: read latch offset cal 1 status \r\n\t00010110: check latch offset cal 1 status \r\n\t00010111: bist latch offset cal done \r\n\t00011000: unused \r\n\t00011001: unused \r\n\t00011010: unused \r\n\t00011011: unused \r\n\t00011100: unused \r\n\t00011101: unused \r\n\t00011110: unused \r\n\t00011111: unused \r\n\t00100000: start vref cal \r\n\t00100001: start vref servo \r\n\t00100010: read vref servo status \r\n\t00100011: check vref servo status \r\n\t00100100: start dcd adjust servo \r\n\t00100101: read dcd adjust servo status \r\n\t00100110: check dcd adjust servo status \r\n\t00100111: unused \r\n\t00101000: unused \r\n\t00101001: unused \r\n\t00101010: unused \r\n\t00101011: unused \r\n\t00101100: unused \r\n\t00101101: unused \r\n\t00101110: unused \r\n\t00101111: unused \r\n\t00110000: vga start-clear done flags \r\n\t00110001: vga measure ape/apo \r\n\t00110010: vga read ape/apo status \r\n\t00110011: vga check ape/apo status \r\n\t00110100: vga measure ane/ano \r\n\t00110101: vga read ane/ano status \r\n\t00110110: vga check ane/ano status \r\n\t00110111: vga measure ape dfe \r\n\t00111000: vga read ape dfe status \r\n\t00111001: vga check ape dfe status \r\n\t00111010: vga measure ane dfe \r\n\t00111011: vga read ane dfe status \r\n\t00111100: vga check ane dfe status \r\n\t00111101: vga measure apo dfe \r\n\t00111110: vga read apo dfe status \r\n\t00111111: vga check apo dfe status \r\n\t01000000: vga measure ano dfe \r\n\t01000001: vga read ano dfe status \r\n\t01000010: vga check ano dfe status \r\n\t01000011: vga measure amin no dfe \r\n\t01000100: vga read amin no dfe status \r\n\t01000101: vga check amin no dfe status \r\n\t01000110: vga measure amin dfe \r\n\t01000111: vga read amin dfe status \r\n\t01001000: vga check amin dfestatus \r\n\t01001001: vga clear lane address \r\n\t01001010: vga check lane valid \r\n\t01001011: vga read rx amp cntl \r\n\t01001100: vga read rx amp values \r\n\t01001101: vga read ape and apo \r\n\t01001110: vga read ane and ano \r\n\t01001111: vga read amine and amino \r\n\t01010000: vga check offset \r\n\t01010001: vga check amax \r\n\t01010010: vga write vga done control \r\n\t01010011: vga write all done status \r\n\t01010100: vga write vga adjust value \r\n\t01010101: vga check done \r\n\t01010110: unused \r\n\t01010111: unused \r\n\t01011000: unused \r\n\t01011001: unused \r\n\t01011010: unused \r\n\t01011011: unused \r\n\t01011100: unused \r\n\t01011101: unused \r\n\t01011110: unused \r\n\t01011111: unused \r\n\t01100000: unused \r\n\t01100001: unused \r\n\t01100010: unused \r\n\t01100011: unused \r\n\t01100100: unused \r\n\t01100101: unused \r\n\t01100110: unused \r\n\t01100111: unused \r\n\t01101000: unused \r\n\t01101001: unused \r\n\t01101010: unused \r\n\t01101011: unused \r\n\t01101100: unused \r\n\t01101101: unused \r\n\t01101110: unused \r\n\t01101111: unused \r\n\t01110000: ctle start \r\n\t01110001: ctle bump left \r\n\t01110010: ctle read bump left status \r\n\t01110011: ctle check bump left status \r\n\t01110100: ctle start servo \r\n\t01110101: ctle read servo status \r\n\t01110110: ctle check servo status \r\n\t01110111: ctle bump right \r\n\t01111000: ctle read bump right status \r\n\t01111001: ctle check bump rightstatus \r\n\t01111010: unused \r\n\t01111011: unused \r\n\t01111100: unused \r\n\t01111101: unused \r\n\t01111110: unused \r\n\t01111111: unused \r\n\t10000000: h1ap tweak start \r\n\t10000001: h1ap tweak run servo \r\n\t10000010: h1ap tweak read servo status \r\n\t10000011: h1ap tweak check servo status \r\n\t10000100: unused \r\n\t10000101: unused \r\n\t10000110: unused \r\n\t10000111: unused \r\n\t10001000: unused \r\n\t10001001: unused \r\n\t10001010: unused \r\n\t10001011: unused \r\n\t10001100: unused \r\n\t10001101: unused \r\n\t10001110: unused \r\n\t10001111: unused \r\n\t10010000: ddc start \r\n\t10010001: ddc run servo \r\n\t10010010: ddc read servo status \r\n\t10010011: ddc check servo status \r\n\t10010100: ddc check clear counter \r\n\t10010101: ddc check fly state \r\n\t10010110: ddc check lane \r\n\t10010111: ddc read  lane status \r\n\t10011000: ddc check lane status \r\n\t10011001: ddc write bad ddc \r\n\t10011010: ddc check if all done \r\n\t10011011: unused \r\n\t10011100: unused \r\n\t10011101: unused \r\n\t10011110: unused \r\n\t10011111: unused \r\n\t10100000: eye measure start \r\n\t10100001: eye measure start edge track \r\n\t10100010: eye measure read edge track status \r\n\t10100011: eye measure check edge track status \r\n\t10100100: eye measure fly state \r\n\t10100101: eye measure start eye track \r\n\t10100110: eye measure read eye track status \r\n\t10100111: eye measure check eye track status \r\n\t10101000: unused \r\n\t10101001: unused \r\n\t10101010: unused \r\n\t10101011: unused \r\n\t10101100: unused \r\n\t10101101: unused \r\n\t10101110: unused \r\n\t10101111: unused \r\n\t10110000: final l2u set sls checkers \r\n\t10110001: final l2u run err check timer \r\n\t10110010: final l2u dec l2u delay \r\n\t10110011: final l2u inc prbs \r\n\t10110100: final l2u inc l2u delay \r\n\t10110101: final l2u dec prbs \r\n\t10110110: unused \r\n\t10110111: final l2u run err check timer \r\n\t10111000: final l2u clear l2u counter \r\n\t10111001: final l2u check final delay \r\n\t10111010: final l2u inc l2u final delay \r\n\t10111011: final l2u dec prbs \r\n\t10111100: unused \r\n\t10111101: unused \r\n\t10111110: final l2u done \r\n\t10111111: final l2u fail \r\n\t11000000: final l2u wait for prev group status \r\n\t11000001: final l2u send status to next group \r\n\t11000010: final l2u wait for all group status \r\n\t11000011: unused \r\n\t11000100: unused \r\n\t11000101: unused \r\n\t11000110: unused \r\n\t11000111: unused \r\n\t11001000: unused \r\n\t11001001: unused \r\n\t11001010: unused \r\n\t11001011: unused \r\n\t11001100: unused \r\n\t11001101: unused \r\n\t11001110: final l2u max change send fail \r\n\t11001111: final l2u max change recv fail \r\n\t11010000: result check clear and start \r\n\t11010001: result check fly state \r\n\t11010010: result check for valid lane \r\n\t11010011: result check read eye width \r\n\t11010100: result check write bad width \r\n\t11010101: result check read amin values \r\n\t11010110: result check check height \r\n\t11010111: result check write bad height \r\n\t11011000: result check start ber servo \r\n\t11011001: result check read ber servo stat \r\n\t11011010: result check checkber status \r\n\t11011011: result check read ber count \r\n\t11011100: result checkcheck ber \r\n\t11011101: result check write bad ber \r\n\t11011110: result checkcheck if done \r\n\t11011111: result check fail \r\n\t11100000: completion start \r\n\t11100001: completion enable driving all \r\n\t11100010: completion drive eye opt done \r\n\t11100011: completion set up sls rcvr \r\n\t11100100: completion watch for sls nop \r\n\t11100101: completion drive sls nop ds \r\n\t11100110: completion wait for sls nop \r\n\t11100111: completion undrive lanes \r\n\t11101000: completion drive bogus sls nop \r\n\t11101001: completion wait non-sls data \r\n\t11101010: completion enable receive sls \r\n\t11101011: completion eye opt done \r\n\t11101100: unused \r\n\t11101101: unused \r\n\t11101110: unused \r\n\t11101111: unused \r\n\t11110000: latch offset fail \r\n\t11110001: vref fail \r\n\t11110010: vga measure ape/o fail \r\n\t11110011: vga measure ane/o fail \r\n\t11110100: vga measure ape dfe fail \r\n\t11110101: vga measure ane/o fail \r\n\t11110110: vga measure ane/o fail \r\n\t11110111: vga measure ano dfe fail \r\n\t11111000: vga measure amine fail \r\n\t11111001: vga measure amine fail \r\n\t11111010: ctle adjust fail \r\n\t11111011: h1ap tweak fail \r\n\t11111100: ddc fail \r\n\t11111101: measure eye fail \r\n\t11111110: dcd duty cycle fail \r\n\t11111111: unused \r\n\trjr
#define EDI_RX_RECAL_STATE                                 374,  8,  8 // EDI_RX_EO_RECAL_PG :: common edi/ei4 recalibration state machine\r\n\trjr
#define EDI_RX_WT_CLK_LANE_INVERTED                        353,  1,  1 // EDI_RX_WT_CLK_STATUS_PG :: clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted\r\n\trjr
#define EDI_RX_WT_CLK_LANE_BAD_CODE                        353,  2,  3 // EDI_RX_WT_CLK_STATUS_PG :: clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused\r\n\trjr
#define EDI_RX_WT_CLK_LANE_STATUS_ALIAS                    353,  1,  4 // EDI_RX_WT_CLK_STATUS_PG :: alias for rx_wt_clk_lane_inverted concatenated with rx_wt_clk_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at '0'--not swapped/inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--swapped or inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--swapped or inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--swapped or inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--swapped or inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_DYN_RECAL_OVERALL_TIMEOUT_SEL               354,  0,  3 // EDI_RX_DYN_RECAL_CONFIG_PG :: dynamic recalibration overall timeout selects\r\n\t000:(tap0) 27.30us - really small value for sim\r\n\t001:(tap1) 436.73us - smallest value for normal operation\r\n\t010:(tap2) 873.46us\r\n\t011:(tap3) 1.75ms\r\n\t100:(tap4) 3.49ms - recal should be around 2ms\r\n\t101:(tap5) 13.97ms\r\n\t110:(tap6) 55.90ms - largest value for normal operation\r\n\t111:(tap7) infinite- for debug purposes\r\n\tsmr
#define EDI_RX_DYN_RECAL_SUSPEND                           354,  3,  1 // EDI_RX_DYN_RECAL_CONFIG_PG :: suspend dynamic recalibration; otherwise starts automatically after link training\r\n\tsmr
#define EDI_RX_DYN_RECAL_IP_GCRMSG                         356,  0,  1 // EDI_RX_DYN_RECAL_GCRMSG_PG :: gcr message: rx dynamic recalibration in progress\r\n\tsmr
#define EDI_RX_DYN_RECAL_FAILED_GCRMSG                     356,  1,  1 // EDI_RX_DYN_RECAL_GCRMSG_PG :: gcr message: rx dynamic recalibration failed\r\n\tsmr
#define EDI_RX_DYN_RECAL_RIPPLE_GCRMSG                     356,  2,  1 // EDI_RX_DYN_RECAL_GCRMSG_PG :: gcr message: rx dynamic recalibration: reached end of bus...ripple back down to the beginning\r\n\tsmr
#define EDI_RX_DYN_RECAL_TIMEOUT_GCRMSG                    356,  3,  1 // EDI_RX_DYN_RECAL_GCRMSG_PG :: gcr message: rx dynamic recalibration: recal handshake timed out\r\n\tsmr
#define EDI_RX_EO_ENABLE_LATCH_OFFSET_CAL                  358,  0,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization latch offset adjustment enable\r\n\trjr
#define EDI_RX_EO_ENABLE_CTLE_CAL                          358,  1,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization ctle/peakin enable\r\n\trjr
#define EDI_RX_EO_ENABLE_VGA_CAL                           358,  2,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization vga gainand offset adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_DFE_H1_CAL                        358,  4,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization dfe h1  adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_H1AP_TWEAK                        358,  5,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization h1/an pr adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_DDC                               358,  6,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization dynamic data centering enable\r\n\trjr
#define EDI_RX_EO_ENABLE_FINAL_L2U_ADJ                     358,  8,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization final rx fifo load-to-unload delay adjustment enable\r\n\trjr
#define EDI_RX_EO_ENABLE_BER_TEST                          358,  9,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization bit error rate test enable\r\n\trjr
#define EDI_RX_EO_ENABLE_RESULT_CHECK                      358, 10,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization final results check enable\r\n\trjr
#define EDI_RX_EO_ENABLE_CTLE_EDGE_TRACK_ONLY              358, 11,  1 // EDI_RX_EO_STEP_CNTL_PG :: rx eye optimization ctle/peakin enable with edge tracking only\r\n\trjr
#define EDI_RX_RC_ENABLE_LATCH_OFFSET_CAL                  373,  0,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    latch offset adjustment enable\r\n\trjr
#define EDI_RX_RC_ENABLE_CTLE_CAL                          373,  1,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    ctle/peaking enable\r\n\trjr
#define EDI_RX_RC_ENABLE_VGA_CAL                           373,  2,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    vga gainand offset adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_DFE_H1_CAL                        373,  4,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    dfe h1  adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_H1AP_TWEAK                        373,  5,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    h1/an pr adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_DDC                               373,  6,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    dynamic data centering enable\r\n\trjr
#define EDI_RX_RC_ENABLE_BER_TEST                          373,  8,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    bit error rate test enable\r\n\trjr
#define EDI_RX_RC_ENABLE_RESULT_CHECK                      373,  9,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    final results check enable\r\n\trjr
#define EDI_RX_RC_ENABLE_CTLE_EDGE_TRACK_ONLY              373, 11,  1 // EDI_RX_RC_STEP_CNTL_PG :: rx recalibration    ctle/peaking enable with edge tracking only\r\n\trjr
#define EDI_RX_EO_LATCH_OFFSET_DONE                        359,  0,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization latch offset adjustment done\r\n\trjr
#define EDI_RX_EO_CTLE_DONE                                359,  1,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization ctle/peaking done\r\n\trjr
#define EDI_RX_EO_VGA_DONE                                 359,  2,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization vga gain/offset adjust done\r\n\trjr
#define EDI_RX_EO_H1AP_TWEAK_DONE                          359,  5,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization h1/an pr adjust done\r\n\trjr
#define EDI_RX_EO_DDC_DONE                                 359,  6,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization dynamic data centering done\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_ADJ_DONE                       359,  8,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization final rx fifo load-to-unload adjust done\r\n\trjr
#define EDI_RX_EO_DFE_FLAG                                 359,  9,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization dfe mode flag\r\n\trjr
#define EDI_RX_EO_BER_TEST_DONE                            359, 10,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization bit error rate test done\r\n\trjr
#define EDI_RX_EO_RESULT_CHECK_DONE                        359, 11,  1 // EDI_RX_EO_STEP_STAT_PG :: rx eye optimization eye width/heighter check done\r\n\trjr
#define EDI_RX_EO_LATCH_OFFSET_FAILED                      360,  0,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization latch offset adjustment  failed\r\n\trjr
#define EDI_RX_EO_CTLE_FAILED                              360,  1,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization ctle/peaking  failed\r\n\trjr
#define EDI_RX_EO_VGA_FAILED                               360,  2,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization vga gain/offset adjust  failed\r\n\trjr
#define EDI_RX_EO_DFE_H1_FAILED                            360,  4,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization dfe h1  adjust failed\r\n\trjr
#define EDI_RX_EO_H1AP_TWEAK_FAILED                        360,  5,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization h1/an pr adjust failed\r\n\trjr
#define EDI_RX_EO_DDC_FAILED                               360,  6,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization dynamic data centering failed\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_ADJ_FAILED                     360,  8,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization final rx fifo load-to-unload adjust  failed\r\n\trjr
#define EDI_RX_EO_RESULT_CHECK_FAILED                      360,  9,  1 // EDI_RX_EO_STEP_FAIL_PG :: rx eye optimization final result checking failed\r\n\trjr
#define EDI_RX_EO_CONVERGED_COUNT                          367,  0,  4 // EDI_RX_EO_CONVERGENCE_PG :: rx eye optimization convergence counter current value\r\n\trjr
#define EDI_RX_EO_CONVERGED_END_COUNT                      367,  4,  4 // EDI_RX_EO_CONVERGENCE_PG :: rx eye optimization covergence counter end value\r\n\trjr
#define EDI_RX_AP_EVEN_WORK                                361,  0,  8 // EDI_RX_AP_PG :: rx ap even working register\r\n\trjr
#define EDI_RX_AP_ODD_WORK                                 361,  8,  8 // EDI_RX_AP_PG :: rx ap odd  working register\r\n\trjr
#define EDI_RX_AN_EVEN_WORK                                362,  0,  8 // EDI_RX_AN_PG :: rx an even working register\r\n\trjr
#define EDI_RX_AN_ODD_WORK                                 362,  8,  8 // EDI_RX_AN_PG :: rx an odd  working register\r\n\trjr
#define EDI_RX_AMIN_EVEN_WORK                              363,  0,  8 // EDI_RX_AMIN_PG :: rx amin even working register\r\n\trjr
#define EDI_RX_AMIN_ODD_WORK                               363,  8,  8 // EDI_RX_AMIN_PG :: rx amin odd  working register\r\n\trjr
#define EDI_RX_AMAX_HIGH                                   364,  0,  8 // EDI_RX_AMAX_PG :: rx amax high limit default 125\r\n\trjr
#define EDI_RX_AMAX_LOW                                    364,  8,  8 // EDI_RX_AMAX_PG :: rx amax low limit  default 75\r\n\trjr
#define EDI_RX_AMP_PEAK_WORK                               365,  0,  4 // EDI_RX_AMP_VAL_PG :: rx amp peak working register\r\n\trjr
#define EDI_RX_AMP_GAIN_WORK                               365,  4,  4 // EDI_RX_AMP_VAL_PG :: rx amp gain working register\r\n\trjr
#define EDI_RX_AMP_OFFSET_WORK                             365, 10,  6 // EDI_RX_AMP_VAL_PG :: rx amp offset working register\r\n\trjr
#define EDI_RX_AMP_OFFSET_MAX                              366,  0,  6 // EDI_RX_AMP_OFFSET_PG :: rx amp maximum allowable offset\r\n\trjr
#define EDI_RX_AMP_OFFSET_MIN                              366,  6,  6 // EDI_RX_AMP_OFFSET_PG :: rx amp minimum allowable offset\r\n\trjr
#define EDI_RX_SERVO_BER_COUNT_WORK                        375,  0, 12 // EDI_RX_SERVO_BER_COUNT_PG :: rx servo-based bit error rate count working register\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_DLY_SEQ_GCRMSG                 347,  0,  2 // EDI_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: rx final load to unload delay gcr messages\r\n\t00:(fl2uprevchg) indicate prior group calculated max load to unload change.\r\n\t01:(fl2uallchg) indicate all groups have calculated max load to unload change.\r\n\t10:(unused) unused.\r\n\t11:(fl2unomsg) no message.\r\n\tmbs
#define EDI_RX_EO_FINAL_L2U_DLY_MAXCHG_GCRMSG              347,  2,  6 // EDI_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: max change in miniumum load to unload delay.\r\n\tmbs
#define EDI_RX_EO_FINAL_L2U_DLY_CHG                        347, 10,  6 // EDI_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: local change in miniumum load to unload delay.\r\n\tmbs
#define EDI_RX_SLS_RCVY_DISABLE                            368,  0,  1 // EDI_RX_SLS_RCVY_PG :: disable sls recovery\r\n\tsmr
#define EDI_RX_SLS_RCVY_STATE                              368,  3,  5 // EDI_RX_SLS_RCVY_PG :: sls recovery state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_rcvy_state\r\n\tsmr
#define EDI_RX_SLS_RCVY_REQ_GCRMSG                         369,  0,  1 // EDI_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair req has been issued.\r\n\tsmr
#define EDI_RX_SLS_RCVY_IP_GCRMSG                          369,  1,  1 // EDI_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair is in progress.\r\n\tsmr
#define EDI_RX_SLS_RCVY_DONE_GCRMSG                        369,  2,  1 // EDI_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair has been issued and is now done.\r\n\tsmr
#define EDI_RX_TX_BAD_LANE_CNTR_GCRMSG                     370,  0,  2 // EDI_RX_TX_LANE_INFO_GCRMSG_PG :: gcr message: rx side tx bad lane counter\r\n\tsmr
#define EDI_RX_DIS_SYND_TALLYING_GCRMSG                    371,  0,  1 // EDI_RX_ERR_TALLYING_GCRMSG_PG :: gcr message: internal logic has disabled the syndrome tallying feature for reasons such as the current rx sls lane is in the process of moving.\r\n\tsmr
#define EDI_RX_TRC_MODE                                    372,  0,  4 // EDI_RX_TRACE_PG :: rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd\r\n\tsmr
#define EDI_RX_TRC_GRP                                     372,  6,  6 // EDI_RX_TRACE_PG :: rx clock group to be traced\r\n\t111111 will trace whichever clk group currently contains the rx sls lane\r\n\tsmr
#define EDI_RX_DYN_RPR_BAD_LANE_VALID_DEBUG                377,  0,  1 // EDI_RX_DYN_RPR_DEBUG_PG :: for testfloor/debug purposes, the specified encoded bad data lane will be tallied as having one cycle of a valid crc/ecc error (this is a write-only pulse register)\r\n\tsmr
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_DEBUG             377,  1,  7 // EDI_RX_DYN_RPR_DEBUG_PG :: for testfloor/debug purposes, specify the encoded bad data lane to report to the dynamic repair tally logic\r\n\tsmr
#define EDI_RX_BAD_BUS_ERR_CNTR                            377,  9,  7 // EDI_RX_DYN_RPR_DEBUG_PG :: bad bus error counter (aka counter2)\r\n\tsmr
#define EDI_RX_BAD_BUS_LANE_ERR_CNTR_DIS_CLR               305,  0,  1 // EDI_RX_DYN_RPR_DEBUG2_PG :: disable clearing of the bad bus lane error counter (aka counter1) when the next crc/ecc error comes in on a new lane\r\n\tsmr
#define EDI_RX_BAD_BUS_LANE_ERR_CNTR                       305,  1,  7 // EDI_RX_DYN_RPR_DEBUG2_PG :: bad bus lane error counter (aka counter1)\r\n\tsmr
#define EDI_RX_LAST_BAD_BUS_LANE                           305,  9,  7 // EDI_RX_DYN_RPR_DEBUG2_PG :: last bad bus lane (bus lane causing the last crc or ecc error)\r\n\tsmr
#define EDI_RX_DYN_RPR_BAD_BUS_MAX                         378,  0,  7 // EDI_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: max number of times crc or ecc errors can be found on the bus (not included in the bad lane cntr1 tally) before setting a fir error\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_CNTR2_DURATION                  378,  7,  4 // EDI_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: duration the bad bus cntr2 error counter can run before being divided by 2 (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EDI_RX_DYN_RPR_CLR_ERR_CNTR2                       378, 11,  1 // EDI_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: firmware-based clear of bus error counter2 register\r\n\tsmr
#define EDI_RX_DYN_RPR_DISABLE2                            378, 12,  1 // EDI_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: when set, disables the repair from the dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2), however leaves the counters running\r\n\tsmr
#define EDI_RX_MIN_EYE_WIDTH                               379,  2,  6 // EDI_RX_RESULT_CHK_PG :: minimum acceptable eye width used during init or recal results checking--edi or ei4\r\n\tdmb
#define EDI_RX_MIN_EYE_HEIGHT                              379,  8,  8 // EDI_RX_RESULT_CHK_PG :: minimum acceptable eye height used during init or recal results checking--edi only\r\n\tdmb
#define EDI_RX_MAX_BER_CHECK_COUNT                         380,  8,  8 // EDI_RX_BER_CHK_PG :: maximum acceptable number of bit errors allowable after recal. it is used in both edi and ei-4 for initialization, but not used during ei4 recal. it is used during recal checks on edi.\r\n\trjr
#define EDI_RX_STOP_STATE_ENABLE                           296,  0,  1 // EDI_RX_STOP_CNTL_STAT_PG :: enable state machine stop of address\r\n\trjr
#define EDI_RX_STATE_STOPPED                               296,  1,  1 // EDI_RX_STOP_CNTL_STAT_PG :: state machines stopped\r\n\trjr
#define EDI_RX_RESUME_FROM_STOP                            296,  2,  1 // EDI_RX_STOP_CNTL_STAT_PG :: resume stopped state machines and /or counters\r\n\trjr
#define EDI_RX_STOP_ADDR_MSB                               296,  8,  4 // EDI_RX_STOP_CNTL_STAT_PG :: stop address most-significant four bits 0 to 3\r\n\trjr
#define EDI_RX_STOP_MASK_MSB                               296, 12,  4 // EDI_RX_STOP_CNTL_STAT_PG :: stop mask    most-significant four bits 0 to 3\r\n\trjr
#define EDI_RX_STOP_ADDR_LSB                               298,  0, 16 // EDI_RX_STOP_ADDR_LSB_PG :: stop address least-significant 16 bits 4 to 19\r\n\trjr
#define EDI_RX_STOP_MASK_LSB                               299,  0, 16 // EDI_RX_STOP_MASK_LSB_PG :: stop mask    least-significant 16 bits 4 to 19\r\n\trjr
#define EDI_RX_SLV_SHDW_DONE_FIN_GCRMSG                    381,  0,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_done\r\n\tsmr
#define EDI_RX_SLV_SHDW_NOP_FIN_GCRMSG                     381,  1,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_SHDW_RPR_DONE_FIN_GCRMSG                381,  2,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_rpr_done\r\n\tsmr
#define EDI_RX_SLV_SHDW_RPR_NOP_FIN_GCRMSG                 381,  3,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_DONE_FIN_GCRMSG                  381,  4,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_done\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_NOP_FIN_GCRMSG                   381,  5,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_RPR_DONE_FIN_GCRMSG              381,  6,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_rpr_done\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_RPR_NOP_FIN_GCRMSG               381,  7,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_DONE_NOP_FIN_GCRMSG               381,  8,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal done; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_FAIL_NOP_FIN_GCRMSG               381,  9,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal fail; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_FRESULTS_FIN_GCRMSG               381, 11,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal fail results; need to finish slave recal handshake starting with waiting for results\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_ACK_FIN_GCRMSG              381, 12,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_MNOP_FIN_GCRMSG             381, 13,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_SNOP_FIN_GCRMSG             381, 14,  1 // EDI_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_SHFT_AMT          313,  0,  7 // EDI_RX_DYN_RPR_MODE_PG :: crc/ecc dynamic repair: programmable register value that is subtracted from the enc_bad_data_lane value provided from the crc/ecc check logic (except for the all 1s clear pattern).  (e.g. should be set to 0x07 for the zmci logic to compensate for disabled lanes, but otherwise generally 0x00.  note: always check figtree for current settings, though, and not this comment!).\r\n\tsmr
#define EDI_RX_REDUCED_SCRAMBLE_MODE                       382,  0,  2 // EDI_RX_MODE1_PP :: sets reduced density of scramble pattern. this must be set consistent with tx_reduced_scramble_mode.  \r\n\t00:(disable_0) disable reduced density \r\n\t01:(disable_1) disable reduced density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div4) enable div4 reduced density (div4 is edi only) \r\n\tmbs
#define EDI_RX_PRBS_SCRAMBLE_MODE                          382,  2,  2 // EDI_RX_MODE1_PP :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDI_RX_ACT_CHECK_TIMEOUT_SEL                       382,  4,  3 // EDI_RX_MODE1_PP :: sets activity check timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(128ui) 128 ui \r\n\t010:(256ui) 256 ui \r\n\t011:(512ui) 512 ui \r\n\t100:(1024ui) 1024 ui \r\n\t101:(2048ui) 2048 ui \r\n\t110:(4096ui) 4096 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_BLOCK_LOCK_TIMEOUT_SEL                      382,  7,  3 // EDI_RX_MODE1_PP :: sets block lock timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(1024ui) 1024 ui \r\n\t010:(2048ui) 2048 ui \r\n\t011:(4096ui) 4096 ui \r\n\t100:(8192ui) 8192 ui \r\n\t101:(16384ui) 16384 ui \r\n\t110:(32768ui) 32768 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_BIT_LOCK_TIMEOUT_SEL                        382, 10,  3 // EDI_RX_MODE1_PP :: sets bit lock/edge detect timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(512ui) 512 ui \r\n\t010:(1024ui) 1024 ui \r\n\t011:(2048ui) 2048 ui \r\n\t100:(4096ui) 4096 ui \r\n\t101:(8192ui) 8192 ui \r\n\t110:(16384ui) 16384 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_ENABLE_DFE_V1                               382, 13,  1 // EDI_RX_MODE1_PP :: rx cal sm chicken switch. when this bit is set we will revert dfe back to the v1 implememntation\r\n\tcpg
#define EDI_RX_AMIN_ALL                                    382, 14,  1 // EDI_RX_MODE1_PP :: rx cal sm, a chicken switch of sorts. when this bit is a one we not only use the sp1 latch in generating amin but also sp0. this is helpfull in very short channels which tend to be over peaked.\r\n\tcpg
#define EDI_RX_PP_TRC_EN                                   396,  0,  1 // EDI_RX_MODE2_PP :: per pack rx trace mode enable \r\n\t0:(disabled) per pack trace mode is disabled \r\n\t1:(enabled) per pack trace mode is enabled \r\n\tsmr
#define EDI_RX_PP_TRC_MODE                                 396,  1,  3 // EDI_RX_MODE2_PP :: per pack rx trace mode\r\n\t000:(tap0) tbd\r\n\t001:(tap1) tbd\r\n\t010:(tap2) tbd\r\n\t011:(tap3) tbd\r\n\t100:(tap4) tbd\r\n\t101:(tap5) tbd\r\n\t110:(tap6) tbd\r\n\t111:(tap7) tbd\r\n\tsmr
#define EDI_RX_BIST_JITTER_PULSE_SEL                       396,  4,  2 // EDI_RX_MODE2_PP :: rx bist jitter select\r\n\tthis setting induces artificial jitter into the data of the prbs generator during bist to ensure the deadzone between the two eyes of the bist pattern is at least two pr steps wide.\r\n\t00:(steps4) four jitter steps\r\n\t01: (steps2) two jitter steps\r\n\t10: (steps8) eight jitter steps\r\n\t11: (steps0) no jitter\r\n\tjgr
#define EDI_RX_BIST_MIN_EYE_WIDTH                          396,  6,  6 // EDI_RX_MODE2_PP :: rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass phybist.\r\n\tjgr
#define EDI_RX_WT_PATTERN_LENGTH                           396, 14,  2 // EDI_RX_MODE2_PP :: rx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EDI_RX_BIST_STEP_INTERVAL_EN                       399,  0,  1 // EDI_RX_MODE3_PP :: \r\n\tjgr
#define EDI_RX_BIST_STEP_INTERVAL                          399,  1,  2 // EDI_RX_MODE3_PP :: \r\n\tjgr
#define EDI_RX_BIST_PHASEROT_OFFSET_EN                     399,  3,  1 // EDI_RX_MODE3_PP :: \r\n\tjgr
#define EDI_RX_BIST_PHASEROT_OFFSET                        399,  4,  2 // EDI_RX_MODE3_PP :: \r\n\tjgr
#define EDI_RX_BIST_BUFFER_SEL                             399,  6,  3 // EDI_RX_MODE3_PP :: \r\n\tjgr
#define EDI_RX_SERVO_TIMEOUT_SEL_A                         387,  0,  4 // EDI_RX_SERVO_TO1_PP :: rx servo operation timeout a used to time latch offset calibration.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_B                         387,  4,  4 // EDI_RX_SERVO_TO1_PP :: rx servo operation timeout b used to time ctle/peaking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_C                         387,  8,  4 // EDI_RX_SERVO_TO1_PP :: rx servo operation timeout c used to time vref adjustment.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_D                         387, 12,  4 // EDI_RX_SERVO_TO1_PP :: rx servo operation timeout d used to time block locking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_E                         388,  0,  4 // EDI_RX_SERVO_TO2_PP :: rx servo operation timeout e used to time edge tracking .\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_F                         388,  4,  4 // EDI_RX_SERVO_TO2_PP :: rx servo operation timeout f used to time eye tracking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_G                         388,  8,  4 // EDI_RX_SERVO_TO2_PP :: rx servo operation timeout g used to time ber testing.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_H                         388, 12,  4 // EDI_RX_SERVO_TO2_PP :: rx servo operation timeout h used to time edi dynamic data centering and ei-4 clock duty cycle distortion adjust.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_I                         389,  0,  4 // EDI_RX_SERVO_TO3_PP :: rx servo operation timeout i used to time ap and an measurements without dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_J                         389,  4,  4 // EDI_RX_SERVO_TO3_PP :: rx servo operation timeout j used to time ap and an measurements with dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_K                         389,  8,  4 // EDI_RX_SERVO_TO3_PP :: rx servo operation timeout k used to time amin measurements with or without dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_L                         389, 12,  4 // EDI_RX_SERVO_TO3_PP :: rx servo operation timeout l used to time phase rotator bump commands.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_A                         393,  0,  4 // EDI_RX_RECAL_TO1_PP :: rx recal servo operation timeout a used to time latch offset calibration during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_B                         393,  4,  4 // EDI_RX_RECAL_TO1_PP :: rx recal servo operation timeout b used to time ctle measurements during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_E                         394,  0,  4 // EDI_RX_RECAL_TO2_PP :: rx recal servo operation timeout e used to time edge tracking during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_G                         394,  8,  4 // EDI_RX_RECAL_TO2_PP :: rx recal servo operation timeout g used to time ber testing during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_H                         394, 12,  4 // EDI_RX_RECAL_TO2_PP :: rx recal servo operation timeout h used to time dynamic data centering during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_I                         395,  0,  4 // EDI_RX_RECAL_TO3_PP :: rx recal servo operation timeout i used to time ap and an measurements without dfe during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_J                         395,  4,  4 // EDI_RX_RECAL_TO3_PP :: rx recal servo operation timeout j used to time ap and an measurements with dfe during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_K                         395,  8,  4 // EDI_RX_RECAL_TO3_PP :: rx recal servo operation timeout k used to time amin measurements during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_L                         395, 12,  4 // EDI_RX_RECAL_TO3_PP :: rx recal servo operation timeout l used to time bump commands during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_PRBS_CHECK_SYNC                             383,  1,  1 // EDI_RX_CNTL_FAST_PP :: enables checking for the 12 ui scramble sync pattern. \r\n\t0:(disabled) disable checking (forces prbs_synced_b to 1)\r\n\t1:(enabled) enable checking (prbs_synced_b can go to 0)\r\n\trjr
#define EDI_RX_ENABLE_REDUCED_SCRAMBLE                     383,  2,  1 // EDI_RX_CNTL_FAST_PP :: enables reduced density of scramble pattern. \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the rx_reduced_scramble_mode setting\r\n\trjr
#define EDI_RX_PRBS_INC                                    383,  3,  1 // EDI_RX_CNTL_FAST_PP :: shift the prbs pattern forward in time by one extra local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EDI_RX_PRBS_DEC                                    383,  4,  1 // EDI_RX_CNTL_FAST_PP :: shift the prbs pattern back in time by holding it one local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EDI_RX_DYN_RECAL_INTERVAL_TIMEOUT_SEL              384,  1,  3 // EDI_RX_DYN_RECAL_TIMEOUTS_PP :: rx dynamic recalibration interval timeout selects\r\n\t000:(tap0) 1024ui or 106.5ns\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_RX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL            384,  4,  2 // EDI_RX_DYN_RECAL_TIMEOUTS_PP :: rx dynamic recalibration status reporting timeout selects\r\n\tthis value must be longer than the sls_cntr_tap_sel!\r\n\t00:(tap0) 512ui or 53.2ns\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\tsmr
#define EDI_RX_PEAK_CFG                                    390,  0,  2 // EDI_RX_DFE_CONFIG_PP :: this register controls the servo inc/dec settings for adjusting peaking. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the peak setting. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\thss recommendation is to set this filter to 256. this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_AMIN_CFG                                    390,  2,  3 // EDI_RX_DFE_CONFIG_PP :: this register controls the servo inc setting for measuring amin. amin is the level of the inner eye. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the amin register value. unlike other servo operations, amin has a fixed filter setting for the decrement. any time we get a servo decrement we will decrement by 4096 causing an immediate underflow. so for amin all we can adjust is the speed we increment, not decrement. that is just the way amin works.\r\n\thss recommendation is to set this filter to 1024. this will be the lab initial setting and we have the capability to decrease this by one step, halving the value.\r\n\tcpg
#define EDI_RX_ANAP_CFG                                    390,  5,  2 // EDI_RX_DFE_CONFIG_PP :: this register controls the servo inc/dec settings for measuring an and ap. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the value of an or ap.. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\thss recommendation is to set this filter to 32. this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_H1_CFG                                      390,  7,  2 // EDI_RX_DFE_CONFIG_PP :: this register controls the servo inc/dec settings for adjusting the h1 coefficients. the details of this adjustment is found later. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the value of the h1 cooeficient. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\tthe h1 filter setting is done a little different than the others in that it is time into the adjustment of anap. in this we increasing or decreasing this register will have an effect in the filtering that is independent of anap while adjusting the anap_cfg will change the h1 filter setting in unison.\r\n\thss recommendation is to set this filter to 256. this makes it 8 times the anap value. this is necessary as the h1 coefficients must be adjusted slower than anap to keep it from chasing the ap values this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_H1AP_CFG                                    390,  9,  3 // EDI_RX_DFE_CONFIG_PP :: this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. if we are under the limit set by this register we are allowed to encrease the h1 servo value. this could then eventually result in an increase in the h1 cooeficient. if this ratio is greater than the limits set by this register, the servo will be decremented and this will continue to happen as long as the ratio remains too high. this will then eventually cause a decrease in the h1 cooeficient. as long as we are below the limit it is business as usual and when we are above the limit we will react slowly to get us back within the limits.\r\n\thss recommendation is to set this ratio to 0.5 with the ability to go to 0.6 and 0.7. implementation was done to allow adjustment in steps of 1/16 for minimum logic taking us from 0.5 up to 0.6875. register settings 100 through 111 were added in case we really wanted to restrict the ratio because of some unknown thing. encode 100 should be 0.25 but a typo in dd1 resulted in the ratio of 0.125.\r\n\tcpg
#define EDI_RX_DFE_CA_CFG                                  390, 12,  2 // EDI_RX_DFE_CONFIG_PP :: rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 10\r\n\t01 - 12\r\n\t10 - 14\r\n\t11 - 16\r\n\t hss has determined that the recommended k value be 14 but our ams simulations look more like 10. lab testing will be required to determine the proper value of k.\r\n\tcpg
#define EDI_RX_SPMUX_CFG                                   390, 14,  2 // EDI_RX_DFE_CONFIG_PP :: this register is used to take control of the spec mux and select which of the two speculation latches you wish to use. this would only be used for charactorization when we want complete control. bit 0 is set to a 0b1 to override spec mux control and bit 1 is used to select the 1 or 0 latch\r\n\tcpg
#define EDI_RX_INIT_TMR_CFG                                391,  0,  3 // EDI_RX_DFE_TIMERS_PP :: this register controls the time we will take to do the initial block lock. this is the number of cycles we wait for the phase rotator to align on the edge before we check for block lock. during the block lock phase we have a 2 up 2 down square wave coming in to lock on. this should be a fairly easy target. keep in mind that since we are using nothing but data to represent both data and edge we could need to move as much as 32 phase rotator steps to find the edge. while way off the edge we should only be limited by the filter setting. the phase rotator filter will normally be set to 16 meaning it will take at least 512 cycles to slew to the edge. as we approach the edge it may take longer per step. in retrospect we maybe should have spread this across a wider range. something we may wish to do for dd2.\r\n\tto be on the safe side i suggest the max value for bringup. it only takes 2.346 us at the longest setting. \r\n\tcpg
#define EDI_RX_BER_CFG                                     391,  3,  3 // EDI_RX_DFE_TIMERS_PP :: this register controls the bit error rate threshold used for ddc. during ddc we quickly move out of the eye and then slowly move back till we are back into the eye. this is the bit error rate threshold used to determine we are back in the eye. to be on the safe side we have to figure on 4 x this time as the time needed to run ddc. hss recommends that we run ddc looking for a 1e-6 bit error rate as our criteria. this could take as much as 477us in a 9.6gbit link. this is way too long so we must pick a shorter time.\r\n\tthe following table shows the bit error rate for the settings. recommended setting is 0b100 and we can evaluate in the lab. please note that the setting 0b110 is slightly off. it should have been 333328 but is off 6.8% due to a typo. this is no issue.\r\n\treg setting   error free bits\r\n\t000     336\r\n\t001  1000\r\n\t010 3328\r\n\t011 10000\r\n\t100     33328\r\n\t101     100000\r\n\t110    355856\r\n\t111    1000000\r\n\tcpg
#define EDI_RX_FIFO_DLY_CFG                                391,  6,  2 // EDI_RX_DFE_TIMERS_PP :: this register controls how long we wait after every change to the phase rotator before we begin using the data again. this is to allow the data time to flow throught the receive fifo so we are looking at new data. this is the number of c8 cycles we wait giving us the ability to wait 48 to 72 ui. if we miss it a bit, no problem, as filtering will still hide most of the edge effects when shifting the rotator. therefore i suggest we set it to the fastest setting until we prove we need more time.\r\n\tcpg
#define EDI_RX_DDC_CFG                                     391,  8,  2 // EDI_RX_DFE_TIMERS_PP :: this register controls how long we wait looking for errors as we march further into the edge. this is using the same timer as the fifo delay so you really should subtract that out if you want to see how long we are really waiting. complete details in the ddc section but during this phase we are marching further to the edge if we do not find an error in a rather short period of time.\r\n\tcpg
#define EDI_RX_DAC_BO_CFG                                  391, 10,  3 // EDI_RX_DFE_TIMERS_PP :: this register controls the time of the dac black out time. when the dac code is changed it takes some time for the dac to reach its new value. even though we usually only make single step adjustments to the dac we have to allow time for the dac output to settle. this timer blocks all usage of data until the dac has settled. current estimate for dac settling time is aobut 75 ns. this timer is not exact. we are using higher order bits of a free running timer and we do not know where the counter is at the time the data switches. as an example, if the timer was about to overflow when the dac code changed it may only take a cycle or two for us to get another switch. the timer is counting the number of times the low order three bits of a free running counter are 0b111 so the timer period is 0 to 64 ui per count\r\n\trecommending a starting value of 100 and we will characterize from there.\r\n\tcpg
#define EDI_RX_PROT_CFG                                    391, 13,  2 // EDI_RX_DFE_TIMERS_PP :: this register controls the filtering we do when searching for the edge of the data window and also when tracking the edge during ctle. due to a typo dd1 does not have the intended values. although very close in the range we use this should still be changed to be consistant with all other designs. the normal recommended value is a shift 16 selected by a register setting of 0b10. it is very unlikely that any amount of hardware testing would be able to tell the difference between a shift 15 and a shift 16.\r\n\tthe normal useful settings are 8, 16, and 32. 4 should only be used in sumulation as it is not as stable as the others. we do block the use of the data for a period of time after moving the phase rotator to ensure we are only using the correct data for our next move. this adds stability but there is really no good reason to ever use 4. \r\n\tcpg
#define EDI_RX_RESET_CFG_HLD                               392,  0, 16 // EDI_RX_RESET_CFG_PP :: reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via rx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EDI_RX_SCOPE_CONTROL                               398,  0,  2 // EDI_RX_SCOPE_CNTL_PP :: bit 0 odd/even (1 is odd) bit 1 speculation latch 0=0 1=1.\r\n\tcpg
#define EDI_RX_BUMP_SCOPE                                  398,  2,  1 // EDI_RX_SCOPE_CNTL_PP :: when written to a 1 it will bump the scope sync counter one notch.\r\n\tcpg
#define EDI_RX_H1_CLKADJ_CFG                               398,  3,  3 // EDI_RX_SCOPE_CNTL_PP :: this is the config bits for the h1 ap clock adjust logic\r\n\tcpg
#define EDI_RX_BIST_EN                                     397,  0,  1 // EDI_RX_BIST_GCRMSG_PP :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.\r\n\tjgr
#define EDI_RX_BER_EN                                      385,  0,  1 // EDI_RX_BER_CNTL_PP :: per-pack (pp) diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.\r\n\tpmt
#define EDI_RX_BER_COUNT_CLR                               385,  1,  1 // EDI_RX_BER_CNTL_PP :: pp diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EDI_RX_BER_TIMER_CLR                               385,  2,  1 // EDI_RX_BER_CNTL_PP :: pp diag ber timer clear pulse. when written to a 1 the per-pack timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EDI_RX_BER_TIMER_FREEZE_EN                         386,  0,  1 // EDI_RX_BER_MODE_PP :: per-pack (pp) diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the per-pack timer is frozen when any lane error count saturates in that pack.\r\n\tpmt
#define EDI_RX_BER_COUNT_FREEZE_EN                         386,  1,  1 // EDI_RX_BER_MODE_PP :: pp diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.\r\n\tpmt
#define EDI_RX_BER_COUNT_SEL                               386,  3,  3 // EDI_RX_BER_MODE_PP :: pp diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. \r\n\t000:(1) 1\r\n\t001:(2) 2\r\n\t010:(4) 4\r\n\t011:(8) 8\r\n\t100:(16) 16\r\n\t101:(32) 32\r\n\t110:(64) 64\r\n\t111:(128) 128\r\n\tpmt
#define EDI_RX_BER_TIMER_SEL                               386,  6,  3 // EDI_RX_BER_MODE_PP :: pp diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. \r\n\t000:(2tothe39th) 2^39\r\n\t001:(2tothe35th) 2^35\r\n\t010:(2tothe31st) 2^31\r\n\t011:(2tothe27th) 2^27\r\n\t100:(2tothe25th) 2^25\r\n\t101:(2tothe21th) 2^21\r\n\t110:(2tothe17th) 2^17\r\n\t111:(2tothe13th) 2^13\r\n\tpmt
#define EDI_RX_BER_CLR_COUNT_ON_READ_EN                    386,  9,  1 // EDI_RX_BER_MODE_PP :: pp diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.\r\n\tpmt
#define EDI_RX_BER_CLR_TIMER_ON_READ_EN                    386, 10,  1 // EDI_RX_BER_MODE_PP :: pp diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes per-pack timer when it is read from any lane in the pack.\r\n\tpmt
#define EDI_RX_FIR_MSG                                     404,  0,  8 // EDI_RX_FIR_MSG_PB :: dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.\r\n\tpmt
#define EDI_RX_PB_CLR_PAR_ERRS                             400, 14,  1 // EDI_RX_FIR_RESET_PB :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.\r\n\tpmt
#define EDI_RX_PB_FIR_RESET                                400, 15,  1 // EDI_RX_FIR_RESET_PB :: fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_FULL_REG                        401,  0, 10 // EDI_RX_FIR_PB :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS                                 401,  0, 10 // EDI_RX_FIR_PB :: a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_PB_REGS                          401,  0,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF0                        401,  1,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF1                        401,  2,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF2                        401,  3,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM0                      401,  4,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM1                      401,  5,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM2                      401,  6,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM0                    401,  7,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM1                    401,  8,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM2                    401,  9,  1 // EDI_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_MASK_FULL_REG                   402,  0, 10 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for rx_fir_pb errors.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_MASK                            402,  0, 10 // EDI_RX_FIR_MASK_PB :: fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_PB_REGS                     402,  0,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF0                   402,  1,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF1                   402,  2,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF2                   402,  3,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                 402,  4,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                 402,  5,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                 402,  6,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0               402,  7,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1               402,  8,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2               402,  9,  1 // EDI_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_INJ_FULL_REG                    403,  0, 10 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_INJ                             403,  0, 10 // EDI_RX_FIR_ERROR_INJECT_PB :: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_PB_REGS                      403,  0,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF0                    403,  1,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF1                    403,  2,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF2                    403,  3,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                  403,  4,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                  403,  5,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                  403,  6,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0                403,  7,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1                403,  8,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2                403,  9,  1 // EDI_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_GCR_TEST_MODE                                  405,  0,  1 // EDI_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.\r\n\tpmt
#define EDI_ENABLE_GCR_OFL_BUFF                            405,  1,  1 // EDI_SCOM_MODE_PB :: enables 2nd gcr overflow buffer, one is used by default.\r\n\tdmb
#define EDI_IORESET_HARD_BUS0                              405,  2,  6 // EDI_SCOM_MODE_PB :: io hard reset per-bus and gcr reset\r\n\tenables a hard reset on bus 0 thru 5 (this is application dependent and bus 1-5 may not be present). a gcr reset affects all busses since any of them may be corrupted.\r\n\t000000:(functional) functional (default)\r\n\t100000:(reset0) reset bus 0\r\n\t010000:(reset1) reset bus 1\r\n\t001000:(reset2) reset bus 2\r\n\t000100:(reset3) reset bus 3\r\n\t000010:(reset4) reset bus 4\r\n\t000001:(reset5) reset bus 5\r\n\t111111:(resetgcr) reset all local busses and perform a gcr reset.\r\n\tjfg
#define EDI_GCR_HANG_DET_SEL                               405,  8,  3 // EDI_SCOM_MODE_PB :: gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 31 cycles\r\n\t010: 63 cycles\r\n\t011: 127 cycles\r\n\t100: 255 cycles\r\n\t101: 511 cycles\r\n\t110: 1023 cycles\r\n\t111: 2047 cycles.\r\n\tdmb
#define EDI_GCR_BUFFER_ENABLED                             405, 11,  1 // EDI_SCOM_MODE_PB :: flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.\r\n\tdmb
#define EDI_GCR_HANG_ERROR_MASK                            405, 12,  1 // EDI_SCOM_MODE_PB :: mask for gcr hang error when 2nd buffer is enabled.\r\n\tdmb
#define EDI_GCR_HANG_ERROR_INJ                             405, 13,  1 // EDI_SCOM_MODE_PB :: inject for gcr hang error.\r\n\tdmb
#define EDI_SCOM_MODE_PB_SPARES                            405, 14,  8 // EDI_SCOM_MODE_PB :: scom mode reg spares.\r\n\tdmb
#define EI4_TX_MODE_PL_FULL_REG                            415,  0, 16 // EI4_TX_MODE_PL :: iotk alias: for entire tx_mode_pl register
#define EI4_TX_LANE_PDWN                                   415,  0,  1 // EI4_TX_MODE_PL :: used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (tx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers tx_lane_disabled_vec_0_15 and tx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane drive inhibited (tristated) and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EI4_TX_LANE_INVERT                                 415,  1,  1 // EI4_TX_MODE_PL :: used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.\r\n\tmbs
#define EI4_TX_LANE_QUIESCE                                415,  2,  2 // EI4_TX_MODE_PL :: used to force the output of a lane to a particular value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.\r\n\tmbs
#define EI4_TX_LANE_SCRAMBLE_DISABLE                       415,  6,  1 // EI4_TX_MODE_PL :: used to disable the tx scrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EI4_TX_FIFO_ERR                                    416,  0,  1 // EI4_TX_CNTL_STAT_PL :: indicates an error condition in the tx fifo.\r\n\trgr
#define EI4_TX_PL_SPARE_MODE_0                             417,  0,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_1                             417,  1,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_2                             417,  2,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_3                             417,  3,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_4                             417,  4,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_5                             417,  5,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_6                             417,  6,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_PL_SPARE_MODE_7                             417,  7,  1 // EI4_TX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_TX_LANE_BIST_ERR                               418,  0,  1 // EI4_TX_BIST_STAT_PL :: indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.\r\n\tjgr
#define EI4_TX_LANE_BIST_DONE                              418,  1,  1 // EI4_TX_BIST_STAT_PL :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running.\r\n\tjgr
#define EI4_TX_PL_FIR_ERRS_FULL_REG                        422,  0, 16 // EI4_TX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EI4_TX_PL_FIR_ERRS                                 422,  0,  1 // EI4_TX_FIR_PL :: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_PL_REGS                          422,  0,  1 // EI4_TX_FIR_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EI4_TX_PL_FIR_ERRS_MASK_FULL_REG                   423,  0, 16 // EI4_TX_FIR_MASK_PL :: iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\tpmt
#define EI4_TX_PL_FIR_ERRS_MASK                            423,  0,  1 // EI4_TX_FIR_MASK_PL :: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_MASK_PL_REGS                     423,  0,  1 // EI4_TX_FIR_MASK_PL :: iotk alias: fir mask for the per-lane tx register checker.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_INJ_FULL_REG                     424,  0, 16 // EI4_TX_FIR_ERROR_INJECT_PL :: iotk alias: for tx_fir_error_inject_pl register.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_INJ                              424,  0,  1 // EI4_TX_FIR_ERROR_INJECT_PL :: tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - tx_pl_fir_err_inj_from_regs.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_INJ_PL_REGS                      424,  0,  1 // EI4_TX_FIR_ERROR_INJECT_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EI4_TX_PRBS_TAP_ID                                 419,  0,  3 // EI4_TX_PRBS_MODE_PL :: tx per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with rx_prbs_tap_id.  see data scrambling workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EI4_TX_DRV_DATA_PATTERN_GCRMSG                     420,  0,  4 // EI4_TX_DATA_CNTL_GCRMSG_PL :: gcr message: tx per data lane drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id) (\r\n\t0110:(drv_red_prbs) prbs reduced density scramble pattern (see tx_prbs_tap_id and tx_reduced_scramble_mode)\r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_ei3_iap) ei-3 busy iap pattern (ei4 only)\r\n\t1001:(unused_e) unused\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(k28_5) drives 20-bit k28.5 pattern - padded to 32 bits\r\n\t1100:(unused_a) unused\r\n\t1101:(unused_b) unused\r\n\t1110:(unused_c) unused\r\n\t1111:(unused_d) unused\r\n\trjr
#define EI4_TX_SLS_LANE_SEL_GCRMSG                         420,  5,  1 // EI4_TX_DATA_CNTL_GCRMSG_PL :: gcr message: sls commands & recalibration\r\n\t0:(sls_gated) sls commands & recalibration data gated\r\n\t1:(snd_sls) send sls command or recalibration data\r\n\tsmr
#define EI4_TX_DRV_SYNC_PATT_GCRMSG                        421,  1,  1 // EI4_TX_SYNC_PATTERN_GCRMSG_PL :: sync pattern command\r\n\t used to reset the tx prbs register and send a 1111 1111 1111 sync pattern followed by changing tx_drv_data_pattern_gcrmsg to send full prbs (code 0101).  the rx prbs register is then reset after seeing the twelve ones if the rx_prbs_check_sync bit is set.  normally this is set by the training machine after sending the deskew pattern.  note that most prbs patterns have twelve ones so this operation could not be done after prbs is already started.  \r\n\t0:(sync_gated) sync pattern gated\r\n\t1:(snd_sync) send sync pattern
#define EI4_TX_ERR_INJECT                                  425,  0,  4 // EI4_TX_MODE_FAST_PL :: software-only controlled register to inject one or more errors for one deserialized clock pulse on one or more specified beats on this lane.  set bit position x to inject on beat x of a cycle.  bits 0:3 are used in edi and 0:1 are used in ei4. \r\n\tmbs
#define EI4_TX_ERR_INJ_A_ENABLE                            425,  4,  1 // EI4_TX_MODE_FAST_PL :: control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane. \r\n\tmbs
#define EI4_TX_ERR_INJ_B_ENABLE                            425,  5,  1 // EI4_TX_MODE_FAST_PL :: control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane. \r\n\tmbs
#define EI4_TX_TDR_CAPT_VAL                                426,  0,  1 // EI4_TX_TDR_STAT_PL :: value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.\r\n\tdmb
#define EI4_TX_CLK_PDWN                                    427,  0,  1 // EI4_TX_CLK_MODE_PG :: used to disable the tx clock and put it into a low power state.\r\n\t0:(clk_enable) clk enabled (default)\r\n\t1:(clk_disable) clk disabled.\r\n\tmbs
#define EI4_TX_CLK_INVERT                                  427,  1,  1 // EI4_TX_CLK_MODE_PG :: used to invert the polarity of the clock.\r\n\t0:(normal_clk) normal clk polarity (default)\r\n\t1:(invert_clk) invert clk.\r\n\tmbs
#define EI4_TX_CLK_QUIESCE_P                               427,  2,  2 // EI4_TX_CLK_MODE_PG :: used to force the output of the positive differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EI4_TX_CLK_QUIESCE_N                               427,  4,  2 // EI4_TX_CLK_MODE_PG :: used to force the output of the negative differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EI4_TX_PG_SPARE_MODE_0                             428,  0,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_1                             428,  1,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_2                             428,  2,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_3                             428,  3,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_4                             428,  4,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_5                             428,  5,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_6                             428,  6,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_PG_SPARE_MODE_7                             428,  7,  1 // EI4_TX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_TX_CLK_BIST_ERR                                432,  0,  2 // EI4_TX_BIST_STAT_PG :: indicates a txbist clock side error occurred.\r\n\t00:(no_error) no errors\r\n\t01:(clkn_error) an error has been found on clkn side\r\n\t10:(clkp_error) an error has been found on clkp side\r\n\t11:(all_errors) errors have been found on both clkp and clkn\r\n\tjgr
#define EI4_TX_CLK_BIST_DONE                               432,  2,  2 // EI4_TX_BIST_STAT_PG :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EI4_TX_FIFO_INIT                                   429,  1,  1 // EI4_TX_CNTL_STAT_PG :: used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.\r\n\tthis bit is write-only and as such writing a 1 to this bit will generate a pulse signal. there is no need to write this bit back to a 0.\r\n\trjr
#define EI4_TX_MAX_BAD_LANES                               430,  0,  5 // EI4_TX_MODE_PG :: static repair, dynamic repair & recal max number of bad lanes per tx bus (note: should match rx side)\r\n\tsmr
#define EI4_TX_MSBSWAP                                     430,  5,  1 // EI4_TX_MODE_PG :: used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode\r\n\tmbs
#define EI4_TX_RESET_CFG_ENA                               431,  0,  1 // EI4_TX_RESET_ACT_PG :: enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EI4_TX_CLR_PAR_ERRS                                431, 14,  1 // EI4_TX_RESET_ACT_PG :: clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.\r\n\tpmt
#define EI4_TX_FIR_RESET                                   431, 15,  1 // EI4_TX_RESET_ACT_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.\r\n\tpmt
#define EI4_TX_PG_FIR_ERRS_FULL_REG                        433,  0, 16 // EI4_TX_FIR_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.\r\n\tpmt
#define EI4_TX_PG_FIR_ERRS                                 433,  0,  8 // EI4_TX_FIR_PG :: a per-group txctl register or state machine parity error has occurred.\r\n\tbit0 - par_err_txctl_regs\r\n\tbit1: par_err_gcr_buff\r\n\tbit2 - reserved.\r\n\tbit3: par_err_tx_stt_rpr_snd_msg_state.\r\n\tbit4 - par_err_gcrs_ld_state\r\n\tbit5 - par_err_gcrs_unld_state\r\n\tbit6 - reserved.\r\n\tbit7 - reserved.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_PG_REGS                          433,  0,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl registers.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_GCR_BUFF                         433,  1,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EI4_TX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              433,  3,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EI4_TX_PG_FIR_ERR_GCRS_LD_SM                       433,  4,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr load state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_GCRS_UNLD_SM                     433,  5,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_PP_REGS                          433,  6,  1 // EI4_TX_FIR_PG :: iotk alias: parity error has occurred in the per-pack register space.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR                                  433, 15,  1 // EI4_TX_FIR_PG :: summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_MASK_FULL_REG                    434,  0, 16 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tpmt
#define EI4_TX_PG_FIR_ERRS_MASK                            434,  0,  8 // EI4_TX_FIR_MASK_PG :: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_MASK_PG_REGS                     434,  0,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl registers.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_MASK_GCR_BUFF                    434,  1,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr buffer.\r\n\tdmb
#define EI4_TX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         434,  3,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EI4_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                  434,  4,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr load state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                434,  5,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_MASK_PP_REGS                     434,  6,  1 // EI4_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group per-pack register space.\r\n\tpmt
#define EI4_TX_PL_FIR_ERR_MASK                             434, 15,  1 // EI4_TX_FIR_MASK_PG :: fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ_FULL_REG                     435,  0, 16 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ                              435,  0,  8 // EI4_TX_FIR_ERROR_INJECT_PG :: tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ_PG_REGS                      435,  0,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ_GCR_BUFF                     435,  1,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.\r\n\tdmb
#define EI4_TX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          435,  3,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EI4_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                   435,  4,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 435,  5,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.\r\n\tpmt
#define EI4_TX_PG_FIR_ERR_INJ_PP_REGS                      435,  6,  1 // EI4_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group per-pack register space.\r\n\tpmt
#define EI4_TX_BUS_ID                                      436,  0,  6 // EI4_TX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EI4_TX_GROUP_ID                                    436,  7,  6 // EI4_TX_ID1_PG :: this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EI4_TX_LAST_GROUP_ID                               437,  0,  6 // EI4_TX_ID2_PG :: this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EI4_TX_START_LANE_ID                               438,  1,  7 // EI4_TX_ID3_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EI4_TX_END_LANE_ID                                 438,  9,  7 // EI4_TX_ID3_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EI4_TX_DRV_CLK_PATTERN_GCRMSG                      439,  0,  2 // EI4_TX_CLK_CNTL_GCRMSG_PG :: tx clock drive patterns\r\n\t00:(drv_0s) drive all 0s pattern\r\n\t01:(drv_wt) drive wiretest pattern\r\n\t10:(drv_c4) drive clock pattern\r\n\t11:(unused) unused\r\n\tdmb
#define EI4_TX_WT_EN_ALL_CLK_SEGS_GCRMSG                   443,  0,  1 // EI4_TX_WT_SEG_ENABLE_PG :: tx clock wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EI4_TX_WT_EN_ALL_DATA_SEGS_GCRMSG                  443,  1,  1 // EI4_TX_WT_SEG_ENABLE_PG :: tx data  wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EI4_TX_BAD_LANE1_GCRMSG                            440,  0,  7 // EI4_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane one in relation to the entire tx bus\r\n\tsmr
#define EI4_TX_BAD_LANE2_GCRMSG                            440,  7,  7 // EI4_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane two in relation to the entire tx bus\r\n\tsmr
#define EI4_TX_BAD_LANE_CODE_GCRMSG                        440, 14,  2 // EI4_TX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: tx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EI4_TX_SLS_LANE_GCRMSG                             442,  0,  7 // EI4_TX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: encoded sls lane in relation to the entire tx bus\r\n\tsmr
#define EI4_TX_SLS_LANE_VAL_GCRMSG                         442,  7,  1 // EI4_TX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: tx sls lane valid\r\n\tsmr
#define EI4_TX_PC_TEST_MODE                                444,  0,  1 // EI4_TX_PC_FFE_PG :: driver segment test mode\r\n\t0:(disabled) mission mode enable\r\n\t1:(seg_test) driver output test mode\r\n\tmbs
#define EI4_TX_MAIN_SLICE_EN_ENC                           444,  4,  4 // EI4_TX_PC_FFE_PG :: 240ohm main slice enable\r\n\t0000:(zero_slices) zero main slices enabled\r\n\t0110:(max_slices) maximum main slices enabled\r\n\tmbs
#define EI4_TX_PC_SLICE_EN_ENC                             444, 12,  4 // EI4_TX_PC_FFE_PG :: 240ohm precompensation slice enable\r\n\t0000:(zero_slices) zero precomp slices enabled\r\n\t1110:(max_slices) maximum precomp slices enabled\r\n\tmbs
#define EI4_TX_SLEWCTL                                     445,  0,  4 // EI4_TX_MISC_ANALOG_PG :: driver slew control\r\n\tbits 2 and 3 of this field are reserved\r\n\t0000:(slew80ps) 80ps nominal rate \r\n\t0100:(slew110ps) 110ps nominal rate \r\n\t1000:(slew140ps) 140ps nominal rate \r\n\t1100:(slew170ps) 170ps nominal rate \r\n\tmbs
#define EI4_TX_PVTNL_ENC                                   445, 10,  2 // EI4_TX_MISC_ANALOG_PG :: pvt nfet enables for all driver slices\r\n\t00:(disable) no pvt nfets enable \r\n\t01:(2400ohms) min pvt nfet enabled in parallel \r\n\t10:(1200ohms) max pvt nfet enabled in parallel \r\n\t11:(800ohms) both pvt nfets enabled in parallel\r\n\tmbs
#define EI4_TX_PVTPL_ENC                                   445, 14,  2 // EI4_TX_MISC_ANALOG_PG :: pvt pfet enables for all driver slices\r\n\t00:(disable) no pvt pfets enable \r\n\t01:(2400ohms) min pvt pfet enabled in parallel \r\n\t10:(1200ohms) max pvt pfet enabled in parallel \r\n\t11:(800ohms) both pvt pfets enabled in parallel\r\n\tmbs
#define EI4_TX_LANE_DISABLED_VEC_0_15                      446,  0, 16 // EI4_TX_LANE_DISABLED_VEC_0_15_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EI4_TX_LANE_DISABLED_VEC_16_31                     447,  0, 16 // EI4_TX_LANE_DISABLED_VEC_16_31_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EI4_TX_SLS_LANE_SHDW_GCRMSG                        448,  0,  1 // EI4_TX_SLS_LANE_MUX_GCRMSG_PG :: gcr message: sls lane shadowing or unshadowing functional data (used to set up tx mux controls)\r\n\tsmr
#define EI4_TX_SLS_HNDSHK_STATE                            449,  0,  5 // EI4_TX_DYN_RPR_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for tx_sls_hndshk_state\r\n\t smr
#define EI4_TX_SLV_MV_SLS_SHDW_REQ_GCRMSG                  450,  0,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EI4_TX_SLV_MV_SLS_SHDW_RPR_REQ_GCRMSG              450,  1,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EI4_TX_SLV_MV_SLS_UNSHDW_REQ_GCRMSG                450,  2,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EI4_TX_SLV_MV_SLS_UNSHDW_RPR_REQ_GCRMSG            450,  3,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EI4_TX_BUS_WIDTH                                   450,  4,  7 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: tx bus width\r\n\tsmr
#define EI4_TX_SLV_MV_SLS_RPR_REQ_GCRMSG                   450, 11,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EI4_TX_SLS_LANE_SEL_LG_GCRMSG                      450, 12,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: sets the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EI4_TX_SLS_LANE_UNSEL_LG_GCRMSG                    450, 13,  1 // EI4_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG :: gcr message: clears the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EI4_TX_RDT_MODE                                    451,  0,  1 // EI4_TX_RDT_CNTL_PG :: sets rdt mode\r\n\t0:(normal) rdt off \r\n\t1:(set_rdt_mode) drive rdt-make sure it is on for all groups that need in\r\n\tdmb
#define EI4_TX_RUN_RDT                                     451,  1,  1 // EI4_TX_RDT_CNTL_PG :: drives rdt pattern\r\n\t0:(normal) rdt off \r\n\t1:(drv_rdt) drive rdt\r\n\tdmb
#define EI4_TX_WT_PATTERN_LENGTH                           461,  0,  2 // EI4_TX_WIRETEST_PP :: tx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EI4_TX_REDUCED_SCRAMBLE_MODE                       462,  0,  2 // EI4_TX_MODE_PP :: enables/disables and sets reduced density of scramble pattern. this must be set consistent with rx_reduced_scramble_mode.  \r\n\t00:(disable_0) full density \r\n\t01:(disable_1) full density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div2_1) enable div2 reduced density.\r\n\trjr
#define EI4_TX_PRBS_SCRAMBLE_MODE                          462,  2,  2 // EI4_TX_MODE_PP :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by tx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EI4_TX_EI3_MODE                                    462, 15,  1 // EI4_TX_MODE_PP :: ei3 mode - see also rx_ei3_mode \r\n\t0:(ei4) ei4 mode (default) \r\n\t1:(ei3) ei3 mode\r\n\tdmb
#define EI4_TX_BIST_EN                                     466,  0,  1 // EI4_TX_BIST_CNTL_PP :: this bit enables the tx bist state machine to begin testing.\r\n\tjgr
#define EI4_TX_SND_SLS_CMD_GCRMSG                          463,  0,  1 // EI4_TX_SLS_GCRMSG_PP :: gcr message: send sls command or recalibration data\r\n\tsmr
#define EI4_TX_DYN_RECAL_TSR_IGNORE_GCRMSG                 463,  1,  1 // EI4_TX_SLS_GCRMSG_PP :: gcr message: send dynamic recal sls commands all the time (not just during the status reporting interval)\r\n\tsmr
#define EI4_TX_SLS_CMD_GCRMSG                              463,  2,  6 // EI4_TX_SLS_GCRMSG_PP :: gcr message: tx sls command\r\n\tsmr
#define EI4_TX_SND_SLS_CMD_PREV_GCRMSG                     463,  8,  1 // EI4_TX_SLS_GCRMSG_PP :: gcr message: revert to sending previous sls command or recalibration data after recovery repair made\r\n\tsmr
#define EI4_TX_SND_SLS_USING_REG_SCRAMBLE                  463,  9,  1 // EI4_TX_SLS_GCRMSG_PP :: gcr message: send sls command using normal scramble pattern instead of calibration or 9th pattern\r\n\trjr
#define EI4_TX_ERR_INJ_A_RAND_BEAT_DIS                     464,  0,  1 // EI4_TX_BER_CNTL_A_PP :: used to disable randomization of error inject on different beats of data for pattern a.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EI4_TX_ERR_INJ_A_FINE_SEL                          464,  1,  3 // EI4_TX_BER_CNTL_A_PP :: random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EI4_TX_ERR_INJ_A_COARSE_SEL                        464,  4,  4 // EI4_TX_BER_CNTL_A_PP :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EI4_TX_ERR_INJ_A_BER_SEL                           464, 10,  6 // EI4_TX_BER_CNTL_A_PP :: used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EI4_TX_ERR_INJ_B_RAND_BEAT_DIS                     465,  0,  1 // EI4_TX_BER_CNTL_B_PP :: used to disable randomization of error inject on different beats of data for pattern b.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EI4_TX_ERR_INJ_B_FINE_SEL                          465,  1,  3 // EI4_TX_BER_CNTL_B_PP :: random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EI4_TX_ERR_INJ_B_COARSE_SEL                        465,  4,  4 // EI4_TX_BER_CNTL_B_PP :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EI4_TX_ERR_INJ_B_BER_SEL                           465, 10,  6 // EI4_TX_BER_CNTL_B_PP :: used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EI4_TX_ERR_INJ_SLS_MODE                            467,  0,  1 // EI4_TX_BER_CNTL_SLS_PP :: used to set the random bit error injection for pattern a to work during sls transmission only. \r\n\tmbs
#define EI4_TX_ERR_INJ_SLS_ALL_CMD                         467,  1,  1 // EI4_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on all sls command transmissions. \r\n\tmbs
#define EI4_TX_ERR_INJ_SLS_RECAL                           467,  2,  1 // EI4_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on the calibration lane only when not sending an sls command. see workbook for details.\r\n\tmbs
#define EI4_TX_ERR_INJ_SLS_CMD                             467, 10,  6 // EI4_TX_BER_CNTL_SLS_PP :: used to qualify the sls mode error injection for pattern a, to inject on only this sls command transmission. see workbook for sls command codes.\r\n\tmbs
#define EI4_TX_ENABLE_REDUCED_SCRAMBLE                     468,  0,  1 // EI4_TX_CNTL_PP :: enables reduced density of scramble pattern. normally this is set automatically in the functional mode training state.  users should use tx_reduced_scramble_mode to throttle density.  \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the tx_reduced_scramble_mode setting.\r\n\trjr
#define EI4_TX_RESET_CFG_HLD                               469,  0, 16 // EI4_TX_RESET_CFG_PP :: reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via tx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EI4_TX_TDR_DAC_CNTL                                470,  0,  8 // EI4_TX_TDR_CNTL1_PP :: controls variable threshold receiver for tdr function\r\n\tdmb
#define EI4_TX_TDR_PULSE_OFFSET                            471,  0, 12 // EI4_TX_TDR_CNTL2_PP :: offset value for tdr pulse.\r\n\tdmb
#define EI4_TX_TDR_PULSE_WIDTH                             472,  0, 12 // EI4_TX_TDR_CNTL3_PP :: width of tdr pulse.\r\n\tdmb
#define EI4_RX_MODE_PL_FULL_REG                            475,  0, 16 // EI4_RX_MODE_PL :: alias for entire rx_mode_pl register\r\n\tpmt
#define EI4_RX_LANE_PDWN                                   475,  0,  1 // EI4_RX_MODE_PL :: used to receive inhibit and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (rx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers rx_lane_disabled_vec_0_15 and rx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane receive inhibited and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EI4_RX_LANE_SCRAMBLE_DISABLE                       475,  6,  1 // EI4_RX_MODE_PL :: used to disable the rx descrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EI4_RX_BLOCK_LOCK_LANE                             476,  0,  1 // EI4_RX_CNTL_PL :: enables rotation and checking for block lock. \r\n\t0:(disabled) disable checking (forces block_locked_b to 1)\r\n\t1:(enabled) enable checking and run block lock.\r\n\trjr
#define EI4_RX_CHECK_SKEW_LANE                             476,  1,  1 // EI4_RX_CNTL_PL :: per-lane initialization controls. checks skew request\r\n\trjr
#define EI4_RX_OFFCAL_MODE                                 476,  3,  1 // EI4_RX_CNTL_PL :: when set, put this lanes front end into offset cancellation mode. only needed as an override since running offset cancellation does this automatically.\r\n\tjfg
#define EI4_RX_PL_SPARE_MODE_0                             477,  0,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_1                             477,  1,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_2                             477,  2,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_3                             477,  3,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_4                             477,  4,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_5                             477,  5,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_6                             477,  6,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_PL_SPARE_MODE_7                             477,  7,  1 // EI4_RX_SPARE_MODE_PL :: per-lane spare mode latch.\r\n\tpmt
#define EI4_RX_BIST_ERR                                    479,  0,  1 // EI4_RX_BIST_STAT_PL :: indicates that rxbist did not find two data eyes of sufficient width.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist\r\n\tjgr
#define EI4_RX_BIST_DONE                                   479,  1,  1 // EI4_RX_BIST_STAT_PL :: indicates a rxbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EI4_RX_OFFSET_EVEN_SAMP1                           480,  1,  7 // EI4_RX_OFFSET_EVEN_PL :: this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EI4_RX_OFFSET_EVEN_SAMP0                           480,  9,  7 // EI4_RX_OFFSET_EVEN_PL :: this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EI4_RX_OFFSET_ODD_SAMP1                            481,  1,  7 // EI4_RX_OFFSET_ODD_PL :: this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EI4_RX_OFFSET_ODD_SAMP0                            481,  9,  7 // EI4_RX_OFFSET_ODD_PL :: this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EI4_RX_AMP_PEAK                                    482,  0,  6 // EI4_RX_AMP_VAL_PL :: for ei4 this field is used in halves: bits 0-2 set the value for peak_en_1_2g baud rate, 3-5 set peak_en_2_4g.  each half is considered an independent 3 bit field - no overflow from one to the other.\r\n\tdmb
#define EI4_RX_FIFO_L2U_DLY                                486,  0,  4 // EI4_RX_FIFO_STAT_PL :: rx fifo load-to-unload delay, initailed during fifo init and modified thereafter by the deskew machine.  for setting x, the latency is 2*x to 2*x+2 ui.  default is 8-10 ui\r\n\trjr
#define EI4_RX_FIFO_INIT                                   486,  4,  1 // EI4_RX_FIFO_STAT_PL :: initializes the fifo unload counter with the load counter and initializes the fifo load to unload delay\r\n\trjr
#define EI4_RX_FIFO_INC_L2U_DLY                            496,  0,  1 // EI4_RX_FIFO_CNTL_PL :: increment existing fifo load-to-unload delay register\r\n\trjr
#define EI4_RX_FIFO_DEC_L2U_DLY                            496,  1,  1 // EI4_RX_FIFO_CNTL_PL :: decrement existing fifo load-to-unload delay register\r\n\trjr
#define EI4_RX_CLR_SKEW_VALID                              496,  2,  1 // EI4_RX_FIFO_CNTL_PL :: clear skew valid registers\r\n\trjr
#define EI4_RX_BAD_BLOCK_LOCK                              490,  0,  1 // EI4_RX_DESKEW_STAT_PL :: deskew step block lock not established--lane marked bad\r\n\trjr
#define EI4_RX_BAD_SKEW                                    490,  1,  1 // EI4_RX_DESKEW_STAT_PL :: deskew step skew value not detected--lane marked bad\r\n\trjr
#define EI4_RX_BAD_DESKEW                                  490,  2,  1 // EI4_RX_DESKEW_STAT_PL :: deskew step deskew value\r\n\trjr
#define EI4_RX_BAD_EYE_OPT_BER                             509,  0,  1 // EI4_RX_EYE_OPT_STAT_PL :: eye opt step failed ber test--lane marked bad\r\n\trjr
#define EI4_RX_BAD_EYE_OPT_WIDTH                           509,  1,  1 // EI4_RX_EYE_OPT_STAT_PL :: eye opt step failed width test--lane marked bad\r\n\trjr
#define EI4_RX_VREF                                        488,  0,  8 // EI4_RX_VREF_PL :: this is the voltage reference setting of the pre-amp. the step size is about vio*5/1100.\r\n\tdmb
#define EI4_RX_PL_FIR_ERRS_FULL_REG                        491,  0, 16 // EI4_RX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EI4_RX_PL_FIR_ERRS                                 491,  0,  1 // EI4_RX_FIR_PL :: a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_PL_REGS                          491,  0,  1 // EI4_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx registers.\r\n\tpmt
#define EI4_RX_PL_FIR_ERRS_MASK_FULL_REG                   492,  0, 16 // EI4_RX_FIR_MASK_PL :: iotk alias: fir mask for rx_fir_pl errors.\r\n\tpmt
#define EI4_RX_PL_FIR_ERRS_MASK                            492,  0,  1 // EI4_RX_FIR_MASK_PL :: fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_MASK_PL_REGS                     492,  0,  1 // EI4_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane register parity errors.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_INJ_FULL_REG                     493,  0, 16 // EI4_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_INJ                              493,  0,  1 // EI4_RX_FIR_ERROR_INJECT_PL :: rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_INJ_PL_REGS                      493,  0,  1 // EI4_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EI4_RX_PRBS_TAP_ID                                 487,  0,  3 // EI4_RX_PRBS_MODE_PL :: per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with tx_prbs_tap_id.  see data descramble workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EI4_RX_SOME_BLOCK_LOCKED                           489,  0,  1 // EI4_RX_STAT_PL :: per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane not block locked.\r\n\t1:(high) lane block locked\r\n\trjr
#define EI4_RX_ALL_BLOCK_LOCKED_B                          489,  1,  1 // EI4_RX_STAT_PL :: per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane block locked\r\n\t1:(high) lane not block locked.\r\n\trjr
#define EI4_RX_SOME_SKEW_VALID                             489,  2,  1 // EI4_RX_STAT_PL :: per-lane deskew pattern b detect indicator\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern not detected.\r\n\t1:(high) pattern detected\r\n\trjr
#define EI4_RX_ALL_SKEW_VALID_B                            489,  3,  1 // EI4_RX_STAT_PL :: per-lane deskew pattern b detect indicator (active low)\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern detected\r\n\t1:(high) pattern not detected.\r\n\trjr
#define EI4_RX_SOME_PRBS_SYNCED                            489,  4,  1 // EI4_RX_STAT_PL :: per-lane prbs synchronization indicator\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized on any lane in a pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EI4_RX_PRBS_SYNCED_B                               489,  5,  1 // EI4_RX_STAT_PL :: per-lane prbs synchronization indicator (active low)\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized or there are no valid or good lanes in the pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EI4_RX_SKEW_VALUE                                  489,  6,  6 // EI4_RX_STAT_PL :: per-lane prbs synchronization count\r\n\tvalue of the free-running counter when the marker pattern of deskew pattern b is detected\r\n\trjr
#define EI4_RX_SLS_LANE_SEL                                494,  0,  1 // EI4_RX_SLS_PL :: selects which lane to receive sls commands and recalibration data on\r\n\tsmr
#define EI4_RX_9TH_PATTERN_EN                              494,  1,  1 // EI4_RX_SLS_PL :: sets rx descrabmler to use calibration or 9th scramble pattern\r\n\tsmr
#define EI4_RX_WT_LANE_DISABLED                            495,  0,  1 // EI4_RX_WT_STATUS_PL :: wiretest has disabled this lane\r\n\trjr
#define EI4_RX_WT_LANE_INVERTED                            495,  1,  1 // EI4_RX_WT_STATUS_PL :: wiretest lane inverted ( or _n and _p swapped)\r\n\t0--not inverted if rx_wt_lane_bad_code = 000 \r\n\t1--inverted if rx_wt_lane_bad_code = 000\r\n\t see rx_wt_lane_bad_code descriptions  for meaning if rx_wt_lane_bad_code not = 000\r\n\trjr
#define EI4_RX_WT_LANE_BAD_CODE                            495,  2,  3 // EI4_RX_WT_STATUS_PL :: wiretest lane bad code concatenate rx_wt_lane_inverted with rx_wt_lane_bad_code to get a full status: \r\n\t0000--good lane--not inverted (edi and ei-4)\r\n\t0001--bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010--bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011--bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100--bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101--bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110--bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111--bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000--good lane--inverted (edi and ei-4) \r\n\t1001--bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010--bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011--bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100--bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101--bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110--bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111--bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EI4_RX_WT_LANE_STATUS_ALIAS                        495,  1,  4 // EI4_RX_WT_STATUS_PL :: alias for rx_wt_lane_inverted concatenated with rx_wt_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EI4_RX_EXT_SR                                      485,  4,  1 // EI4_RX_PROT_CNTL_PL :: rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 causes the phase rotator to shift one value to the right, ie add one to the pr value. if rx_reverse_shift is set to a 1 then a shift right pulse results in a subtraction of one instead of an addition.\r\n\trjr
#define EI4_RX_EXT_SL                                      485,  5,  1 // EI4_RX_PROT_CNTL_PL :: rx manual phase rotator shift left pulse\r\n\trx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 causes the phase rotator to shift one value to the right, ie add one to the pr value. if rx_reverse_shift is set to a 1 then a shift right pulse results in a subtraction of one instead of an addition. this mode is used for diagnostics and characterization\r\n\trjr
#define EI4_RX_PHASEROT_OFFSET                             484,  1,  7 // EI4_RX_PROT_MODE_PL :: rx phase rotator fixed offset from learned value\r\n\trjr
#define EI4_RX_PHASEROT_VAL                                483,  1,  7 // EI4_RX_PROT_STATUS_PL :: rx phase rotator current value\r\n\trjr
#define EI4_RX_EYE_WIDTH                                   505,  2,  6 // EI4_RX_EYE_WIDTH_STATUS_PL :: rx current eye width (in pr steps).\r\n\tdmb
#define EI4_RX_HIST_MIN_EYE_WIDTH_VALID                    505,  8,  1 // EI4_RX_EYE_WIDTH_STATUS_PL :: rx historic eye minimum is valid for this lane.\r\n\tdmb
#define EI4_RX_HIST_MIN_EYE_WIDTH                          505, 10,  6 // EI4_RX_EYE_WIDTH_STATUS_PL :: rx historic eye minimum--per-pack register valid for this lane if rx_hist_eye_min_valid is asserted for this lane.\r\n\tdmb
#define EI4_RX_RESET_HIST_EYE_WIDTH_MIN                    506,  0,  1 // EI4_RX_EYE_WIDTH_CNTL_PL :: rx historic eye minimum reset--reset historic min to maximum value and clears valid bits.\r\n\tdmb
#define EI4_RX_BER_COUNT                                   497,  0,  8 // EI4_RX_BER_STATUS_PL :: per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.\r\n\tpmt
#define EI4_RX_BER_COUNT_SATURATED                         497,  8,  1 // EI4_RX_BER_STATUS_PL :: pl diag ber error counter saturation indicator. when '1' indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.\r\n\tpmt
#define EI4_RX_BER_COUNT_FROZEN_BY_LANE                    497,  9,  1 // EI4_RX_BER_STATUS_PL :: pl diag ber error counter and or pp timer has been frozen by another lane's error counter being saturated.\r\n\tpmt
#define EI4_RX_BER_COUNT_FROZEN_BY_TIMER                   497, 10,  1 // EI4_RX_BER_STATUS_PL :: pl diag ber error counter has been frozen by a diag ber timer becoming saturated.\r\n\tpmt
#define EI4_RX_BER_TIMER_SATURATED                         497, 11,  1 // EI4_RX_BER_STATUS_PL :: pl diag ber timer saturation indicator. when '1' indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.\r\n\tpmt
#define EI4_RX_BER_TIMER_VALUE_0_15                        498,  0, 16 // EI4_RX_BER_TIMER_0_15_PL :: pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.\r\n\tpmt
#define EI4_RX_BER_TIMER_VALUE_16_31                       499,  0, 16 // EI4_RX_BER_TIMER_16_31_PL :: pl diag ber timer value, bits 16-31.\r\n\tpmt
#define EI4_RX_BER_TIMER_VALUE_32_39                       500,  0,  8 // EI4_RX_BER_TIMER_32_39_PL :: pl diag ber timer value, bits 32-39.\r\n\tpmt
#define EI4_RX_SERVO_OP_DONE                               501,  0,  1 // EI4_RX_SERVO_CNTL_PL :: servo op completed\r\n\trjr
#define EI4_RX_SERVO_OP_ALL_DONE_B                         501,  1,  1 // EI4_RX_SERVO_CNTL_PL :: servo op code on all lanes-asserted (low) if the lane *_done is asserted or the lane is disabled or the lane is bad--intended for global reading using the dot-or nature of the bus to see that all valid lanes are done when low \r\n\trjr
#define EI4_RX_SERVO_OP                                    501,  2,  5 // EI4_RX_SERVO_CNTL_PL :: servo operation code \r\n\t00000: c_nop \r\n\t00001: c_offcal_0 \r\n\t00010: c_offcal_1 \r\n\t00011: c_ctle \r\n\t00100: c_vref \r\n\t00101: c_blocklock \r\n\t00110: c_edgetrack \r\n\t00111: c_ddc \r\n\t01000: c_ap_noh \r\n\t01001: c_an_noh \r\n\t01010: c_amin_noh \r\n\t01011: unused \r\n\t01100: unused \r\n\t01101: unused \r\n\t01110: c_eye_track \r\n\t01111: c_dcd_adj \r\n\t10000: c_dfe_ape \r\n\t10001: c_dfe_ane \r\n\t10010: c_dfe_apo \r\n\t10011: c_dfe_ano \r\n\t10100: c_dfe_amin \r\n\t10101: unused \r\n\t10110: unused \r\n\t10111: unused \r\n\t11000: c_bump_left \r\n\t11001: c_bump_right \r\n\t11010: c_bump1 \r\n\t11011: c_bump2 \r\n\t11100: c_h1ap_adjust \r\n\t11101: c_ber_test \r\n\t11110: unused \r\n\t11111: unused  \r\n\trjr
#define EI4_RX_FIFO_OUT_0_15                               502,  0, 16 // EI4_RX_FIFO_DIAG_0_15_PL :: diag capture: fifo entries 0 to 15\r\n\tdmb
#define EI4_RX_FIFO_OUT_16_31                              503,  0, 16 // EI4_RX_FIFO_DIAG_16_31_PL :: diag capture: fifo entries 16 to 31\r\n\tdmb
#define EI4_RX_FIFO_OUT_32_47                              504,  0, 16 // EI4_RX_FIFO_DIAG_32_47_PL :: diag capture: fifo entries 32 to 47\r\n\tdmb
#define EI4_RX_LN_TRC_EN                                   507,  0,  1 // EI4_RX_TRACE_PL :: enable tracing of this lane.\r\n\tsmr
#define EI4_RX_SERVO_BER_COUNT                             508,  0, 12 // EI4_RX_SERVO_BER_COUNT_PL :: servo-based bit error count.\r\n\trjr
#define EI4_RX_DCD_ADJUST                                  510,  0,  4 // EI4_RX_DCD_ADJ_PL :: clock duty cycle adjustment, binary 2s complement value.\r\n\tdmb
#define EI4_RX_CLK_PDWN                                    511,  0,  1 // EI4_RX_CLK_MODE_PG :: used to disable the rx clock and put it into a low power state.\r\n\t0:(enabled) clk enabled (default)\r\n\t1:(disabled) clk disabled
#define EI4_RX_CLK_INVERT                                  511,  1,  1 // EI4_RX_CLK_MODE_PG :: used to invert the polarity of the clock.\r\n\t0:(normal) normal clk polarity (default)\r\n\t1:(inverted) clk inverted
#define EI4_RX_CLK_AMP_PEAK                                511, 10,  6 // EI4_RX_CLK_MODE_PG :: this is the vertical offset of the clock pre-amp\r\n\trjr
#define EI4_RX_PG_SPARE_MODE_0                             512,  0,  1 // EI4_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_RX_PG_SPARE_MODE_1                             512,  1,  1 // EI4_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_RX_PG_SPARE_MODE_2                             512,  2,  1 // EI4_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_RX_PG_SPARE_MODE_3                             512,  3,  1 // EI4_RX_SPARE_MODE_PG :: per-group spare mode latch.\r\n\tpmt
#define EI4_RX_PG_SPARE_MODE_4                             512,  4,  1 // EI4_RX_SPARE_MODE_PG :: chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.\r\n\tsmr
#define EI4_RX_SLS_EXTEND_SEL                              512,  5,  3 // EI4_RX_SPARE_MODE_PG :: how long to extend sending of the tx sls command (i.e. delay the gcr_wrt_done to the sending sm).\r\n\t(times based on edi slow clk of 833ps)\r\n\t000:(tap1) 0.833ns\r\n\t001:(tap2) 53.3ns\r\n\t010:(tap3) 106.6ns\r\n\t011:(tap4) 213.2ns\r\n\t100:(tap5) 426.5ns\r\n\t101:(tap6) 853.0ns\r\n\t110:(tap7) 1.7us\r\n\t111:(tap8) 3.4us\r\n\tsmr
#define EI4_RX_MASTER_MODE                                 514,  0,  1 // EI4_RX_MODE_PG :: master mode\r\n\tused to set a chip bus as the master side of the interface. the master side of the interface is where training is kicked off and coordinated in the logic.\r\n\t0:(slave) slave\r\n\t1:(master) master\r\n\trjr
#define EI4_RX_DISABLE_FENCE_RESET                         514,  1,  1 // EI4_RX_MODE_PG :: set to disable clearing of the rx and tx fence controls at the end of training. \r\n\t0:(enable) clear the fence bit (default) \r\n\t1:(disable) leave the fence in its current state \r\n\tmbs
#define EI4_RX_RESET_CFG_ENA                               517,  0,  1 // EI4_RX_RESET_ACT_PG :: enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EI4_RX_CLR_PAR_ERRS                                517, 14,  1 // EI4_RX_RESET_ACT_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.\r\n\tpmt
#define EI4_RX_FIR_RESET                                   517, 15,  1 // EI4_RX_RESET_ACT_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EI4_RX_BUS_ID                                      518,  0,  6 // EI4_RX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EI4_RX_GROUP_ID                                    518,  7,  6 // EI4_RX_ID1_PG :: this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EI4_RX_LAST_GROUP_ID                               519,  0,  6 // EI4_RX_ID2_PG :: this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EI4_RX_START_LANE_ID                               520,  1,  7 // EI4_RX_ID3_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EI4_RX_END_LANE_ID                                 520,  9,  7 // EI4_RX_ID3_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EI4_RX_SLS_DISABLE                                 522,  0,  1 // EI4_RX_SLS_MODE_PG :: disables receiving & decoding of sls commands\r\n\tsmr
#define EI4_TX_SLS_DISABLE                                 522,  1,  1 // EI4_RX_SLS_MODE_PG :: if set, the sls command being sent will always just be a nop.  to truly disable the full sls logic path, also do some combination of the following (depending on what exactly you are trying to do): set the rx_sls_disable, manually override the tx_snd_sls_cmd_gcrmsg per pack registers (if you do not also disable the various sending sms, though, this will eventually get overwritten), set tx_sls_lane_val_gcrmsg to 0 (if there is no valid tx sls lane, no sls command will get sent on it), and/or disable the recal, repair, recovery sms (rx_dyn_recal_suspend, rx_dyn_rpr_disable, rx_sls_rcvy_disable) that initiate the sending of sls commands\r\n\tsmr
#define EI4_RX_SLS_CNTR_TAP_PTS                            522,  2,  2 // EI4_RX_SLS_MODE_PG :: how long the sls rx command needs to be stable for.\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 16 c8 clks; ei4 - 32 c4 clks\r\n\t01:(tap2) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t10:(tap3) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t11:(tap4) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\tsmr
#define EI4_RX_NONSLS_CNTR_TAP_PTS                         522,  4,  2 // EI4_RX_SLS_MODE_PG :: how long a non-sls rx command needs to be stable for (to know we have switched from an sls command to data).\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t01:(tap2) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t10:(tap3) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\t11:(tap4) edi - 256 c8 clks; ei4 - 512 c4 clks\r\n\tsmr
#define EI4_RX_SLS_ERR_CHK_RUN                             522,  6,  1 // EI4_RX_SLS_MODE_PG :: run sls error check counter\r\n\tsmr
#define EI4_RX_FINAL_NOP_CS                                522,  7,  1 // EI4_RX_SLS_MODE_PG :: hw210823 chicken switch.  0: allows receiver of final nop to accept either sls_nop or sls_*_req to exit the handshake sm; 1: reverts to original dd1.0 logic to only accept nop to exit the handshake sm. \r\n\tsmr
#define EI4_RX_SR_FINAL_NOP_TIMEOUT_SEL                    522,  8,  3 // EI4_RX_SLS_MODE_PG :: hw232404: for ei4 in the case of 2 bad lanes, so no sls lane, how long to wait for final nop during static repair. \r\n\t000:(tap0) 0.8ns (one cycle chicken switch) \r\n\t001:(tap1) 1.7us \r\n\t010:(tap2) 3.4us \r\n\t011:(tap3) 6.8us \r\n\t100:(tap4) 13.6us \r\n\t101:(tap5) 27.2us \r\n\t110:(tap6) 54.6us \r\n\t111:(tap7) infinite\r\n\tsmr
#define EI4_RX_SLS_EXCEPTION2_CS                           522, 11,  1 // EI4_RX_SLS_MODE_PG :: hw235842: added chicken switch for new sls exception2 command.  need to set this when mixing allv3 and later logic with logic previous to allv3\r\n\tif set to 1, should set rx_sls_timeout_sel > 4x recal_overall_timeout_sel so avoid sending exception on sr interval and seeing false exception resmr
#define EI4_RX_START_WDERF_ALIAS                           523,  0,  5 // EI4_RX_TRAINING_START_PG :: alias for rx_start_* bits\r\n\tpmt
#define EI4_RX_START_WIRETEST                              523,  0,  1 // EI4_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the wiretest portion of the training states.\r\n\trjr
#define EI4_RX_START_DESKEW                                523,  1,  1 // EI4_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the deskew portion of the training states.\r\n\trjr
#define EI4_RX_START_EYE_OPT                               523,  2,  1 // EI4_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the data eye optimization portion of the training states.\r\n\trjr
#define EI4_RX_START_REPAIR                                523,  3,  1 // EI4_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the static lane repair portion of the training states.\r\n\trjr
#define EI4_RX_START_FUNC_MODE                             523,  4,  1 // EI4_RX_TRAINING_START_PG :: when this register is written to a 1 the training state machine will run the transition to functional data portion of the training states.\r\n\trjr
#define EI4_RX_START_BIST                                  523,  5,  1 // EI4_RX_TRAINING_START_PG :: set bit to run bist and perform the required tx fifo init, rx cu pll lock, rx fifo init, and offset calibration in the bist helper state machine. the rx bist state machine is enabled through a gcr message to the rx_bist_en register field. \r\n\t0: (idle) idle \r\n\t1: (en_rx_bist) start rx bist \r\n\tjgr
#define EI4_RX_START_OFFSET_CAL                            523,  6,  1 // EI4_RX_TRAINING_START_PG :: set bit to run offset cal and the required tx fifo init, rx cu pll lock, and rx fifo init through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (ocal) start offset cal \r\n\tjgr
#define EI4_RX_START_WT_BYPASS                             523,  7,  1 // EI4_RX_TRAINING_START_PG :: set bit to run wiretest bypass and the required tx fifo initialization through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (wtbyp) start wiretest bypass \r\n\tjgr
#define EI4_RX_WDERF_DONE_ALIAS                            524,  0,  5 // EI4_RX_TRAINING_STATUS_PG :: alias for rx_*_done bits\r\n\tpmt
#define EI4_RX_WIRETEST_DONE                               524,  0,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the wiretest training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EI4_RX_DESKEW_DONE                                 524,  1,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the deskew training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EI4_RX_EYE_OPT_DONE                                524,  2,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the eye optimization training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EI4_RX_REPAIR_DONE                                 524,  3,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the static lane repair training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EI4_RX_FUNC_MODE_DONE                              524,  4,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the transition to functional data training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EI4_RX_BIST_STARTED                                524,  5,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx bist helper initializations have completed and a gcr enable message has been sent to rx bist. \r\n\tjgr
#define EI4_RX_OFFSET_CAL_DONE                             524,  6,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, offset cal has completed. \r\n\tjgr
#define EI4_RX_WT_BYPASS_DONE                              524,  7,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, wiretest bypass has completed. \r\n\tjgr
#define EI4_RX_WDERF_FAILED_ALIAS                          524,  8,  5 // EI4_RX_TRAINING_STATUS_PG :: alias for rx_*_failed bits\r\n\tpmt
#define EI4_RX_WIRETEST_FAILED                             524,  8,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the wiretest training state encountered an error.\r\n\trjr
#define EI4_RX_DESKEW_FAILED                               524,  9,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the deskew training state encountered an error.\r\n\trjr
#define EI4_RX_EYE_OPT_FAILED                              524, 10,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the eye optimization training state encountered an error.\r\n\trjr
#define EI4_RX_REPAIR_FAILED                               524, 11,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the static lane repair training state encountered an error.\r\n\trjr
#define EI4_RX_START_BIST_FAILED                           524, 13,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock and bist was not started. (this bit is set along with rx_wt_bypass_failed and rx_offset_cal_failed)\r\n\tjgr
#define EI4_RX_OFFSET_CAL_FAILED                           524, 14,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock and offset cal was not performed. (this bit is set along with rx_wt_bypass_failed and rx_start_bist_failed)\r\n\tjgr
#define EI4_RX_WT_BYPASS_FAILED                            524, 15,  1 // EI4_RX_TRAINING_STATUS_PG :: when this bit is read as a 1, the rx cu pll failed to lock. wiretest bypass did not complete. (this bit is set along with rx_offset_cal_failed and rx_start_bist_failed)\r\n\tjgr
#define EI4_RX_RECAL_STATUS                                525,  0, 16 // EI4_RX_RECAL_STATUS_PG :: no longer used--remove for dd2 design\r\n\trjr
#define EI4_RX_WT_CHECK_COUNT                              570,  0,  5 // EI4_RX_WT_CONFIG_PG :: selects number of extra times the wiretest pattern is checked for a good lane \r\n\trjr
#define EI4_RX_WT_CHECK_LANES                              570,  5,  2 // EI4_RX_WT_CONFIG_PG :: selects number of lanes that are checked during all-ones or all-zeroes check during wiretest:\r\n\t00:check all good lanes \r\n\t01:check majority of good lanes\r\n\t10:check half of good lanes\r\n\t11:check good lanes-2\r\n\trjr
#define EI4_RX_WT_ENABLE_TERM_MODE                         570,  7,  1 // EI4_RX_WT_CONFIG_PG :: enables week pullup or pulldown of receivers during wiretestt\r\n\t0:not enalbed pullup\r\r\n\t\t:enabled\r\n\trjr
#define EI4_RX_WT_TERM_PHASE                               570,  8,  1 // EI4_RX_WT_CONFIG_PG :: phase of pullup or pulldown of receivers during wiretest\r\n\t0:pulldown\r\r\n\t\t:pullup\r\n\trjr
#define EI4_RX_WT_TERM_MODE_ENC                            570,  9,  5 // EI4_RX_WT_CONFIG_PG :: slice enable for pfet/nfet pairs for termination mode during wiretest.  bits 0:3 determine how many 240ohm pairs to enable, out of 14.  bit 4 enables a half-strength 480ohm pfet/nfet pair, and also controls whether that pair is enabled in test mode.\r\n\trjr
#define EI4_RX_SLS_TIMEOUT_SEL                             526,  0,  4 // EI4_RX_TIMEOUT_SEL_PG :: selects spare lane signalling timeout value (how long to wait for a sls handshake command)\r\n\t0000:(tap0) 6.8us very small value for sim only\r\n\t0001:(tap1) 54.6us \r\n\t0010:(tap2) 109.2us \r\n\t0011:(tap3) 218.4us \r\n\t0100:(tap4) 436.7us \r\n\t0101:(tap5) 873.5us \r\n\t0110:(tap6) 1.7ms \r\n\t0111:(tap7) 3.5ms \r\n\t1000:(tap8) 7.0ms \r\n\t1001:(tap9) 14.0ms \r\n\t1010:(tap10) 28.0ms \r\n\t1011:(tap11) 55.9ms \r\n\t1100:(tap12) 111.8ms \r\n\t1101:(tap13) 447.2ms \r\n\t1110:(tap14) 1.8 s \r\n\t1111:(tap15) infinite\r\n\tnote: value must be 4x larger than tx_dyn_recal_interval_timeout_sel when doing recal aborts, and should really be 4x rx_dyn_recal_overall_timeout_sel.\r\n\tsmr
#define EI4_RX_DS_BL_TIMEOUT_SEL                           526,  4,  3 // EI4_RX_TIMEOUT_SEL_PG :: selects deskew block lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_CL_TIMEOUT_SEL                              526,  7,  3 // EI4_RX_TIMEOUT_SEL_PG :: selects clock lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_WT_TIMEOUT_SEL                              526, 10,  3 // EI4_RX_TIMEOUT_SEL_PG :: selects wiretest timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_DS_TIMEOUT_SEL                              526, 13,  3 // EI4_RX_TIMEOUT_SEL_PG :: selects deskew  timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_EO_OFFSET_TIMEOUT_SEL                       538,  0,  3 // EI4_RX_TIMEOUT_SEL1_PG :: selects latch offset timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_EO_VREF_TIMEOUT_SEL                         538,  3,  3 // EI4_RX_TIMEOUT_SEL1_PG :: selects  vref adjust watchdog timeout (ei-4 only). \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_EO_CTLE_TIMEOUT_SEL                         538,  6,  3 // EI4_RX_TIMEOUT_SEL1_PG :: selects  ctle ajdust watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_EO_ET_TIMEOUT_SEL                           538, 12,  3 // EI4_RX_TIMEOUT_SEL1_PG :: selects  measure eye watchdog timeout (ei-4 only). \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_EO_FINAL_L2U_TIMEOUT_SEL                    538, 15,  1 // EI4_RX_TIMEOUT_SEL1_PG :: selects final load to unload delay qualification time per step. \r\n\t0:(tap0) 4k ui or 0.425us \r\n\t1:(tap1) 64k ui or 6.8us\r\n\tmbs
#define EI4_RX_FUNC_MODE_TIMEOUT_SEL                       559,  0,  3 // EI4_RX_TIMEOUT_SEL2_PG :: selects functional mode wait timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_RC_SLOWDOWN_TIMEOUT_SEL                     559,  3,  3 // EI4_RX_TIMEOUT_SEL2_PG :: selects recal  slowdown      timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 0   ui or   0us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_PUP_LITE_WAIT_SEL                           559,  6,  2 // EI4_RX_TIMEOUT_SEL2_PG :: how long to wait for analog logic to power up an unused spare lane for recal and repair\r\n\t00:(tap0) 833ps (for sim use only)\r\n\t01:(tap1) 107ns (default value)\r\n\t10:(tap2) 213ns\r\n\t11:(tap3) 427ns\r\n\tsmr
#define EI4_RX_EO_L2U_WD_TIMEOUT_SEL                       559,  9,  3 // EI4_RX_TIMEOUT_SEL2_PG :: selects final load to unload delay watchdog timeout.\r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EI4_RX_FIFO_INITIAL_L2U_DLY                        527,  0,  4 // EI4_RX_FIFO_MODE_PG :: rx fifo initial load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 16-20 ui\r\n\trjr
#define EI4_RX_FIFO_FINAL_L2U_DLY                          527,  4,  4 // EI4_RX_FIFO_MODE_PG :: rx fifo final load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 8-12 ui\r\n\trjr
#define EI4_RX_FIFO_FINAL_L2U_MIN_ERR_THRESH               527, 12,  2 // EI4_RX_FIFO_MODE_PG :: rx fifo error threshold used to qualify the minimum load to unload delay as bad, which is used as the point of reference for adjusting to the final load to unload delay. note that the errors are accumulated across the entire clock group for a length of time selected by rx_eo_final_l2u_timeout_sel. \r\n\t00:(tap0) 8 errors \r\n\t01:(tap1) 16 errors \r\n\t10:(tap2) 128 errors \r\n\t11:(tap3) 255 errors\r\n\tmbs
#define EI4_RX_SLS_CMD_VAL                                 528,  0,  1 // EI4_RX_SLS_STATUS_PG :: current sls command valid\r\n\tsmr
#define EI4_RX_SLS_CMD_ENCODE                              528,  2,  6 // EI4_RX_SLS_STATUS_PG :: current sls command\r\n\t000000:(nop) null operation\r\n\t000001:(shadow_request) driven by the rx side to request shadowing of its receive lane from lane n-1 to lane n\r\n\t000010:(shadow_done) driven by the rx side to signal now receiving lane n-1s data on lane n\r\n\t000011:(shadow_repair_request) driven by the rx side to request shadowing and repair of its receive lane from lane n-1 to n.\r\n\t000100:(shadow_repair_done) driven by the rx side to signal lane n-1 is repaired.\r\n\t000101:(unshadow_request) driven by the rx side to request shadowing of receive lane from lane n+1 to lane n.\r\n\t000110:(unshadow_done) driven by the rx side to signal now receiving lane n+1 data on lane n\r\n\t000111:(unshadow_repair_request) driven by the rx side to request unshadowing and repair of its receive lane from lane n+1 to lane n.\r\n\t001000:(unshadow_repair_done) driven by the rx side to signal lane n+1 is repaired.\r\n\t001001:(sls_exception) driven by the rx side to indicate to the other side of the bus its rx sls lane is broken.\r\n\t001010:(init_done) driven to signal the ctle/dfe/offset (re-)calibration operations have completed (not currently used).\r\n\t001011:(recal_request) driven on recalibration lane x to request a recalibration of its receive recalibration lane y.\r\n\t001100:(recal_running) driven during the status reporting interval of recalibration to indicate recalibration has not completed\r\n\t001101:(recal_done) driven to indicate its recalibration is complete.\r\n\t001110:(recal_failed) driven to indicate recalibration has failed on its receive recalibration lane\r\n\t001111:(recal_abort) abort recalibration.\r\n\t010000:(reserved2) reserved.010001:(reserved3) reserved.\r\n\t010010:(reserved4) reserved.\r\n\t010011:(reserved5) reserved.\r\n\t010100:(reserved6) reserved.\r\n\t010101:(reserved7) reserved.\r\n\t010110:(reserved8) reserved.\r\n\t010111:(reserved9) reserved.\r\n\t011000:(reserved10) reserved.\r\n\t\n011001:(init_ack_done) driven in response to an init_done (not currently used).\r\n\t011010:(reserved11) reserved.\r\n\t011011:(recal_ack) driven on recalibration lane y in response to a recal_request on its receive recalibration lane x\r\n\t011100:(reserved12) reserved.\r\n\t011101:(reserved13) reserved.\r\n\t011110:(reserved14) reserved.\r\n\t011111:(recal_abort_ack) abort recalibration acknowledge.\r\n\t1cdddd: transmits four bits of data dddd command each time clock c toggles.\r\n\tsmr
#define EI4_RX_SLS_ERR_CHK_CNT                             528,  8,  8 // EI4_RX_SLS_STATUS_PG :: error count result for sls error checking mode\r\n\tsmr
#define EI4_RX_PG_FIR_TRAINING_ERROR                       536,  0,  1 // EI4_RX_FIR_TRAINING_PG :: this field is now defunct and is permanently masked in the rx_fir_training_mask_pg fir isolation register.\r\n\tpmt
#define EI4_RX_PG_FIR_STATIC_SPARE_DEPLOYED                536,  1,  1 // EI4_RX_FIR_TRAINING_PG :: a spare lane has been deployed during training to heal a lane that was detected as bad. rx_static_spare_deployed (ssd) will be set after the repair training step if during training either wiretest, deskew, eyeopt or repair has detected one or more bad lanes have been detected. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed and the rx_bad_lane.\r\n\tpmt
#define EI4_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED           536,  2,  1 // EI4_RX_FIR_TRAINING_PG :: a lane has been detected as bad during training but there are no spare lanes available to heal it. this fir will not be set until the repair training step has been run. this is a catastrophic failure for the bus when in mission mode but all training steps will still be run on whatever good lanes there are. rx_static_max_spares_exceeded will be set if wiretest, deskew, eyeopt or repair find the excessive number of bad lanes.\r\n\tpmt
#define EI4_RX_PG_FIR_DYNAMIC_REPAIR_ERROR                 536,  3,  1 // EI4_RX_FIR_TRAINING_PG :: a dynamic repair error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.\r\n\tpmt
#define EI4_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED               536,  4,  1 // EI4_RX_FIR_TRAINING_PG :: a spare lane has been deployed by ecc/crc logic to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.\r\n\tpmt
#define EI4_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED          536,  5,  1 // EI4_RX_FIR_TRAINING_PG :: a lane has been detected as bad by ecc/crc logic but there are no spare lanes to heal it. this is a catastrophic failure for the bus.\r\n\tpmt
#define EI4_RX_PG_FIR_TOO_MANY_BUS_ERRORS                  536,  9,  1 // EI4_RX_FIR_TRAINING_PG :: more than one lane has been detected as having too many errors during functional operation. this is a catastrophic failure for the bus.\r\n\tpmt
#define EI4_RX_PG_FIR_TRAINING_ERROR_MASK                  537,  0,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_training_error.\r\n\tpmt
#define EI4_RX_PG_FIR_STATIC_SPARE_DEPLOYED_MASK           537,  1,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_spare_deployed.\r\n\tpmt
#define EI4_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED_MASK      537,  2,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_max_spares_exceeded\r\n\tpmt.
#define EI4_RX_PG_FIR_DYNAMIC_REPAIR_ERROR_MASK            537,  3,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_repair_error\r\n\tpmt
#define EI4_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED_MASK          537,  4,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_spare_deployed.\r\n\tpmt
#define EI4_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED_MASK     537,  5,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_max_spares_exceeded.\r\n\tpmt
#define EI4_RX_PG_FIR_TOO_MANY_BUS_ERRORS_MASK             537,  9,  1 // EI4_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_too_many_bus_errors.\r\n\tpmt
#define EI4_RX_PG_FIR1_ERRS_FULL_REG                       530,  0, 16 // EI4_RX_FIR1_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EI4_RX_PG_FIR1_ERRS                                530,  0, 14 // EI4_RX_FIR1_PG :: a per-group rxctl register or state machine parity error has occurred.\r\n\tbit0: (par_err_rxctl_regs) rxctl register parity error.\r\n\tbit1: reserved\r\n\tbit2: reserved\r\n\tbit3: (par_err_gcrs_ld_state) rxctl gcr load state machine parity error.\r\n\tbit4: (par_err_gcrs_unld_state) rxctl gcr unload state machine parity error.\r\n\tbit5: (par_err_snd_msg_state)\r\n\tbit6: (par_err_rx_main_init_state) rxctl main init sm parity error.\r\n\tbit7: (par_err_rx_wtm_state) rxctl wiretest main sm parity error.\r\n\tbit8: (par_err_rx_wtr_state)\r\n\tbit9: (par_err_rx_wtl_state)\r\n\tbit10: (par_err_rx_rpr_state)\r\n\tbit11: (par_err_rx_eyeopt_state)\r\n\tbit12: (par_err_dsm_state)\r\n\tbit13: (par_err_rxdsm_state)\r\n\tbit14:(channel_fail) dmi-only\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_PG_REGS                          530,  0,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rxctl registers.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_GCR_BUFF                         530,  1,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EI4_RX_PG_FIR_ERR_GCRS_LD_SM                       530,  3,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr load state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_GCRS_UNLD_SM                     530,  4,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr unload state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_GLB_INIT_SND_MSG_SM              530,  5,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MAIN_INIT_SM                     530,  6,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main init state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_WTM_SM                           530,  7,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main wiretest state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_WTR_SM                           530,  8,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group receiver wiretest state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_WTL_SM                           530,  9,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group lane wiretest state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_RPR_SM                           530, 10,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group repair state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_EYEOPT_SM                        530, 11,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_DSM_SM                           530, 12,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group main deskew state machine.the deskew main state machines function is to control both the driver and receiver sub-machines during block lock, deskew, and prbs scrambler/descrambler synchronization.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_RXDSM_SM                         530, 13,  1 // EI4_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rx deskew state machine.\r\n\tpmt
#define EI4_RX_PG_CHAN_FAIL_RSVD                           530, 14,  1 // EI4_RX_FIR1_PG :: iotk alias: reserved.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR                                  530, 15,  1 // EI4_RX_FIR1_PG :: summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERRS_FULL_REG                       531,  0,  9 // EI4_RX_FIR2_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERRS                                531,  0,  9 // EI4_RX_FIR2_PG :: a per-group register or state machine parity error has occurred.\r\n\tbit0: (err_dyn_rpr_sm) rxctl dynamic repair sm parity error.\r\n\tbit1: (err_sls_hndshk_sm) rxctl sls handshake sm parity error.\r\n\tbit2: (err_rpr_snd_msg_sm) rxctl repair send message sm parity error.\r\n\tbit3: (err_recal_sm) rxctl recal state machine parity error.\r\n\tbit4: reserved.\r\n\tbit5: reserved.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_DYN_RPR_SM                       531,  0,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_SLS_HNDSHK_SM                    531,  1,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic sls state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_DYN_RPR_SND_MSG_SM               531,  2,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic gcr send message state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_RECAL_SM                         531,  3,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group recalibration state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_SLS_ENC_SND_MSG_SM               531,  4,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_GLB_CAL_SND_MSG_SM               531,  5,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group global cal gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              531,  6,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_SLS_RCVY_SM                      531,  7,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair sls recovery state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_PP_REGS                          531,  8,  1 // EI4_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-pack registers.\r\n\tdmb
#define EI4_RX_PG_FIR1_ERRS_MASK_FULL_REG                  532,  0, 16 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for rx_fir1_pg errors.\r\n\tpmt
#define EI4_RX_PG_FIR1_ERRS_MASK                           532,  0, 14 // EI4_RX_FIR1_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_PG_REGS                     532,  0,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl register checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_GCR_BUFF                    532,  1,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr buffer.\r\n\tdmb
#define EI4_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                  532,  3,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr load state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                532,  4,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_GLB_INIT_SND_MSG_SM         532,  5,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl repair state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_MAIN_INIT_SM                532,  6,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr send message state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_WTM_SM                      532,  7,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl main init state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_WTR_SM                      532,  8,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl main wiretest state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_WTL_SM                      532,  9,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl receiver wiretest state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_RPR_SM                      532, 10,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl lane wiretest state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_EYEOPT_SM                   532, 11,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_DSM_SM                      532, 12,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group main deskew state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_RXDSM_SM                    532, 13,  1 // EI4_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rx deskew state machine.\r\n\tpmt
#define EI4_RX_PL_FIR_ERR_MASK                             532, 15,  1 // EI4_RX_FIR1_MASK_PG :: fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERRS_MASK_FULL_REG                  533,  0,  9 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for rx_fir2_pg errors.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERRS_MASK                           533,  0,  9 // EI4_RX_FIR2_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_dyn_rpr_sm) rxctl dynamic repair sm parity error mask.\r\n\tbit1: (mask_sls_hndshk_sm) rxctl sls handshake sm parity error mask.\r\n\tbit2: (mask_rpr_snd_msg_sm) rxctl repair send message sm parity error mask.\r\n\tbit3: (mask_recal_sm) rxctl recal state machine parity error mask.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_DYN_RPR_SM                  533,  0,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_SLS_HNDSHK_SM               533,  1,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group lane repair logic sls state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_DYN_RPR_SND_MSG_SM          533,  2,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic gcr send message state machine.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_RECAL_SM                    533,  3,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group recalibration state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_MASK_SLS_ENC_SND_MSG_SM          533,  4,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_MASK_GLB_CAL_SND_MSG_SM          533,  5,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group global cal gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         533,  6,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_MASK_SLS_RCVY_SM                 533,  7,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls recovery state machine.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_MASK_PP_REGS                     533,  8,  1 // EI4_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group per-pack registers.\r\n\tdmb
#define EI4_RX_PG_FIR1_ERR_INJ_FULL_REG                    534,  0, 16 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EI4_RX_PG_FIR1_ERR_INJ                             534,  0, 14 // EI4_RX_FIR1_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_PG_REGS                      534,  0,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_GCR_BUFF                     534,  1,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.\r\n\tdmb
#define EI4_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                   534,  3,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 534,  4,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_GLB_INIT_SND_MSG_SM          534,  5,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_MAIN_INIT_SM                 534,  6,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main init state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_WTM_SM                       534,  7,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_WTR_SM                       534,  8,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_WTL_SM                       534,  9,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_RPR_SM                       534, 10,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_EYEOPT_SM                    534, 11,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl eye opt state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_DSM_SM                       534, 12,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_RXDSM_SM                     534, 13,  1 // EI4_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERR_INJ_FULL_REG                    535,  0,  9 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EI4_RX_PG_FIR2_ERR_INJ                             535,  0,  9 // EI4_RX_FIR2_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_dyn_rpr_sm) rxctl dynamic repair sm parity error inject.\r\n\tbit1: (inj_sls_hndshk_sm) rxctl sls handshake sm parity error inject.\r\n\tbit2: (inj_rpr_snd_msg_sm) rxctl repair send message sm parity error inject.\r\n\tbit3: (inj_recal_sm) rxctl recal state machine parity error inject.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_DYN_RPR_SM                   535,  0,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on per-group lane repair logic state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_SLS_HNDSHK_SM                535,  1,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group lane repair logic sls state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_DYN_RPR_SND_MSG_SM           535,  2,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group dynamic lane repair logic gcr send message state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_RECAL_SM                     535,  3,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group recalibration state machine parity checker.\r\n\tpmt
#define EI4_RX_PG_FIR_ERR_INJ_SLS_ENC_SND_MSG_SM           535,  4,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls encode gcr send message state machine parity checker.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_INJ_GLB_CAL_SND_MSG_SM           535,  5,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group global cal gcr send message state machine parity checker.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          535,  6,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group stat repair gcr send message state machine parity checker.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_INJ_SLS_RCVY_SM                  535,  7,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls recovery state machine parity checker.\r\n\tjgr
#define EI4_RX_PG_FIR_ERR_INJ_PP_REGS                      535,  8,  1 // EI4_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group per pack register checker.\r\n\tdmb
#define EI4_RX_LANE_BAD_VEC_0_15                           539,  0, 16 // EI4_RX_LANE_BAD_VEC_0_15_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).to be clear, the bad_lane vector is only updated during training.  it will not reflect bad lanes found post training during dynamic repair or dynamic recal.  for that, you need to read the [rx,tx]_bad_lane[1,2]_gcrmsg registers.  to calculate what you want to know, you need five registers:\r\n\t rx_bad_lane1_gcrmsg\r\n\t rx_bad_lane2_gcrmsg\r\n\t rx_bad_lane_code_gcrmsg\r\n\t rx_sls_lane_gcrmsg\r\n\t rx_wtr_max_bad_lanes\r\n\tin general, if the spares deployed fir goes on, and the bad_lane_code is a 1, then the newly spared lane resides in the rx_bad_lane1_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 2, then the newly spared lane resides in the rx_bad_lane2_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 3, then the newly spared lane resides in the rx_sls_lane_gcrmsg register. that might be enough information for what you want to know, trying to keep the answer very general.  at the moment, this case where both the spare deployed and max spares exceeded both come on at the same time, is for the edi where a third bad lane has been found and we have chosen to use the sls lane as a third spare. edi normally only has two spare lanes. in that case, i first set the spare deployed fir as the sls lane is being used as a third spare. but then a few cycles later, i set the max spares exceeded because i no longer have an sls lane and cant finish my sls repair handshake.\r\n\trjr
#define EI4_RX_LANE_BAD_VEC_16_31                          540,  0, 16 // EI4_RX_LANE_BAD_VEC_16_31_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).\r\n\trjr
#define EI4_RX_LANE_DISABLED_VEC_0_15                      541,  0, 16 // EI4_RX_LANE_DISABLED_VEC_0_15_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EI4_RX_LANE_DISABLED_VEC_16_31                     542,  0, 16 // EI4_RX_LANE_DISABLED_VEC_16_31_PG :: lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EI4_RX_LANE_SWAPPED_VEC_0_15                       543,  0, 16 // EI4_RX_LANE_SWAPPED_VEC_0_15_PG :: wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EI4_RX_LANE_SWAPPED_VEC_16_31                      544,  0, 16 // EI4_RX_LANE_SWAPPED_VEC_16_31_PG :: wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EI4_RX_MAIN_INIT_STATE                             545,  0,  4 // EI4_RX_INIT_STATE_PG :: main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused\r\n\trjr
#define EI4_RX_WTM_STATE                                   546,  0,  5 // EI4_RX_WIRETEST_STATE_PG :: main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail \r\n\trjr
#define EI4_RX_WTR_STATE                                   546,  5,  4 // EI4_RX_WIRETEST_STATE_PG :: receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused\r\n\trjr
#define EI4_RX_WTL_STATE                                   546, 11,  5 // EI4_RX_WIRETEST_STATE_PG :: lane wiretest sub state machine current state (rjr)\r\n\tx00: idle\r\n\tx01: wait 1st long transition\r\n\tx02: wait 2nd long transition\r\n\tx03: wait short transition\r\n\tx04: wait transition from pn=01\r\n\tx05: wait transition from 10\r\n\tx06: wait transition from 00\r\n\tx07: wait transition from 11\r\n\tx10: good-no swap\r\n\tx11: bad-n=1-no swap\r\n\tx12: bad-n=0-no swap\r\n\tx13: bad-p=1-no swap\r\n\tx14: bad-p=0-no swap\r\n\tx15: bad-p or n floating\r\n\tx16: bad-pn=00\r\n\tx17: bad-pn=11\r\n\tx18: good--swapped\r\n\tx19: bad-n=1-swapped\r\n\tx1a: bad-n=0-swapped\r\n\tx1b: bad-p=1-swapped\r\n\tx1c: bad-p=0-swapped\r\n\tx1d: bad-pn=10\r\n\tx1e: bad-pn=01\r\n\tx1f: bad-unknown failure\r\n\trjr
#define EI4_RX_WTL_DONE_ALIAS                              546, 11,  1 // EI4_RX_WIRETEST_STATE_PG :: iotk alias: wiretest lane state machine done indication(rjr):\r\n\t0: idling or running.\r\n\t1: done\r\n\trjr
#define EI4_RX_WTL_P_N_SWAP_ALIAS                          546, 12,  1 // EI4_RX_WIRETEST_STATE_PG :: iotk alias: for wiretest lane state machine p/n wire swap indication(rjr):\r\n\t0: lane p/n wires not swapped.\r\n\t1: lane p/n wires swapped\r\n\t:may have different meaning if fault code is non-zero\r\n\trjr
#define EI4_RX_WTL_FAULT_CODE_ALIAS                        546, 13,  3 // EI4_RX_WIRETEST_STATE_PG :: iotk alias: for wiretest lane state machine fault code(rjr):\r\n\t000: lane good.\r\n\t001: lane n wire stuck at 1.\r\n\t010: lane n wire stuck at 0.\r\n\t011: lane p wire stuck at 1\r\n\t100: lane p wire stuck at 0\r\n\t101: lane n or p wire floating: swap status invalid.\r\n\t110: lane p and n stuck--00 if swap=0, 10 if swap=1, swap status invalid.\r\n\t111: p and n stuck at 1 if swap=0 unknown failure if swap=1.\r\n\trjr
#define EI4_RX_WTR_CUR_LANE                                547,  0,  5 // EI4_RX_WIRETEST_LANEINFO_PG :: wiretest current lane under test\r\n\trjr
#define EI4_RX_WTR_MAX_BAD_LANES                           547,  5,  5 // EI4_RX_WIRETEST_LANEINFO_PG :: wiretest max number of bad lanes allowed per clk group\r\n\trjr\r\n\talso static repair, dynamic repair & recal max number of bad lanes per rx bus (note: should match tx side)\r\n\tsmr
#define EI4_RX_WTR_BAD_LANE_COUNT                          547, 11,  5 // EI4_RX_WIRETEST_LANEINFO_PG :: wiretest current number of bad lanes in this clk group\r\n\trjr
#define EI4_RX_WT_PREV_DONE_GCRMSG                         548,  0,  1 // EI4_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has completed wiretest\r\n\tjfg
#define EI4_RX_WT_ALL_DONE_GCRMSG                          548,  1,  1 // EI4_RX_WIRETEST_GCRMSG_PG :: gcr message: all clk groups have completed wiretest\r\n\tjfg
#define EI4_RX_CD_PREV_DONE_GCRMSG                         548,  2,  1 // EI4_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has finished sending & receiving 4 clk/data sls commands\r\n\tsmr
#define EI4_RX_CD_ALL_DONE_GCRMSG                          548,  3,  1 // EI4_RX_WIRETEST_GCRMSG_PG :: gcr message: all clk groups have completed sending & receiving 4 clk/data sls commands.  in the case of the slave side, also the final nop has been received.\r\n\tsmr
#define EI4_RX_CNTLS_PREV_LDED_GCRMSG                      548,  4,  1 // EI4_RX_WIRETEST_GCRMSG_PG :: gcr message: previous clk group has finished updating rx sls/bad lane & repair controls\r\n\tsmr
#define EI4_RX_WT_CU_PLL_PGOOD                             571,  0,  1 // EI4_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset\r\n\tjfg
#define EI4_RX_WT_CU_PLL_RESET                             571,  1,  1 // EI4_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing\r\n\tjfg
#define EI4_RX_WT_CU_PLL_PGOODDLY                          571,  2,  3 // EI4_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll pgood delay selects length of reset period after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking period \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset\r\n\tjfg
#define EI4_RX_WT_CU_PLL_LOCK                              571,  5,  1 // EI4_RX_WIRETEST_PLL_CNTL_PG :: rx pll/dll locked\r\n\tjfg
#define EI4_RX_WT_PLL_REFCLKSEL                            571,  6,  1 // EI4_RX_WIRETEST_PLL_CNTL_PG :: select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock\r\n\tdmb
#define EI4_RX_DLL1_CAL_GOOD                               452,  0,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 1 calibration has completed successfully and clock is properly aligned. this remains static (not dynamically updated) unless the initialization process requests either a new calibration or a fine update.\r\n\tjfg
#define EI4_RX_DLL1_CAL_ERROR                              452,  1,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 1 calibration has failed to pass coarse delay or coarse vreg calibration and clock is not aligned.\r\n\tjfg
#define EI4_RX_DLL1_CAL_ERROR_FINE                         452,  2,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 1 calibration has failed to pass fine vreg calibration on either reset or on update and clock is not aligned.\r\n\tjfg
#define EI4_RX_DLL1_CAL_SKIP                               452,  3,  2 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 1 calibration skip steps\r\n\tif any steps are skipped respective manual settings must be supplied. fine cal cannot be skipped.\r\n\t00:(default) skip no steps\r\n\t01:(skip_delay) skip coarse delay cal only\r\n\t10:(skip_vreg) skip coarse vreg cal only\r\n\t11:(skip_both) skip both coarse vreg and coarse delay cal\r\n\tjfg
#define EI4_RX_DLL1_COARSE_ADJ_BY2                         452,  5,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 1 calibration coarse delay backoff tweak\r\n\twhen coarse delay is calibrated normally 1 delay step is removed to assist finding the edge for fine delay. this allows for 2 steps adjustment.\r\n\t0:(default) normal coarse delay adjust\r\n\t1:(minus2) adjust coarse delay by 2.\r\n\tjfg
#define EI4_RX_DLL2_CAL_GOOD                               452,  8,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 2 calibration has completed successfully and clock is properly aligned. this remains static (not dynamically updated) unless the initialization process requests either a new calibration or a fine update.\r\n\tjfg
#define EI4_RX_DLL2_CAL_ERROR                              452,  9,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 2 calibration has failed to pass coarse delay or coarse vreg calibration and clock is not aligned.\r\n\tjfg
#define EI4_RX_DLL2_CAL_ERROR_FINE                         452, 10,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 2 calibration has failed to pass fine vreg calibration on either reset or on update and clock is not aligned.\r\n\tjfg
#define EI4_RX_DLL2_CAL_SKIP                               452, 11,  2 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 2 calibration skip steps\r\n\tif any steps are skipped respective manual settings must be supplied. fine cal cannot be skipped.\r\n\t00:(default) skip no steps\r\n\t01:(skip_delay) skip coarse delay cal only\r\n\t10:(skip_vreg) skip coarse vreg cal only\r\n\t11:(skip_both) skip both coarse vreg and coarse delay cal\r\n\tjfg
#define EI4_RX_DLL2_COARSE_ADJ_BY2                         452, 13,  1 // EI4_RX_DLL_CAL_CNTL_PG :: rx dll 2 calibration coarse delay backoff tweak\r\n\twhen coarse delay is calibrated normally 1 delay step is removed to assist finding the edge for fine delay. this allows for 2 steps adjustment.\r\n\t0:(default) normal coarse delay adjust\r\n\t1:(minus2) adjust coarse delay by 2.\r\n\tjfg
#define EI4_RX_DLL1_COARSE_EN                              453,  0,  6 // EI4_RX_DLL1_SETPOINT1_PG :: rx dll 1 calibration result/setting for coarse delay adjust\r\n\tjfg
#define EI4_RX_DLL1_VREG_DAC_COARSE                        453,  7,  7 // EI4_RX_DLL1_SETPOINT1_PG :: rx dll 1 calibration result/setting for coarse vreg dac\r\n\tjfg
#define EI4_RX_DLL1_VREG_DAC_LOWER                         454,  0, 15 // EI4_RX_DLL1_SETPOINT2_PG :: rx dll 1 calibration result/setting for fine vreg dac lower\r\n\tthermometer coded 1x strength component.\r\n\tjfg
#define EI4_RX_DLL1_VREG_DAC_UPPER                         455,  0, 15 // EI4_RX_DLL1_SETPOINT3_PG :: rx dll 1 calibration result/setting for fine vreg dac upper\r\n\tthermometer coded 16x strength component.\r\n\tjfg
#define EI4_RX_DLL2_COARSE_EN                              456,  0,  6 // EI4_RX_DLL2_SETPOINT1_PG :: rx dll 2 calibration result/setting for coarse delay adjust\r\n\tjfg
#define EI4_RX_DLL2_VREG_DAC_COARSE                        456,  7,  7 // EI4_RX_DLL2_SETPOINT1_PG :: rx dll 2 calibration result/setting for coarse vreg dac\r\n\tjfg
#define EI4_RX_DLL2_VREG_DAC_LOWER                         457,  0, 15 // EI4_RX_DLL2_SETPOINT2_PG :: rx dll 2 calibration result/setting for fine vreg dac lower\r\n\tthermometer coded 1x strength component.\r\n\tjfg
#define EI4_RX_DLL2_VREG_DAC_UPPER                         458,  0, 15 // EI4_RX_DLL2_SETPOINT3_PG :: rx dll 2 calibration result/setting for fine vreg dac upper\r\n\tthermometer coded 16x strength component.\r\n\tjfg
#define EI4_RX_DLL_DLL_FILTER_LENGTH                       459,  0,  3 // EI4_RX_DLL_FILTER_MODE_PG :: rx dll phase detector digital filter select\r\n\tthe dll delay calibration digitally samples a lead/lag clock edge detector. this filter specifies the samples to take for different levels of filtering in 8 increments of 2*n. more filtering means longer detect time and the minimum samples must be 2 times rx_dll_dll_lead_lag_separation + one.\r\n\t000:(default) 4 samples\r\n\t001:(eighta) 8 samples\r\n\t010:(eightb) 8 samples\r\n\t011:(sixteen) 16 samples\r\n\t100:(thirtytwo) 32 samples\r\n\t101:(sixtyfour) 64 samples\r\n\t110:(one28) 128 samples\r\n\t111:(two56) 256 samples. errata: do not use in dd1 revs. dd2 is fixed.\r\n\tjfg
#define EI4_RX_DLL_DLL_LEAD_LAG_SEPARATION                 459,  4,  3 // EI4_RX_DLL_FILTER_MODE_PG :: rx dll phase detector hysteresis select\r\n\tthe dll phase detector filters the clock lead/lag indicator. this specifies hysteresis separation between a valid lead and valid lag filter sample count in total number of samples. do not set this higher than 2/3 of rx_dll_dll_filter_length samples - one\r\n\tjfg
#define EI4_RX_DLL_VREG_CON                                460,  0,  1 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll vreg kprime voltage level adjust\r\n\t0:(normal) normal\r\n\t1:(adjust) tbd\r\n\tjfg
#define EI4_RX_DLL_VREG_COMPCON                            460,  1,  3 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll vreg chicken switch for filter cap\r\n\tthermometer coded value default is 0.\r\n\tjfg
#define EI4_RX_DLL_VREG_REF_SEL                            460,  4,  3 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll vreg active voltage range adjust\r\n\tthis is primarily for experimentation.100 is default. others tbd.\r\n\tjfg
#define EI4_RX_DLL1_VREG_DRVCON                            460,  7,  3 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll 1 fallback control for vreg drive strength\r\n\tthermometer coded value default is 0.\r\n\tjfg
#define EI4_RX_DLL2_VREG_DRVCON                            460, 10,  3 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll 2 fallback control for vreg drive strength\r\n\tthermometer coded value default is 0.\r\n\tjfg
#define EI4_RX_DLL_VREG_DAC_PULLUP                         460, 13,  1 // EI4_RX_DLL_ANALOG_TWEAKS_PG :: rx dll vreg dac pullup chicken switch\r\n\tadjust dac range for bad hardware.\r\n\t0:(normal) normal\r\n\t1:(adjust) enable pullup\r\n\tjfg
#define EI4_RX_DESKEW_SEQ_GCRMSG                           549,  0,  3 // EI4_RX_DESKEW_GCRMSG_PG :: gcr message: rx deskew sequencer gcr messages\r\n\t000:(dsprevdeskewed) indicate prior group deskewed.\r\n\t001:(dsalldeskewed) indicate all groups deskewed.\r\n\t010:(dsprevdone) indicate prior group completed deskew.\r\n\t011:(dsalldone) indicate all groups completed deskew.\r\n\t100:(dsprevskew) transmit skew values from prior group.\r\n\t101:(dsmaxskew) transmit max skew values to all groups.\r\n\t110:(unused) unused.\r\n\t111:(dsnomsg) no message.\r\n\trjr
#define EI4_RX_DESKEW_SKMIN_GCRMSG                         549,  4,  6 // EI4_RX_DESKEW_GCRMSG_PG :: gcr message: min skew value for deskew sequence.\r\n\trjr
#define EI4_RX_DESKEW_SKMAX_GCRMSG                         549, 10,  6 // EI4_RX_DESKEW_GCRMSG_PG :: gcr message: max skew value for deskew sequence.\r\n\trjr
#define EI4_RX_DSM_STATE                                   550,  2,  6 // EI4_RX_DESKEW_STATE_PG :: main deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init tx fifo\r\n\tx02: master driver patt b\r\n\tx03:block lock\r\n\tx04: check skew\r\n\tx05:send skew to other groups\r\n\tx06: wait for max skew message\r\n\tx07: check max skew\r\n\tx08: deskew group\r\n\tx09: send deskewed message\r\n\tx0a: wait for all deskewd message\r\n\tx0b: deskew group\r\n\tx0c: drive prbs sync\r\n\tx0d: wait for prbs synced\r\n\tx0e: send done message\r\n\tx0f: wait for all done message\r\n\tx10: slave drive patt a\r\n\tx11: enable prbs sync checking\r\n\t:x12-x1e: unused\r\n\tx1f: deskew done\r\n\tx20-x22: unused\r\n\tx23: block lock failed\r\n\tx24: group skew measure fail--timeout\r\n\tx25: group skew fail-rxdsm fail\r\n\tx25: bus deskew fail\r\n\tx27: max skew in group fail\r\n\tx28: group deskew timeout fail\r\n\tx29: unused\r\n\tx2a: bus deskew timeout fail\r\n\tx2b-x2c: unused\r\n\tx2d: wait prbs sync timeout fail\r\n\tx2e: timeout while sending done message fail\r\n\tx2f: timeout waiting for bus deskew all done message fail\r\n\tx30-x3f: unused\r\n\trjr
#define EI4_RX_RXDSM_STATE                                 550,  9,  7 // EI4_RX_DESKEW_STATE_PG :: rx deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init rx fifo\r\n\tx02: start block lock\r\n\tx03:read block lock status\r\n\tx04: check block lock status\r\n\tx05:check lane valid\r\n\tx06: check max lane count\r\n\tx07: lane block lock status\r\n\tx08: write bad lane block lock\r\n\tx09: block lock done\r\n\tx0a: start check skew\r\n\tx0b: read skew status\r\n\tx0c: check skew status\r\n\tx0d: check valid lanes for skew\r\n\tx0e: check max lane count\r\n\tx0f: read first valid lane skew status\r\n\tx10: write bad skew status\r\n\tx11: check lane count\r\n\t:x12: check other lanes valid\r\n\tx13: read lane skew status\r\n\tx14: write lane bad skew stus\r\n\tx15: send rx skew valid to main deskew machine\r\n\tx16: check lane valid for deskew\r\n\tx17: read skew for deskewing\r\n\tx18:  write new rx fifo load-unload delay\r\n\tx19: write bad skew status\r\n\tx1a check last lane for done\r\n\tx1bb: clear skew status\r\n\tx1c: read global skew status\r\n\tx1d: check global skew status\r\n\tx1e: check lane valid for deskew check\r\n\tx1f: read lane deskew status\r\n\tx20: check lane count for done\r\n\tx21: stop checking skew\r\n\tx22: wait for check prbs sync signal\r\n\tx23: read prbs sync status\r\n\tx24: check prbs sync status\r\n\tx25: prbs synced/deskew done\r\n\tx26: clear deskew control\r\n\tx27: write bad deskew status\r\n\tx28-4d: unused\r\n\tx4e: skew error oddbadd fail\r\n\tx4f-7f: unused\r\n\trjr
#define EI4_RX_DESKEW_MAX_LIMIT                            551,  0,  6 // EI4_RX_DESKEW_MODE_PG :: maximum deskewable skew fail threshold \r\n\t000000:   0 ui \r\n\t000001:   2 ui \r\n\t000010:   4 ui \r\n\t000011:   6 ui \r\n\t000100:   8 ui \r\n\t000101:  10 ui \r\n\t000110:  12 ui \r\n\t000111:  14 ui \r\n\t001000:  16 ui \r\n\t001001:  18 ui \r\n\t001010:  20 ui \r\n\t001011:  22 ui > ei-4 max \r\n\t001100:  24 ui > ei-4 max \r\n\t001101:  26 ui > ei-4 max \r\n\t001110:  28 ui > ei-4 max \r\n\t001111:  30 ui > ei-4 max \r\n\t010000:  32 ui > ei-4 max \r\n\t010001:  34 ui > ei-4 max \r\n\t010010:  36 ui > ei-4 max \r\n\t010011:  38 ui > ei-4 max \r\n\t010100:  40 ui > ei-4 max \r\n\t010101:  42 ui > ei-4 max \r\n\t010110:  44 ui > ei-4 max \r\n\t010111:  46 ui > ei-4 & edi max \r\n\t011000:  48 ui > ei-4 & edi max \r\n\t011001:  50 ui > ei-4 & edi max \r\n\t011010:  52 ui > ei-4 & edi max \r\n\t011011:  54 ui > ei-4 & edi max \r\n\t011100:  56 ui > ei-4 & edi max \r\n\t011101:  58 ui > ei-4 & edi max \r\n\t011110:  60 ui > ei-4 & edi max \r\n\t011111:  62 ui > ei-4 & edi max \r\n\t100000:  64 ui > ei-4 & edi max \r\n\t100001:  66 ui > ei-4 & edi max \r\n\t100010:  68 ui > ei-4 & edi max \r\n\t100011:  70 ui > ei-4 & edi max \r\n\t100100:  72 ui > ei-4 & edi max \r\n\t100101:  74 ui > ei-4 & edi max \r\n\t100110:  76 ui > ei-4 & edi max \r\n\t100111:  78 ui > ei-4 & edi max \r\n\t101000:  80 ui > ei-4 & edi max \r\n\t101001:  82 ui > ei-4 & edi max \r\n\t101010:  84 ui > ei-4 & edi max \r\n\t101011:  86 ui > ei-4 & edi max \r\n\t101100:  88 ui > ei-4 max \r\n\t101101:  90 ui > ei-4 max \r\n\t101110:  92 ui > ei-4 max \r\n\t101111:  94 ui > ei-4 max \r\n\t110000:  96 ui > ei-4 max \r\n\t110001:  98 ui > ei-4 max \r\n\t110010: 100 ui > ei-4 max \r\n\t110011: 102 ui > ei-4 max \r\n\t110100: 104 ui > ei-4 max \r\n\t110101: 106 ui > ei-4 max \r\n\t110110: 108 ui > ei-4 max \r\n\t110111: 110 ui > ei-4 max \r\n\t111000: 112 ui > ei-4 & edi max \r\n\t111001: 114 ui > ei-4 & edi max \r\n\t111010: 116 ui > ei-4 & edi max \r\n\t111011: 118 ui > ei-4 & edi max \r\n\t111100: 120 ui > ei-4 & edi max \r\n\t111101: 122 ui > ei-4 & edi max \r\n\t111110: 124 ui > ei-4 & edi max \r\n\t111111: 126 ui > ei-4 & edi max \r\n\trjr
#define EI4_RX_DESKEW_MINSKEW_GRP                          552,  0,  6 // EI4_RX_DESKEW_STATUS_PG :: deskew per-group raw skew min\r\n\trjr
#define EI4_RX_DESKEW_MAXSKEW_GRP                          552,  6,  6 // EI4_RX_DESKEW_STATUS_PG :: deskew per-group raw skew max\r\n\trjr
#define EI4_RX_BAD_LANE1_GCRMSG                            553,  0,  7 // EI4_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane one in relation to the entire rx bus\r\n\tsmr
#define EI4_RX_BAD_LANE2_GCRMSG                            553,  7,  7 // EI4_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: encoded bad lane two in relation to the entire rx bus\r\n\tsmr
#define EI4_RX_BAD_LANE_CODE_GCRMSG                        553, 14,  2 // EI4_RX_BAD_LANE_ENC_GCRMSG_PG :: gcr message: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EI4_RX_RPR_STATE                                   554,  0,  6 // EI4_RX_STATIC_REPAIR_STATE_PG :: static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state\r\n\tsmr
#define EI4_RX_FUNC_MODE_STATE                             585,  0,  4 // EI4_RX_FUNC_STATE_PG :: functional mode state machine(rjr):\r\n\trjr
#define EI4_RX_TX_BUS_WIDTH                                555,  0,  7 // EI4_RX_TX_BUS_INFO_PG :: tx bus width\r\n\tsmr
#define EI4_RX_RX_BUS_WIDTH                                555,  7,  7 // EI4_RX_TX_BUS_INFO_PG :: rx bus width\r\n\tsmr
#define EI4_RX_SLS_LANE_GCRMSG                             556,  0,  7 // EI4_RX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: encoded sls lane in relation to the entire rx bus\r\n\tsmr
#define EI4_RX_SLS_LANE_VAL_GCRMSG                         556,  7,  1 // EI4_RX_SLS_LANE_ENC_GCRMSG_PG :: gcr message: rx sls lane valid\r\n\tsmr
#define EI4_RX_FENCE                                       557,  0,  1 // EI4_RX_FENCE_PG :: rx & tx fence bit\r\n\t0:(unfenced) functional data is being driven to & front nest logic\r\n\t1:(fenced) functional data is gated to zeroes to & from nest logic. also indicates that link training not yet complete.\r\n\tsmr
#define EI4_RX_TERM_TEST_MODE                              558,  0,  1 // EI4_RX_TERM_PG :: termination segment test mode\r\n\t0:(normal) mission mode enable\r\n\t1:(term_test) termination segment test mode\r\n\tmbs
#define EI4_RX_TERM_MODE_ENC                               558,  3,  5 // EI4_RX_TERM_PG :: slice enable for pfet/nfet pairs for termination mode.  bits 0:3 determine how many 240ohm pairs to enable, out of 14.  bit 4 enables a half-strength 480ohm pfet/nfet pair, and also controls whether that pair is enabled in test mode.\r\n\tmbs
#define EI4_RX_IREF_BC                                     560,  4,  3 // EI4_RX_MISC_ANALOG_PG :: bias code for the iref macros on the rx side. all eight 3 bit codes enable current out. the cml voltage swings of the output current will vary with this code.\r\n\tcpg
#define EI4_RX_IREF_BYPASS                                 560,  7,  1 // EI4_RX_MISC_ANALOG_PG :: bypass for the ei4 iref macro. this bypasses the feedback controller to revert back to a resistor bias (chicken switch).\r\n\tcpg
#define EI4_RX_DYN_RPR_STATE                               561,  2,  6 // EI4_RX_DYN_RPR_PG :: dynamic repair main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_rpr_state\r\n\tsmr
#define EI4_RX_SLS_HNDSHK_STATE                            561,  8,  8 // EI4_RX_DYN_RPR_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_hndshk_state\r\n\tsmr
#define EI4_RX_DYN_RPR_REQ_GCRMSG                          562,  0,  1 // EI4_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc tallying logic has a dynamic repair request\r\n\tsmr
#define EI4_RX_DYN_RPR_LANE2RPR_GCRMSG                     562,  1,  7 // EI4_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc tallying logic bad lane to repair\r\n\tsmr
#define EI4_RX_DYN_RPR_IP_GCRMSG                           562,  8,  1 // EI4_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc bad lane repair in progress\r\n\tsmr
#define EI4_RX_DYN_RPR_COMPLETE_GCRMSG                     562,  9,  1 // EI4_RX_DYN_RPR_GCRMSG_PG :: gcr message: crc/ecc bad lane repaired\r\n\tsmr
#define EI4_RX_DYN_RPR_BAD_LANE_MAX                        563,  0,  7 // EI4_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: max number of times a lane can be found bad before repaired\r\n\tsmr
#define EI4_RX_DYN_RPR_ERR_CNTR1_DURATION                  563,  7,  4 // EI4_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: duration the lane error counter1 can run before being cleared (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EI4_RX_DYN_RPR_CLR_ERR_CNTR1                       563, 11,  1 // EI4_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: firmware-based clear of lane error counter1 register\r\n\tsmr
#define EI4_RX_DYN_RPR_DISABLE                             563, 12,  1 // EI4_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: when set, disables dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2)\r\n\tsmr
#define EI4_RX_DYN_RPR_ENC_BAD_DATA_LANE_WIDTH             563, 13,  3 // EI4_RX_DYN_RPR_ERR_TALLYING1_PG :: crc/ecc dynamic repair: width of the enc_bad_data_lane vector used to determine number of 1s in clear code\r\n\tsmr
#define EI4_RX_EYE_OPT_STATE                               583,  0,  8 // EI4_RX_EO_RECAL_PG :: common edi/ei4 eye optimizaton state machine \r\n\t00000000: idle \r\n\t00000001: init latch offset cal done \r\n\t00000010: vref/dcd cal done \r\n\t00000011: vga done \r\n\t00000100: unused \r\n\t00000101: unused \r\n\t00000110: unused \r\n\t00000111: ctle done \r\n\t00001000: h1ap adjust done \r\n\t00001001: ddc done \r\n\t00001010: measure eye width done \r\n\t00001011: final l2u adjust done \r\n\t00001100: unused \r\n\t00001101: results check done \r\n\t00001110: eye opt all done \r\n\t00001111: unused \r\n\t00010000: start latch offset cal \r\n\t00010001: start latch offset cal 0 \r\n\t00010010: read latch offset cal 0 status \r\n\t00010011: check latch offset cal 0 status \r\n\t00010100: start latch offset cal 1 \r\n\t00010101: read latch offset cal 1 status \r\n\t00010110: check latch offset cal 1 status \r\n\t00010111: bist latch offset cal done \r\n\t00011000: unused \r\n\t00011001: unused \r\n\t00011010: unused \r\n\t00011011: unused \r\n\t00011100: unused \r\n\t00011101: unused \r\n\t00011110: unused \r\n\t00011111: unused \r\n\t00100000: start vref cal \r\n\t00100001: start vref servo \r\n\t00100010: read vref servo status \r\n\t00100011: check vref servo status \r\n\t00100100: start dcd adjust servo \r\n\t00100101: read dcd adjust servo status \r\n\t00100110: check dcd adjust servo status \r\n\t00100111: unused \r\n\t00101000: unused \r\n\t00101001: unused \r\n\t00101010: unused \r\n\t00101011: unused \r\n\t00101100: unused \r\n\t00101101: unused \r\n\t00101110: unused \r\n\t00101111: unused \r\n\t00110000: vga start-clear done flags \r\n\t00110001: vga measure ape/apo \r\n\t00110010: vga read ape/apo status \r\n\t00110011: vga check ape/apo status \r\n\t00110100: vga measure ane/ano \r\n\t00110101: vga read ane/ano status \r\n\t00110110: vga check ane/ano status \r\n\t00110111: vga measure ape dfe \r\n\t00111000: vga read ape dfe status \r\n\t00111001: vga check ape dfe status \r\n\t00111010: vga measure ane dfe \r\n\t00111011: vga read ane dfe status \r\n\t00111100: vga check ane dfe status \r\n\t00111101: vga measure apo dfe \r\n\t00111110: vga read apo dfe status \r\n\t00111111: vga check apo dfe status \r\n\t01000000: vga measure ano dfe \r\n\t01000001: vga read ano dfe status \r\n\t01000010: vga check ano dfe status \r\n\t01000011: vga measure amin no dfe \r\n\t01000100: vga read amin no dfe status \r\n\t01000101: vga check amin no dfe status \r\n\t01000110: vga measure amin dfe \r\n\t01000111: vga read amin dfe status \r\n\t01001000: vga check amin dfestatus \r\n\t01001001: vga clear lane address \r\n\t01001010: vga check lane valid \r\n\t01001011: vga read rx amp cntl \r\n\t01001100: vga read rx amp values \r\n\t01001101: vga read ape and apo \r\n\t01001110: vga read ane and ano \r\n\t01001111: vga read amine and amino \r\n\t01010000: vga check offset \r\n\t01010001: vga check amax \r\n\t01010010: vga write vga done control \r\n\t01010011: vga write all done status \r\n\t01010100: vga write vga adjust value \r\n\t01010101: vga check done \r\n\t01010110: unused \r\n\t01010111: unused \r\n\t01011000: unused \r\n\t01011001: unused \r\n\t01011010: unused \r\n\t01011011: unused \r\n\t01011100: unused \r\n\t01011101: unused \r\n\t01011110: unused \r\n\t01011111: unused \r\n\t01100000: unused \r\n\t01100001: unused \r\n\t01100010: unused \r\n\t01100011: unused \r\n\t01100100: unused \r\n\t01100101: unused \r\n\t01100110: unused \r\n\t01100111: unused \r\n\t01101000: unused \r\n\t01101001: unused \r\n\t01101010: unused \r\n\t01101011: unused \r\n\t01101100: unused \r\n\t01101101: unused \r\n\t01101110: unused \r\n\t01101111: unused \r\n\t01110000: ctle start \r\n\t01110001: ctle bump left \r\n\t01110010: ctle read bump left status \r\n\t01110011: ctle check bump left status \r\n\t01110100: ctle start servo \r\n\t01110101: ctle read servo status \r\n\t01110110: ctle check servo status \r\n\t01110111: ctle bump right \r\n\t01111000: ctle read bump right status \r\n\t01111001: ctle check bump rightstatus \r\n\t01111010: unused \r\n\t01111011: unused \r\n\t01111100: unused \r\n\t01111101: unused \r\n\t01111110: unused \r\n\t01111111: unused \r\n\t10000000: h1ap tweak start \r\n\t10000001: h1ap tweak run servo \r\n\t10000010: h1ap tweak read servo status \r\n\t10000011: h1ap tweak check servo status \r\n\t10000100: unused \r\n\t10000101: unused \r\n\t10000110: unused \r\n\t10000111: unused \r\n\t10001000: unused \r\n\t10001001: unused \r\n\t10001010: unused \r\n\t10001011: unused \r\n\t10001100: unused \r\n\t10001101: unused \r\n\t10001110: unused \r\n\t10001111: unused \r\n\t10010000: ddc start \r\n\t10010001: ddc run servo \r\n\t10010010: ddc read servo status \r\n\t10010011: ddc check servo status \r\n\t10010100: ddc check clear counter \r\n\t10010101: ddc check fly state \r\n\t10010110: ddc check lane \r\n\t10010111: ddc read  lane status \r\n\t10011000: ddc check lane status \r\n\t10011001: ddc write bad ddc \r\n\t10011010: ddc check if all done \r\n\t10011011: unused \r\n\t10011100: unused \r\n\t10011101: unused \r\n\t10011110: unused \r\n\t10011111: unused \r\n\t10100000: eye measure start \r\n\t10100001: eye measure start edge track \r\n\t10100010: eye measure read edge track status \r\n\t10100011: eye measure check edge track status \r\n\t10100100: eye measure fly state \r\n\t10100101: eye measure start eye track \r\n\t10100110: eye measure read eye track status \r\n\t10100111: eye measure check eye track status \r\n\t10101000: unused \r\n\t10101001: unused \r\n\t10101010: unused \r\n\t10101011: unused \r\n\t10101100: unused \r\n\t10101101: unused \r\n\t10101110: unused \r\n\t10101111: unused \r\n\t10110000: final l2u set sls checkers \r\n\t10110001: final l2u run err check timer \r\n\t10110010: final l2u dec l2u delay \r\n\t10110011: final l2u inc prbs \r\n\t10110100: final l2u inc l2u delay \r\n\t10110101: final l2u dec prbs \r\n\t10110110: unused \r\n\t10110111: final l2u run err check timer \r\n\t10111000: final l2u clear l2u counter \r\n\t10111001: final l2u check final delay \r\n\t10111010: final l2u inc l2u final delay \r\n\t10111011: final l2u dec prbs \r\n\t10111100: unused \r\n\t10111101: unused \r\n\t10111110: final l2u done \r\n\t10111111: final l2u fail \r\n\t11000000: final l2u wait for prev group status \r\n\t11000001: final l2u send status to next group \r\n\t11000010: final l2u wait for all group status \r\n\t11000011: unused \r\n\t11000100: unused \r\n\t11000101: unused \r\n\t11000110: unused \r\n\t11000111: unused \r\n\t11001000: unused \r\n\t11001001: unused \r\n\t11001010: unused \r\n\t11001011: unused \r\n\t11001100: unused \r\n\t11001101: unused \r\n\t11001110: final l2u max change send fail \r\n\t11001111: final l2u max change recv fail \r\n\t11010000: result check clear and start \r\n\t11010001: result check fly state \r\n\t11010010: result check for valid lane \r\n\t11010011: result check read eye width \r\n\t11010100: result check write bad width \r\n\t11010101: result check read amin values \r\n\t11010110: result check check height \r\n\t11010111: result check write bad height \r\n\t11011000: result check start ber servo \r\n\t11011001: result check read ber servo stat \r\n\t11011010: result check checkber status \r\n\t11011011: result check read ber count \r\n\t11011100: result checkcheck ber \r\n\t11011101: result check write bad ber \r\n\t11011110: result checkcheck if done \r\n\t11011111: result check fail \r\n\t11100000: completion start \r\n\t11100001: completion enable driving all \r\n\t11100010: completion drive eye opt done \r\n\t11100011: completion set up sls rcvr \r\n\t11100100: completion watch for sls nop \r\n\t11100101: completion drive sls nop ds \r\n\t11100110: completion wait for sls nop \r\n\t11100111: completion undrive lanes \r\n\t11101000: completion drive bogus sls nop \r\n\t11101001: completion wait non-sls data \r\n\t11101010: completion enable receive sls \r\n\t11101011: completion eye opt done \r\n\t11101100: unused \r\n\t11101101: unused \r\n\t11101110: unused \r\n\t11101111: unused \r\n\t11110000: latch offset fail \r\n\t11110001: vref fail \r\n\t11110010: vga measure ape/o fail \r\n\t11110011: vga measure ane/o fail \r\n\t11110100: vga measure ape dfe fail \r\n\t11110101: vga measure ane/o fail \r\n\t11110110: vga measure ane/o fail \r\n\t11110111: vga measure ano dfe fail \r\n\t11111000: vga measure amine fail \r\n\t11111001: vga measure amine fail \r\n\t11111010: ctle adjust fail \r\n\t11111011: h1ap tweak fail \r\n\t11111100: ddc fail \r\n\t11111101: measure eye fail \r\n\t11111110: dcd duty cycle fail \r\n\t11111111: unused \r\n\trjr
#define EI4_RX_RECAL_STATE                                 583,  8,  8 // EI4_RX_EO_RECAL_PG :: common edi/ei4 recalibration state machine\r\n\trjr
#define EI4_RX_WT_CLK_LANE_INVERTED                        569,  1,  1 // EI4_RX_WT_CLK_STATUS_PG :: clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted\r\n\trjr
#define EI4_RX_WT_CLK_LANE_BAD_CODE                        569,  2,  3 // EI4_RX_WT_CLK_STATUS_PG :: clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused\r\n\trjr
#define EI4_RX_WT_CLK_LANE_STATUS_ALIAS                    569,  1,  4 // EI4_RX_WT_CLK_STATUS_PG :: alias for rx_wt_clk_lane_inverted concatenated with rx_wt_clk_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at '0'--not swapped/inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--swapped or inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--swapped or inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--swapped or inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--swapped or inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EI4_RX_EO_ENABLE_LATCH_OFFSET_CAL                  572,  0,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization latch offset adjustment enable\r\n\trjr
#define EI4_RX_EO_ENABLE_CTLE_CAL                          572,  1,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization ctle/peakin enable\r\n\trjr
#define EI4_RX_EO_ENABLE_VREF_CAL                          572,  3,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization vref adjust enable\r\n\trjr
#define EI4_RX_EO_ENABLE_MEASURE_EYE_WIDTH                 572,  7,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization eye width check enable\r\n\trjr
#define EI4_RX_EO_ENABLE_FINAL_L2U_ADJ                     572,  8,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization final rx fifo load-to-unload delay adjustment enable\r\n\trjr
#define EI4_RX_EO_ENABLE_BER_TEST                          572,  9,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization bit error rate test enable\r\n\trjr
#define EI4_RX_EO_ENABLE_RESULT_CHECK                      572, 10,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization final results check enable\r\n\trjr
#define EI4_RX_EO_ENABLE_DCD_CAL                           572, 12,  1 // EI4_RX_EO_STEP_CNTL_PG :: rx eye optimization clockduty cycle distortion calibration enable:\r\n\t0:disalbed\r\n\t1:enabled if rx_eo_enable_vref_cal = 1 \r\n\trjr
#define EI4_RX_RC_ENABLE_EDGE_TRACK                        582,  3,  1 // EI4_RX_RC_STEP_CNTL_PG :: rx recalibration    eye tracking\r\n\trjr
#define EI4_RX_RC_ENABLE_MEASURE_EYE_WIDTH                 582,  7,  1 // EI4_RX_RC_STEP_CNTL_PG :: rx recalibration    eye width check enable\r\n\trjr
#define EI4_RX_RC_ENABLE_RESULT_CHECK                      582,  9,  1 // EI4_RX_RC_STEP_CNTL_PG :: rx recalibration    final results check enable\r\n\trjr
#define EI4_RX_RC_ENABLE_DLL_UPDATE                        582, 10,  1 // EI4_RX_RC_STEP_CNTL_PG :: rx recalibration    dll update enable\r\n\trjr
#define EI4_RX_EO_LATCH_OFFSET_DONE                        573,  0,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization latch offset adjustment done\r\n\trjr
#define EI4_RX_EO_CTLE_DONE                                573,  1,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization ctle/peaking done\r\n\trjr
#define EI4_RX_EO_VREF_DONE                                573,  3,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization vref adjust done\r\n\trjr
#define EI4_RX_EO_MEASURE_EYE_WIDTH_DONE                   573,  7,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization eye width check done\r\n\trjr
#define EI4_RX_EO_FINAL_L2U_ADJ_DONE                       573,  8,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization final rx fifo load-to-unload adjust done\r\n\trjr
#define EI4_RX_EO_RESULT_CHECK_DONE                        573, 11,  1 // EI4_RX_EO_STEP_STAT_PG :: rx eye optimization eye width/heighter check done\r\n\trjr
#define EI4_RX_EO_LATCH_OFFSET_FAILED                      574,  0,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization latch offset adjustment  failed\r\n\trjr
#define EI4_RX_EO_CTLE_FAILED                              574,  1,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization ctle/peaking  failed\r\n\trjr
#define EI4_RX_EO_VREF_FAILED                              574,  3,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization vref adjust  failed\r\n\trjr
#define EI4_RX_EO_MEASURE_EYE_WIDTH_FAILED                 574,  7,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization measure eye width failed\r\n\trjr
#define EI4_RX_EO_FINAL_L2U_ADJ_FAILED                     574,  8,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization final rx fifo load-to-unload adjust  failed\r\n\trjr
#define EI4_RX_EO_RESULT_CHECK_FAILED                      574,  9,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization final result checking failed\r\n\trjr
#define EI4_RX_EO_DCD_FAILED                               574, 10,  1 // EI4_RX_EO_STEP_FAIL_PG :: rx eye optimization clock duty cycle_adjust failed\r\n\trjr
#define EI4_RX_SERVO_BER_COUNT_WORK                        584,  0, 12 // EI4_RX_SERVO_BER_COUNT_PG :: rx servo-based bit error rate count working register\r\n\trjr
#define EI4_RX_EO_FINAL_L2U_DLY_SEQ_GCRMSG                 564,  0,  2 // EI4_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: rx final load to unload delay gcr messages\r\n\t00:(fl2uprevchg) indicate prior group calculated max load to unload change.\r\n\t01:(fl2uallchg) indicate all groups have calculated max load to unload change.\r\n\t10:(unused) unused.\r\n\t11:(fl2unomsg) no message.\r\n\tmbs
#define EI4_RX_EO_FINAL_L2U_DLY_MAXCHG_GCRMSG              564,  2,  6 // EI4_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: max change in miniumum load to unload delay.\r\n\tmbs
#define EI4_RX_EO_FINAL_L2U_DLY_CHG                        564, 10,  6 // EI4_RX_EO_FINAL_L2U_GCRMSG_PG :: gcr message: local change in miniumum load to unload delay.\r\n\tmbs
#define EI4_RX_SLS_RCVY_DISABLE                            576,  0,  1 // EI4_RX_SLS_RCVY_PG :: disable sls recovery\r\n\tsmr
#define EI4_RX_SLS_RCVY_STATE                              576,  3,  5 // EI4_RX_SLS_RCVY_PG :: sls recovery state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_rcvy_state\r\n\tsmr
#define EI4_RX_SLS_RCVY_REQ_GCRMSG                         577,  0,  1 // EI4_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair req has been issued.\r\n\tsmr
#define EI4_RX_SLS_RCVY_IP_GCRMSG                          577,  1,  1 // EI4_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair is in progress.\r\n\tsmr
#define EI4_RX_SLS_RCVY_DONE_GCRMSG                        577,  2,  1 // EI4_RX_SLS_RCVY_GCRMSG_PG :: gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair has been issued and is now done.\r\n\tsmr
#define EI4_RX_TX_BAD_LANE_CNTR_GCRMSG                     578,  0,  2 // EI4_RX_TX_LANE_INFO_GCRMSG_PG :: gcr message: rx side tx bad lane counter\r\n\tsmr
#define EI4_RX_DIS_SYND_TALLYING_GCRMSG                    579,  0,  1 // EI4_RX_ERR_TALLYING_GCRMSG_PG :: gcr message: internal logic has disabled the syndrome tallying feature for reasons such as the current rx sls lane is in the process of moving.\r\n\tsmr
#define EI4_RX_RUN_RDT                                     581,  0,  1 // EI4_RX_RDT_CNTL_PG :: rcv rdt pattern 0: rdt off \r\n\t1: rcv rdt\r\n\tdmb
#define EI4_RX_RDT_CHECK_MASK                              581,  2,  5 // EI4_RX_RDT_CNTL_PG :: rcv rdt bit mask:  11111 checks all bits, otherwise only check the bit specified\r\n\tdmb
#define EI4_RX_RDT_FAILED                                  581,  7,  1 // EI4_RX_RDT_CNTL_PG :: rcv rdt failed\r\n\tdmb
#define EI4_RX_RDT_RUNNING                                 581,  8,  1 // EI4_RX_RDT_CNTL_PG :: rcv rdt running\r\n\tdmb
#define EI4_RX_TRC_MODE                                    580,  0,  4 // EI4_RX_TRACE_PG :: rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd\r\n\tsmr
#define EI4_RX_TRC_GRP                                     580,  6,  6 // EI4_RX_TRACE_PG :: rx clock group to be traced\r\n\t111111 will trace whichever clk group currently contains the rx sls lane\r\n\tsmr
#define EI4_RX_DYN_RPR_BAD_LANE_VALID_DEBUG                586,  0,  1 // EI4_RX_DYN_RPR_DEBUG_PG :: for testfloor/debug purposes, the specified encoded bad data lane will be tallied as having one cycle of a valid crc/ecc error (this is a write-only pulse register)\r\n\tsmr
#define EI4_RX_DYN_RPR_ENC_BAD_DATA_LANE_DEBUG             586,  1,  7 // EI4_RX_DYN_RPR_DEBUG_PG :: for testfloor/debug purposes, specify the encoded bad data lane to report to the dynamic repair tally logic\r\n\tsmr
#define EI4_RX_BAD_BUS_ERR_CNTR                            586,  9,  7 // EI4_RX_DYN_RPR_DEBUG_PG :: bad bus error counter (aka counter2)\r\n\tsmr
#define EI4_RX_BAD_BUS_LANE_ERR_CNTR_DIS_CLR               521,  0,  1 // EI4_RX_DYN_RPR_DEBUG2_PG :: disable clearing of the bad bus lane error counter (aka counter1) when the next crc/ecc error comes in on a new lane\r\n\tsmr
#define EI4_RX_BAD_BUS_LANE_ERR_CNTR                       521,  1,  7 // EI4_RX_DYN_RPR_DEBUG2_PG :: bad bus lane error counter (aka counter1)\r\n\tsmr
#define EI4_RX_LAST_BAD_BUS_LANE                           521,  9,  7 // EI4_RX_DYN_RPR_DEBUG2_PG :: last bad bus lane (bus lane causing the last crc or ecc error)\r\n\tsmr
#define EI4_RX_DYN_RPR_BAD_BUS_MAX                         587,  0,  7 // EI4_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: max number of times crc or ecc errors can be found on the bus (not included in the bad lane cntr1 tally) before setting a fir error\r\n\tsmr
#define EI4_RX_DYN_RPR_ERR_CNTR2_DURATION                  587,  7,  4 // EI4_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: duration the bad bus cntr2 error counter can run before being divided by 2 (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EI4_RX_DYN_RPR_CLR_ERR_CNTR2                       587, 11,  1 // EI4_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: firmware-based clear of bus error counter2 register\r\n\tsmr
#define EI4_RX_DYN_RPR_DISABLE2                            587, 12,  1 // EI4_RX_DYN_RPR_ERR_TALLYING2_PG :: crc/ecc dynamic repair: when set, disables the repair from the dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2), however leaves the counters running\r\n\tsmr
#define EI4_RX_MIN_EYE_WIDTH                               588,  2,  6 // EI4_RX_RESULT_CHK_PG :: minimum acceptable eye width used during init or recal results checking--edi or ei4\r\n\tdmb
#define EI4_RX_MAX_BER_CHECK_COUNT                         589,  8,  8 // EI4_RX_BER_CHK_PG :: maximum acceptable number of bit errors allowable after recal. it is used in both edi and ei-4 for initialization, but not used during ei4 recal. it is used during recal checks on edi.\r\n\trjr
#define EI4_RX_STOP_STATE_ENABLE                           513,  0,  1 // EI4_RX_STOP_CNTL_STAT_PG :: enable state machine stop of address\r\n\trjr
#define EI4_RX_STATE_STOPPED                               513,  1,  1 // EI4_RX_STOP_CNTL_STAT_PG :: state machines stopped\r\n\trjr
#define EI4_RX_RESUME_FROM_STOP                            513,  2,  1 // EI4_RX_STOP_CNTL_STAT_PG :: resume stopped state machines and /or counters\r\n\trjr
#define EI4_RX_STOP_ADDR_MSB                               513,  8,  4 // EI4_RX_STOP_CNTL_STAT_PG :: stop address most-significant four bits 0 to 3\r\n\trjr
#define EI4_RX_STOP_MASK_MSB                               513, 12,  4 // EI4_RX_STOP_CNTL_STAT_PG :: stop mask    most-significant four bits 0 to 3\r\n\trjr
#define EI4_RX_STOP_ADDR_LSB                               515,  0, 16 // EI4_RX_STOP_ADDR_LSB_PG :: stop address least-significant 16 bits 4 to 19\r\n\trjr
#define EI4_RX_STOP_MASK_LSB                               516,  0, 16 // EI4_RX_STOP_MASK_LSB_PG :: stop mask    least-significant 16 bits 4 to 19\r\n\trjr
#define EI4_RX_SLV_SHDW_DONE_FIN_GCRMSG                    590,  0,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_done\r\n\tsmr
#define EI4_RX_SLV_SHDW_NOP_FIN_GCRMSG                     590,  1,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EI4_RX_SLV_SHDW_RPR_DONE_FIN_GCRMSG                590,  2,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_rpr_done\r\n\tsmr
#define EI4_RX_SLV_SHDW_RPR_NOP_FIN_GCRMSG                 590,  3,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EI4_RX_SLV_UNSHDW_DONE_FIN_GCRMSG                  590,  4,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_done\r\n\tsmr
#define EI4_RX_SLV_UNSHDW_NOP_FIN_GCRMSG                   590,  5,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EI4_RX_SLV_UNSHDW_RPR_DONE_FIN_GCRMSG              590,  6,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_rpr_done\r\n\tsmr
#define EI4_RX_SLV_UNSHDW_RPR_NOP_FIN_GCRMSG               590,  7,  1 // EI4_RX_SLS_RCVY_FIN_GCRMSG_PG :: gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EI4_RX_DYN_RPR_ENC_BAD_DATA_LANE_SHFT_AMT          529,  0,  7 // EI4_RX_DYN_RPR_MODE_PG :: crc/ecc dynamic repair: programmable register value that is subtracted from the enc_bad_data_lane value provided from the crc/ecc check logic (except for the all 1s clear pattern).  (e.g. should be set to 0x07 for the zmci logic to compensate for disabled lanes, but otherwise generally 0x00.  note: always check figtree for current settings, though, and not this comment!).\r\n\tsmr
#define EI4_RX_REDUCED_SCRAMBLE_MODE                       591,  0,  2 // EI4_RX_MODE1_PP :: sets reduced density of scramble pattern. this must be set consistent with tx_reduced_scramble_mode.  \r\n\t00:(disable_0) disable reduced density \r\n\t01:(disable_1) disable reduced density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div2_1) enable div2 reduced density\r\n\tmbs
#define EI4_RX_PRBS_SCRAMBLE_MODE                          591,  2,  2 // EI4_RX_MODE1_PP :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EI4_RX_ACT_CHECK_TIMEOUT_SEL                       591,  4,  3 // EI4_RX_MODE1_PP :: sets activity check timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(128ui) 128 ui \r\n\t010:(256ui) 256 ui \r\n\t011:(512ui) 512 ui \r\n\t100:(1024ui) 1024 ui \r\n\t101:(2048ui) 2048 ui \r\n\t110:(4096ui) 4096 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EI4_RX_BLOCK_LOCK_TIMEOUT_SEL                      591,  7,  3 // EI4_RX_MODE1_PP :: sets block lock timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(1024ui) 1024 ui \r\n\t010:(2048ui) 2048 ui \r\n\t011:(4096ui) 4096 ui \r\n\t100:(8192ui) 8192 ui \r\n\t101:(16384ui) 16384 ui \r\n\t110:(32768ui) 32768 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EI4_RX_BIT_LOCK_TIMEOUT_SEL                        591, 10,  3 // EI4_RX_MODE1_PP :: sets bit lock/edge detect timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(512ui) 512 ui \r\n\t010:(1024ui) 1024 ui \r\n\t011:(2048ui) 2048 ui \r\n\t100:(4096ui) 4096 ui \r\n\t101:(8192ui) 8192 ui \r\n\t110:(16384ui) 16384 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EI4_RX_REVERSE_SHIFT                               591, 14,  1 // EI4_RX_MODE1_PP :: rx phase rotator direction\r\n\twriting this bit to a 1 causes the phase rotator to shift in the opposite direction. this mode is used for diagnostics and characterization.\r\n\t0:(normal) normal phase rotator shift direction (default)\r\n\t1:(reversed) reversed phase rotator shift direction\r\n\tcpg
#define EI4_RX_EI3_MODE                                    591, 15,  1 // EI4_RX_MODE1_PP :: ei3 mode - see also tx_ei3_mode \r\n\t0:(ei4) ei4 mode (default) \r\n\t1:(ei3) ei3 mode\r\n\tdmb
#define EI4_RX_PP_TRC_EN                                   605,  0,  1 // EI4_RX_MODE2_PP :: per pack rx trace mode enable \r\n\t0:(disabled) per pack trace mode is disabled \r\n\t1:(enabled) per pack trace mode is enabled \r\n\tsmr
#define EI4_RX_PP_TRC_MODE                                 605,  1,  3 // EI4_RX_MODE2_PP :: per pack rx trace mode\r\n\t000:(tap0) tbd\r\n\t001:(tap1) tbd\r\n\t010:(tap2) tbd\r\n\t011:(tap3) tbd\r\n\t100:(tap4) tbd\r\n\t101:(tap5) tbd\r\n\t110:(tap6) tbd\r\n\t111:(tap7) tbd\r\n\tsmr
#define EI4_RX_BIST_JITTER_PULSE_SEL                       605,  4,  2 // EI4_RX_MODE2_PP :: rx bist jitter select\r\n\tthis setting induces artificial jitter into the data of the prbs generator during bist to ensure the deadzone between the two eyes of the bist pattern is at least two pr steps wide.\r\n\t00:(steps4) four jitter steps\r\n\t01: (steps2) two jitter steps\r\n\t10: (steps8) eight jitter steps\r\n\t11: (steps0) no jitter\r\n\tjgr
#define EI4_RX_BIST_MIN_EYE_WIDTH                          605,  6,  7 // EI4_RX_MODE2_PP :: rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass phybist.\r\n\tjgr
#define EI4_RX_DIS_BLOCK_LOCK_VREF                         605, 13,  1 // EI4_RX_MODE2_PP :: disables vref from running during block lock.\r\n\tdmb
#define EI4_RX_WT_PATTERN_LENGTH                           605, 14,  2 // EI4_RX_MODE2_PP :: rx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EI4_RX_BIST_STEP_INTERVAL_EN                       607,  0,  1 // EI4_RX_MODE3_PP :: enables the increment size of the phase rotator to be increased by the value of rx_bist_step_interval.\r\n\tjgr
#define EI4_RX_BIST_STEP_INTERVAL                          607,  1,  2 // EI4_RX_MODE3_PP :: set to desired increase in phase rotator increment size.\r\n\tjgr
#define EI4_RX_BIST_PHASEROT_OFFSET_EN                     607,  3,  1 // EI4_RX_MODE3_PP :: allows the phase rotator position to be shifted by rx_bist_phaserot_offset number of steps prior to performing the rx bist test.\r\n\tjgr
#define EI4_RX_BIST_PHASEROT_OFFSET                        607,  4,  2 // EI4_RX_MODE3_PP :: set to desired number of steps to shift phase rotator by.\r\n\tjgr
#define EI4_RX_BIST_BUFFER_SEL                             607,  6,  3 // EI4_RX_MODE3_PP :: sets the number of additional steps to be incremented in the buffer states that begin each eye count thus aiding rx bist in transitioning into the clean portion of the data eye. hw200711\r\n\tjgr
#define EI4_RX_SERVO_TIMEOUT_SEL_A                         600,  0,  4 // EI4_RX_SERVO_TO1_PP :: rx servo operation timeout a used to time latch offset calibration.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_B                         600,  4,  4 // EI4_RX_SERVO_TO1_PP :: rx servo operation timeout b used to time ctle/peaking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_C                         600,  8,  4 // EI4_RX_SERVO_TO1_PP :: rx servo operation timeout c used to time vref adjustment.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_D                         600, 12,  4 // EI4_RX_SERVO_TO1_PP :: rx servo operation timeout d used to time block locking .\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_E                         601,  0,  4 // EI4_RX_SERVO_TO2_PP :: rx servo operation timeout e used to time edge tracking .\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_F                         601,  4,  4 // EI4_RX_SERVO_TO2_PP :: rx servo operation timeout f used to time eye tracking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_G                         601,  8,  4 // EI4_RX_SERVO_TO2_PP :: rx servo operation timeout g used to time ber testing.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_SERVO_TIMEOUT_SEL_H                         601, 12,  4 // EI4_RX_SERVO_TO2_PP :: rx servo operation timeout h used to time edi dynamic data centering and ei-4 clock duty cycle distortion adjust.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_RECAL_TIMEOUT_SEL_E                         604,  0,  4 // EI4_RX_RECAL_TO2_PP :: rx recal servo operation timeout e used to time edge tracking during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_RECAL_TIMEOUT_SEL_F                         604,  4,  4 // EI4_RX_RECAL_TO2_PP :: rx recal servo operation timeout f used to time eye  tracking during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EI4_RX_PRBS_CHECK_SYNC                             592,  1,  1 // EI4_RX_CNTL_FAST_PP :: enables checking for the 12 ui scramble sync pattern. \r\n\t0:(disabled) disable checking (forces prbs_synced_b to 1)\r\n\t1:(enabled) enable checking (prbs_synced_b can go to 0)\r\n\trjr
#define EI4_RX_ENABLE_REDUCED_SCRAMBLE                     592,  2,  1 // EI4_RX_CNTL_FAST_PP :: enables reduced density of scramble pattern. \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the rx_reduced_scramble_mode setting\r\n\trjr
#define EI4_RX_PRBS_INC                                    592,  3,  1 // EI4_RX_CNTL_FAST_PP :: shift the prbs pattern forward in time by one extra local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EI4_RX_PRBS_DEC                                    592,  4,  1 // EI4_RX_CNTL_FAST_PP :: shift the prbs pattern back in time by holding it one local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EI4_RX_DDC_USE_CYC_BLOCK_LOCK                      593,  0,  1 // EI4_RX_EI4_CAL_CNTL_PP :: 0: use phase rot, 1: use cycle sim block lock\r\n\trjr
#define EI4_RX_PEAK_BAUD_SEL                               593,  1,  2 // EI4_RX_EI4_CAL_CNTL_PP :: 01: full baud, 10: half baud, 11: automatic toggle, using rx_peak_baud_toggle_sel to adjust rate\r\n\tdmb
#define EI4_RX_PEAK_BAUD_TOGGLE_SEL                        593,  3,  2 // EI4_RX_EI4_CAL_CNTL_PP :: selects rate of toggling between baud rates for peaking: 00 = 16x per ctle servo op, 01 = 8x per ctle servo op, 10 = 4x per ctle servo op, 11 = 2x per ctle servo op \r\n\tdmb
#define EI4_RX_REVERSE_DCD                                 593,  5,  1 // EI4_RX_EI4_CAL_CNTL_PP :: 0: default dcd setting, 1: changes the direction that dcd adjustmenets are made (servo incs will be decs and vice versa)\r\n\tdmb
#define EI4_RX_CAL_INC_VAL_A                               594,  0,  4 // EI4_RX_EI4_CAL_INC_A_D_PP :: rx servo accum inc value a: latch offset cal for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_B                               594,  4,  4 // EI4_RX_EI4_CAL_INC_A_D_PP :: rx servo accum inc value b: ctle for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_C                               594,  8,  4 // EI4_RX_EI4_CAL_INC_A_D_PP :: rx servo accum inc value c: vref for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_D                               594, 12,  4 // EI4_RX_EI4_CAL_INC_A_D_PP :: rx servo accum inc value d: block lock for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_E                               595,  0,  4 // EI4_RX_EI4_CAL_INC_E_H_PP :: rx servo accum inc value e: edge tracking for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_F                               595,  4,  4 // EI4_RX_EI4_CAL_INC_E_H_PP :: rx servo accum inc value f: eye tracking for ei4\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_G                               595,  8,  4 // EI4_RX_EI4_CAL_INC_E_H_PP :: rx servo accum inc value g: reserved\r\n\tcpg
#define EI4_RX_CAL_INC_VAL_H                               595, 12,  4 // EI4_RX_EI4_CAL_INC_E_H_PP :: rx servo accum inc value h: duty cycle adjust for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_A                               596,  0,  4 // EI4_RX_EI4_CAL_DEC_A_D_PP :: rx servo accum dec value a: latch offset cal for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_B                               596,  4,  4 // EI4_RX_EI4_CAL_DEC_A_D_PP :: rx servo accum dec value b: ctle for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_C                               596,  8,  4 // EI4_RX_EI4_CAL_DEC_A_D_PP :: rx servo accum dec value c: vref for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_D                               596, 12,  4 // EI4_RX_EI4_CAL_DEC_A_D_PP :: rx servo accum dec value d: block lock for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_E                               597,  0,  4 // EI4_RX_EI4_CAL_DEC_E_H_PP :: rx servo accum dec value e: edge tracking for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_F                               597,  4,  4 // EI4_RX_EI4_CAL_DEC_E_H_PP :: rx servo accum dec value f: eye tracking for ei4\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_G                               597,  8,  4 // EI4_RX_EI4_CAL_DEC_E_H_PP :: rx servo accum dec value g: reserved\r\n\tcpg
#define EI4_RX_CAL_DEC_VAL_H                               597, 12,  4 // EI4_RX_EI4_CAL_DEC_E_H_PP :: rx servo accum dec value h: duty cycle adjust for ei4\r\n\tcpg
#define EI4_RX_RESET_CFG_HLD                               602,  0, 16 // EI4_RX_RESET_CFG_PP :: reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via rx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EI4_RX_BIST_EN                                     606,  0,  1 // EI4_RX_BIST_GCRMSG_PP :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.\r\n\tjgr
#define EI4_RX_BER_EN                                      598,  0,  1 // EI4_RX_BER_CNTL_PP :: per-pack (pp) diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.\r\n\tpmt
#define EI4_RX_BER_COUNT_CLR                               598,  1,  1 // EI4_RX_BER_CNTL_PP :: pp diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EI4_RX_BER_TIMER_CLR                               598,  2,  1 // EI4_RX_BER_CNTL_PP :: pp diag ber timer clear pulse. when written to a 1 the per-pack timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EI4_RX_BER_TIMER_FREEZE_EN                         599,  0,  1 // EI4_RX_BER_MODE_PP :: per-pack (pp) diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the per-pack timer is frozen when any lane error count saturates in that pack.\r\n\tpmt
#define EI4_RX_BER_COUNT_FREEZE_EN                         599,  1,  1 // EI4_RX_BER_MODE_PP :: pp diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.\r\n\tpmt
#define EI4_RX_BER_COUNT_SEL                               599,  3,  3 // EI4_RX_BER_MODE_PP :: pp diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. \r\n\t000:(1) 1\r\n\t001:(2) 2\r\n\t010:(4) 4\r\n\t011:(8) 8\r\n\t100:(16) 16\r\n\t101:(32) 32\r\n\t110:(64) 64\r\n\t111:(128) 128\r\n\tpmt
#define EI4_RX_BER_TIMER_SEL                               599,  6,  3 // EI4_RX_BER_MODE_PP :: pp diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. \r\n\t000:(2tothe39th) 2^39\r\n\t001:(2tothe35th) 2^35\r\n\t010:(2tothe31st) 2^31\r\n\t011:(2tothe27th) 2^27\r\n\t100:(2tothe25th) 2^25\r\n\t101:(2tothe21th) 2^21\r\n\t110:(2tothe17th) 2^17\r\n\t111:(2tothe13th) 2^13\r\n\tpmt
#define EI4_RX_BER_CLR_COUNT_ON_READ_EN                    599,  9,  1 // EI4_RX_BER_MODE_PP :: pp diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.\r\n\tpmt
#define EI4_RX_BER_CLR_TIMER_ON_READ_EN                    599, 10,  1 // EI4_RX_BER_MODE_PP :: pp diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes per-pack timer when it is read from any lane in the pack.\r\n\tpmt
#define EI4_RX_FIR_MSG                                     612,  0,  8 // EI4_RX_FIR_MSG_PB :: dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.\r\n\tpmt
#define EI4_RX_PB_CLR_PAR_ERRS                             608, 14,  1 // EI4_RX_FIR_RESET_PB :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.\r\n\tpmt
#define EI4_RX_PB_FIR_RESET                                608, 15,  1 // EI4_RX_FIR_RESET_PB :: fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS_FULL_REG                        609,  0, 10 // EI4_RX_FIR_PB :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS                                 609,  0, 10 // EI4_RX_FIR_PB :: a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_PB_REGS                          609,  0,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl registers.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCR_BUFF0                        609,  1,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr buffer.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCR_BUFF1                        609,  2,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCR_BUFF2                        609,  3,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_LD_SM0                      609,  4,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_LD_SM1                      609,  5,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_LD_SM2                      609,  6,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_UNLD_SM0                    609,  7,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_UNLD_SM1                    609,  8,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_GCRS_UNLD_SM2                    609,  9,  1 // EI4_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS_MASK_FULL_REG                   610,  0, 10 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for rx_fir_pb errors.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS_MASK                            610,  0, 10 // EI4_RX_FIR_MASK_PB :: fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_PB_REGS                     610,  0,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl registers.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCR_BUFF0                   610,  1,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr buffer.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCR_BUFF1                   610,  2,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCR_BUFF2                   610,  3,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                 610,  4,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                 610,  5,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                 610,  6,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0               610,  7,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1               610,  8,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2               610,  9,  1 // EI4_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS_INJ_FULL_REG                    611,  0, 10 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EI4_RX_PB_FIR_ERRS_INJ                             611,  0, 10 // EI4_RX_FIR_ERROR_INJECT_PB :: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_PB_REGS                      611,  0,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCR_BUFF0                    611,  1,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr buffer.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCR_BUFF1                    611,  2,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCR_BUFF2                    611,  3,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                  611,  4,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                  611,  5,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                  611,  6,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0                611,  7,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1                611,  8,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EI4_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2                611,  9,  1 // EI4_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EI4_GCR_TEST_MODE                                  613,  0,  1 // EI4_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.\r\n\tpmt
#define EI4_ENABLE_GCR_OFL_BUFF                            613,  1,  1 // EI4_SCOM_MODE_PB :: enables 2nd gcr overflow buffer, one is used by default.\r\n\tdmb
#define EI4_IORESET_HARD_BUS0                              613,  2,  6 // EI4_SCOM_MODE_PB :: io hard reset per-bus and gcr reset\r\n\tenables a hard reset on bus 0 thru 5 (this is application dependent and bus 1-5 may not be present). a gcr reset affects all busses since any of them may be corrupted.\r\n\t000000:(functional) functional (default)\r\n\t100000:(reset0) reset bus 0\r\n\t010000:(reset1) reset bus 1\r\n\t001000:(reset2) reset bus 2\r\n\t000100:(reset3) reset bus 3\r\n\t000010:(reset4) reset bus 4\r\n\t000001:(reset5) reset bus 5\r\n\t111111:(resetgcr) reset all local busses and perform a gcr reset.\r\n\tjfg
#define EI4_GCR_HANG_DET_SEL                               613,  8,  3 // EI4_SCOM_MODE_PB :: gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 31 cycles\r\n\t010: 63 cycles\r\n\t011: 127 cycles\r\n\t100: 255 cycles\r\n\t101: 511 cycles\r\n\t110: 1023 cycles\r\n\t111: 2047 cycles.\r\n\tdmb
#define EI4_GCR_BUFFER_ENABLED                             613, 11,  1 // EI4_SCOM_MODE_PB :: flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.\r\n\tdmb
#define EI4_GCR_HANG_ERROR_MASK                            613, 12,  1 // EI4_SCOM_MODE_PB :: mask for gcr hang error when 2nd buffer is enabled.\r\n\tdmb
#define EI4_GCR_HANG_ERROR_INJ                             613, 13,  1 // EI4_SCOM_MODE_PB :: inject for gcr hang error.\r\n\tdmb
#define EI4_SCOM_MODE_PB_SPARES                            613, 14,  8 // EI4_SCOM_MODE_PB :: scom mode reg spares.\r\n\tdmb
#define EDIP_TX_MODE1_PL_FULL_REG                          623,  0, 16 // EDIP_TX_MODE1_PL :: iotk alias: for entire tx_mode1_pl register
#define EDIP_TX_LANE_PDWN                                  623,  0,  1 // EDIP_TX_MODE1_PL :: used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default). 
#define EDIP_TX_LANE_INVERT                                623,  1,  1 // EDIP_TX_MODE1_PL :: used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.
#define EDIP_TX_LANE_QUIESCE                               623,  2,  2 // EDIP_TX_MODE1_PL :: used to force the output of a lane to a particular logical value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.
#define EDIP_TX_LANE_SCRAMBLE_DISABLE                      623,  6,  1 // EDIP_TX_MODE1_PL :: used to disable the tx scrambler on a specific lane or all lanes by using a per-lane/per-group global write.
#define EDIP_TX_ERR_INJ_A_ENABLE                           623,  7,  1 // EDIP_TX_MODE1_PL :: control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane.
#define EDIP_TX_ERR_INJ_B_ENABLE                           623,  8,  1 // EDIP_TX_MODE1_PL :: control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane.
#define EDIP_TX_PL_SPARE_MODE_0                            623, 12,  1 // EDIP_TX_MODE1_PL :: per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_1                            623, 13,  1 // EDIP_TX_MODE1_PL :: per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_2                            623, 14,  1 // EDIP_TX_MODE1_PL :: per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_3                            623, 15,  1 // EDIP_TX_MODE1_PL :: per-lane spare mode latch.
#define EDIP_TX_FIFO_L2U_DLY                               624,  0,  3 // EDIP_TX_MODE2_PL :: this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define EDIP_TX_PRBS_SCRAMBLE_MODE                         624,  6,  2 // EDIP_TX_MODE2_PL :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by tx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDIP_TX_UNLOAD_CLK_DISABLE                         624,  8,  1 // EDIP_TX_MODE2_PL :: set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define EDIP_TX_RXCAL                                      624,  9,  1 // EDIP_TX_MODE2_PL :: set transmitter to drive vio/2 common mode on both legs.  use this control during far end rx offset calibration.
#define EDIP_TX_UNLOAD_SEL                                 624, 10,  3 // EDIP_TX_MODE2_PL :: controls the preset value of the tx slice unload counter, which effectively gives subcycle control of the offset of tx unload clock from grid clock.
#define EDIP_TX_PDWN_LITE                                  624, 13,  1 // EDIP_TX_MODE2_PL :: when set, gates tx data path (post fifo) to 0s on unused spare lanes when not being recalibrated.
#define EDIP_TX_CAL_LANE_SEL                               624, 14,  1 // EDIP_TX_MODE2_PL :: sls commands & recalibration\r\n\t0: sls commands & recalibration data gated and functional data ungated \r\n\t1: send sls command or recalibration data and functional data gated
#define EDIP_TX_FIFO_HALF_WIDTH_MODE                       624, 15,  1 // EDIP_TX_MODE2_PL :: selects half width mode for tx fifo for slower frequency connections. \r\n\t0: normal width \r\n\t1: half width (bits starting from 0 used, and the second half is unused)
#define EDIP_TX_PRBS_SEED_VALUE_0_15                       630,  0, 16 // EDIP_TX_BIT_MODE1_E_PL :: tx per-lane prbs seed value\r\n\tused to specify loading value of the prbs scramble pattern when the sync pattern is detected.  this must be set consistent with rx_prbs_seed_value.  see data scrambling workbook section for details.  \r\n\twhen connected to legacy centaur parts, the seed must load such that it matches the sequence of those legacy parts.  the patterns listed here match that, including variants required to seed in full or half-width mode.\r\n\t0000000000000000:(pattern_tx_ab_half_a_0_15) tx prbs tap points a and b, and tx half-width tap point a\r\n\t0000000000011110:(pattern_tx_c_0_15) tx prbs tap point c\r\n\t0000000000011111:(pattern_tx_d_0_15) tx prbs tap point d\r\n\t0000000000001111:(pattern_tx_e_half_b_0_15) tx prbs tap point e, and tx half-width tap point b\r\n\t0000000001111100:(pattern_tx_f_0_15) tx prbs tap point f\r\n\t0000110001100011:(pattern_tx_g_0_15) tx prbs tap point g\r\n\t0000111001110011:(pattern_tx_h_0_15) tx prbs tap point h\r\n\t0000000111101111:(pattern_tx_half_c_0_15) tx half width prbs tap point c\r\n\t0000000111110001:(pattern_tx_half_d_0_15) tx half width prbs tap point d\r\n\t0000000011111011:(pattern_tx_half_e_0_15) tx half width prbs tap point e\r\n\t0000011111000010:(pattern_tx_half_f_0_15) tx half width prbs tap point f\r\n\t1100011000110001:(pattern_tx_half_g_0_15) tx half width prbs tap point g\r\n\t1110011100111001:(pattern_tx_half_h_0_15) tx half width prbs tap point h
#define EDIP_TX_PRBS_SEED_VALUE_16_22                      631,  0,  7 // EDIP_TX_BIT_MODE2_E_PL :: tx per-lane prbs seed value lsbs\r\n\tsee rx_prbs_seed_value_0_15 for details.\r\n\t0000001:(pattern_tx_a_16_22) tx prbs tap point a\r\n\t1111100:(pattern_tx_b_16_22) tx prbs tap point b\r\n\t1111011:(pattern_tx_c_16_22) tx prbs tap point c\r\n\t0001100:(pattern_tx_dg_16_22) tx prbs tap points d and g\r\n\t1011110:(pattern_tx_e_16_22) tx prbs tap point e\r\n\t0010000:(pattern_tx_f_half_a_16_22) tx prbs tap point f, and tx half-width tap point a\r\n\t1001110:(pattern_tx_h_half_b_16_22) tx prbs tap point h, and tx half-width tap point b\r\n\t0111101:(pattern_tx_half_c_16_22) tx half width prbs tap point c\r\n\t1000110:(pattern_tx_half_dg_16_22) tx half width prbs tap points d and g\r\n\t1101111:(pattern_tx_half_e_16_22) tx half width prbs tap point e\r\n\t0001000:(pattern_tx_half_f_16_22) tx half width prbs tap point f\r\n\t1100111:(pattern_tx_half_h_16_22) tx half width prbs tap point h
#define EDIP_TX_ERR_INJECT                                 625,  0,  5 // EDIP_TX_CNTL1G_PL :: inject one beat of error on this lane.  set code 1yyyy where yyyy is the beat in the deserialized cycle to inject on.
#define EDIP_TX_FIFO_INIT                                  625,  5,  1 // EDIP_TX_CNTL1G_PL :: used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.
#define EDIP_TX_SET_PDWN_LITE                              625,  6,  1 // EDIP_TX_CNTL1G_PL :: set tx_pdwn_lite register
#define EDIP_TX_CLR_PDWN_LITE                              625,  7,  1 // EDIP_TX_CNTL1G_PL :: clear tx_pdwn_lite register
#define EDIP_TX_SET_CAL_LANE_SEL                           625,  8,  1 // EDIP_TX_CNTL1G_PL :: set tx_cal_lane_sel register
#define EDIP_TX_CLR_CAL_LANE_SEL                           625,  9,  1 // EDIP_TX_CNTL1G_PL :: clear tx_pdwn_lite register
#define EDIP_TX_LANE_BIST_ERR                              626,  0,  1 // EDIP_TX_STAT1_PL :: indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.
#define EDIP_TX_LANE_BIST_ACTVITY_DET                      626,  1,  1 // EDIP_TX_STAT1_PL :: indicates that activity was detected in prbs checker. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define EDIP_TX_SEG_TEST_STATUS                            626,  2,  2 // EDIP_TX_STAT1_PL :: driver segment test result. bit0 for pad p, bit1 for pad n
#define EDIP_TX_TDR_CAPT_VAL                               626, 15,  1 // EDIP_TX_STAT1_PL :: value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.
#define EDIP_TX_PL_FIR_ERRS_FULL_REG                       627,  0, 16 // EDIP_TX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define EDIP_TX_PL_FIR_ERRS                                627,  0,  1 // EDIP_TX_FIR_PL :: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs
#define EDIP_TX_PL_FIR_ERR_PL_REGS                         627,  0,  1 // EDIP_TX_FIR_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.
#define EDIP_TX_PL_FIR_ERRS_MASK_FULL_REG                  628,  0, 16 // EDIP_TX_FIR_MASK_PL :: iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.
#define EDIP_TX_PL_FIR_ERRS_MASK                           628,  0,  1 // EDIP_TX_FIR_MASK_PL :: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs
#define EDIP_TX_PL_FIR_ERR_MASK_PL_REGS                    628,  0,  1 // EDIP_TX_FIR_MASK_PL :: iotk alias: fir mask for the per-lane tx register checker.
#define EDIP_TX_PL_FIR_ERR_INJ_FULL_REG                    629,  0, 16 // EDIP_TX_FIR_ERROR_INJECT_PL :: iotk alias: for tx_fir_error_inject_pl register
#define EDIP_TX_PL_FIR_ERR_INJ                             629,  0,  1 // EDIP_TX_FIR_ERROR_INJECT_PL :: tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker
#define EDIP_TX_PL_FIR_ERR_INJ_PL_REGS                     629,  0,  1 // EDIP_TX_FIR_ERROR_INJECT_PL :: iotk alias: parity error has occurred in the per-lane tx register logic.
#define EDIP_TX_CLK_INVERT                                 640,  0,  1 // EDIP_TX_CTL_MODE1_E_PG :: used to invert the polarity of the clock.\r\n\t0:(normal_clk) normal clk polarity (default)\r\n\t1:(invert_clk) invert clk
#define EDIP_TX_CLK_QUIESCE                                640,  1,  2 // EDIP_TX_CTL_MODE1_E_PG :: used to force the output of the clock lane to a particular value. \r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.
#define EDIP_TX_CLK_RATE                                   640,  5,  2 // EDIP_TX_CTL_MODE1_E_PG :: used to select tx bus clock rate. \r\n\t00:(odr) odr/c8 mode \r\n\t01:(qdr) qdr/c4 mode\r\n\t10:(ddr) ddr/c2 mode\r\n\t11:(unused) unused
#define EDIP_TX_DYN_RECAL_INTERVAL_TIMEOUT_SEL             640,  7,  3 // EDIP_TX_CTL_MODE1_E_PG :: tx dynamic recalibration interval timeout selects \r\n\t  this timeout determines the time between status reporting timeouts. \r\n\t the actual time of sending a message is selected with rx_dyn_recal_status_rpt_timeout_sel. \r\n\t000:(tap0) 1024ui or 106.5ns very small value for sim only\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite
#define EDIP_TX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL           640, 10,  2 // EDIP_TX_CTL_MODE1_E_PG :: tx dynamic recalibration status reporting timeout selects \r\n\t  this timeout determines the time that a status reporting timeout lasts.  the first 1/4 is a blank period, the middle 1/2 is the command message, and the last 1/4 is another blank period. \r\n\t the time between messages is selected with rx_dyn_recal_interval_timeout_sel. \r\n\t00:(tap0) 512ui or 53.2ns very small value for sim only\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\t(note that the first 1/4 and last 1/4 of this time are actually sending the prbs pattern, so the actual time the sls command is on the lane is 1/2 of this value.  for more info see figure 2.4 eye-opening initialization step/recalibration timing description in the workbook.)
#define EDIP_TX_LANE0_DISABLED                             640, 12,  1 // EDIP_TX_CTL_MODE1_E_PG :: tells the tx repair logic whether the used bits are on the end of the group or the beginning numerically.
#define EDIP_TX_PG_SPARE_MODE_0                            632,  0,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_1                            632,  1,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_2                            632,  2,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_3                            632,  3,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_4                            632,  4,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_5                            632,  5,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_6                            632,  6,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_7                            632,  7,  1 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_8_9                          632,  8,  2 // EDIP_TX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_CLK_BIST_ERR                               664,  0,  1 // EDIP_TX_CTLSM_STAT1_EO_PG :: indicates a txbist clock side error occurred.\r\n\t0:(no_error) no error\r\n\t1:(error) a clock side error has has been found
#define EDIP_TX_CLK_BIST_ACTIVITY_DET                      664,  1,  1 // EDIP_TX_CTLSM_STAT1_EO_PG :: indicates that activity was detected in prbs checker for clk pattern. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define EDIP_TX_BIST_DONE                                  664,  2,  1 // EDIP_TX_CTLSM_STAT1_EO_PG :: indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running
#define EDIP_TX_SLS_HNDSHK_STATE                           664,  3,  5 // EDIP_TX_CTLSM_STAT1_EO_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for tx_sls_hndshk_state
#define EDIP_TX_CLKDIST_PDWN                               634,  0,  1 // EDIP_TX_CTL_MODE1_EO_PG :: used to disable the tx group clocks and put them into a low power state. this does not control per-lane circuits or logic.
#define EDIP_TX_BIST_EN                                    634,  3,  1 // EDIP_TX_CTL_MODE1_EO_PG :: this bit enables the tx bist state machine to begin testing.
#define EDIP_TX_EXBIST_MODE                                634,  4,  1 // EDIP_TX_CTL_MODE1_EO_PG :: this bit is the chicken switch to diable the bist enable through external io.
#define EDIP_TX_MAX_BAD_LANES                              634,  5,  5 // EDIP_TX_CTL_MODE1_EO_PG :: static repair, dynamic repair & recal max number of bad lanes per tx bus (note: should match rx side)
#define EDIP_TX_MSBSWAP                                    634, 10,  1 // EDIP_TX_CTL_MODE1_EO_PG :: used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode
#define EDIP_TX_PDWN_LITE_DISABLE                          634, 11,  1 // EDIP_TX_CTL_MODE1_EO_PG :: disables the power down lite feature of unused spare lanes (generally should match rx_pdwn_lite_disable)
#define EDIP_TX_WT_PATTERN_LENGTH                          634, 12,  2 // EDIP_TX_CTL_MODE1_EO_PG :: tx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024
#define EDIP_TX_DESKEW_RATE                                634, 14,  1 // EDIP_TX_CTL_MODE1_EO_PG :: tx deskew rate\r\n\tselects between a div1 (1100) and div2 (11110000) deskew pattern rate for both pattern a and b. \r\n\t0: (div2) divided deskew pattern for p9\r\n\t1: (div1) regular deskew pattern for centaur
#define EDIP_TX_SLS_SCRAMBLE_MODE                          635,  0,  2 // EDIP_TX_CTL_MODE2_EO_PG :: selects sls prbs scramble mode for 9th pattern. \r\n\t00:(prbs23) use prbs23\r\n\t01:(prbs7) use prbs7\r\n\t10:(prbs11) use prbs11\r\n\t11:(prbs15) use prbs15
#define EDIP_TX_CLK_UNLOAD_CLK_DISABLE                     635,  2,  1 // EDIP_TX_CTL_MODE2_EO_PG :: set to 0 to clock off sync logic on the clock slice and save power.  it should not be necessary to use the sync logic on the clock slice since it has no fifo but control is available just in case.
#define EDIP_TX_CLK_RUN_COUNT                              635,  3,  1 // EDIP_TX_CTL_MODE2_EO_PG :: set to 1 to enable the tx clock slice serializer.  this should be enabled at all times but control is available just in case.
#define EDIP_TX_CLK_UNLOAD_SEL                             635,  4,  3 // EDIP_TX_CTL_MODE2_EO_PG :: controls the preset value of the tx clock slice unload counter.  this should not be necessary to use on the clock slice but is available just in case.
#define EDIP_TX_CLK_HALF_WIDTH_MODE                        635,  7,  1 // EDIP_TX_CTL_MODE2_EO_PG :: controls the 4to1 pin on tx clock slice.  this should remain 0 but is provided as a chicken switch just in case.
#define EDIP_TX_BUS_WIDTH                                  635,  8,  7 // EDIP_TX_CTL_MODE2_EO_PG :: tx bus width
#define EDIP_TX_BUS_ID                                     633,  0,  6 // EDIP_TX_ID1_PG :: this field is used to programmably set the bus number that a group belongs to.
#define EDIP_TX_START_LANE_ID                              639,  1,  7 // EDIP_TX_ID2_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.
#define EDIP_TX_END_LANE_ID                                639,  9,  7 // EDIP_TX_ID2_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_TX_DRV_CLK_PATTERN_GCRMSG                     636,  0,  2 // EDIP_TX_CTL_CNTLG1_EO_PG :: tx clock drive patterns\r\n\t00:(drv_0s) drive all 0s pattern\r\n\t01:(drv_wt) drive wiretest pattern\r\n\t10:(drv_clk) drive clock pattern\r\n\t11:(unused) unused
#define EDIP_TX_DRV_DATA_PATTERN_GCRMSG                    636,  2,  4 // EDIP_TX_CTL_CNTLG1_EO_PG :: tx drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id)\r\n\t0110:(drv_rxbist) alternate prbs7 pattern for rx bist \r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_prbs7) prbs7 pattern\r\n\t1001:(drv_prbs11) prbs11 pattern\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(drv_prbs15) prbs15 pattern\r\n\t1100:(drv_nvbus) alternate prbs23 for nvbus\r\n\t1101:(drv_prbs31) prbs31 pattern\r\n\t1110:(unused_a) unused\r\n\t1111:(unused_b) unused\r\n\trjr
#define EDIP_TX_ERR_INJ_A_FINE_SEL                         637,  0,  3 // EDIP_TX_CTL_CNTL2_EO_PG :: random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define EDIP_TX_ERR_INJ_A_COARSE_SEL                       637,  3,  4 // EDIP_TX_CTL_CNTL2_EO_PG :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define EDIP_TX_ERR_INJ_A_BER_SEL                          637,  7,  6 // EDIP_TX_CTL_CNTL2_EO_PG :: used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). 
#define EDIP_TX_ERR_INJ_ENABLE                             637, 13,  1 // EDIP_TX_CTL_CNTL2_EO_PG :: overall error injection enable.  when set to 0, all other injection is gated.
#define EDIP_TX_ERR_INJ_CLOCK_ENABLE                       637, 14,  1 // EDIP_TX_CTL_CNTL2_EO_PG :: enable clocks to larger counter and prbs logic.  use this to stagger start times and effectively seed the injection mechanism randomly.
#define EDIP_TX_ERR_INJ_B_FINE_SEL                         638,  0,  3 // EDIP_TX_CTL_CNTL3_EO_PG :: random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define EDIP_TX_ERR_INJ_B_COARSE_SEL                       638,  3,  4 // EDIP_TX_CTL_CNTL3_EO_PG :: random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define EDIP_TX_ERR_INJ_B_BER_SEL                          638,  7,  6 // EDIP_TX_CTL_CNTL3_EO_PG :: used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). 
#define EDIP_TX_DRV_SYNC_PATTERN_GCRMSG                    665,  0,  1 // EDIP_TX_CTLSM_CNTLG1_E_PG :: sync pattern command\r\n\t used to reset the tx prbs register and send an all ones sync pattern followed by changing tx_drv_data_pattern_gcrmsg to send full prbs (code 0101).  the rx prbs register is then reset after seeing the twelve ones if the rx_prbs_check_sync bit is set.  this is set by the training machine after sending the deskew pattern.   \r\n\t0:(sync_gated) sync pattern gated\r\n\t1:(snd_sync) send sync pattern
#define EDIP_TX_ERR_INJ_SLS_MODE                           641,  3,  1 // EDIP_TX_CTL_CNTL2_E_PG :: used to set the random bit error injection for pattern a to work during sls transmission only. 
#define EDIP_TX_ERR_INJ_SLS_ALL_CMD                        641,  4,  1 // EDIP_TX_CTL_CNTL2_E_PG :: used to qualify the sls mode error injection for pattern a, to inject on all sls command transmissions. 
#define EDIP_TX_ERR_INJ_SLS_RECAL                          641,  5,  1 // EDIP_TX_CTL_CNTL2_E_PG :: used to qualify the sls mode error injection for pattern a, to inject on the calibration lane only when not sending an sls command. see workbook for details.
#define EDIP_TX_ERR_INJ_SLS_CMD                            641,  6,  6 // EDIP_TX_CTL_CNTL2_E_PG :: used to qualify the sls mode error injection for pattern a, to inject on only this sls command transmission. see workbook for sls command codes.
#define EDIP_TX_SEG_TEST_MODE                              656,  2,  8 // EDIP_TX_CTLSM_MODE1_EO_PG :: driver segment test mode: all 0 means normal function mode, when this is not 0, segment test begins
#define EDIP_TX_FFE_BOOST_EN                               656, 11,  1 // EDIP_TX_CTLSM_MODE1_EO_PG :: driver segment test: to enable boost function of nvlink tx 
#define EDIP_TX_SEG_TEST_LEAKAGE_CTRL                      656, 13,  1 // EDIP_TX_CTLSM_MODE1_EO_PG :: control txr_txc_sst_ctl_dc in every tx slice. 1 means run segment test in low leakage mode.
#define EDIP_TX_SEG_TEST_CLK_STATUS                        666,  2,  2 // EDIP_TX_CTLSM_STAT1_E_PG :: driver segment test result for clock lane. bit0 for pad p, bit1 for pad n
#define EDIP_TX_PSEG_PRE_EN                                657,  3,  5 // EDIP_TX_CTLSM_CNTL1_EO_PG :: pre bank pseg enable
#define EDIP_TX_PSEG_PRE_SEL                               657,  8,  5 // EDIP_TX_CTLSM_CNTL1_EO_PG :: pre bank pseg mode selection
#define EDIP_TX_NSEG_PRE_EN                                658,  3,  5 // EDIP_TX_CTLSM_CNTL2_EO_PG :: pre bank nseg enable
#define EDIP_TX_NSEG_PRE_SEL                               658,  8,  5 // EDIP_TX_CTLSM_CNTL2_EO_PG :: pre bank nseg mode selection
#define EDIP_TX_PSEG_MARGINPU_EN                           659,  0,  8 // EDIP_TX_CTLSM_CNTL3_EO_PG :: margin pull-up bank pseg enable
#define EDIP_TX_PSEG_MARGINPD_EN                           659,  8,  8 // EDIP_TX_CTLSM_CNTL3_EO_PG :: margin pull-down bank pseg enable
#define EDIP_TX_NSEG_MARGINPU_EN                           660,  0,  8 // EDIP_TX_CTLSM_CNTL4_EO_PG :: margin pull-up bank nseg enable
#define EDIP_TX_NSEG_MARGINPD_EN                           660,  8,  8 // EDIP_TX_CTLSM_CNTL4_EO_PG :: margin pull-down bank nseg enable
#define EDIP_TX_MARGINPU_SEL                               661,  0,  8 // EDIP_TX_CTLSM_CNTL5_EO_PG :: margin pull-up bank mode selection
#define EDIP_TX_MARGINPD_SEL                               661,  8,  8 // EDIP_TX_CTLSM_CNTL5_EO_PG :: margin pull-down bank mode selection
#define EDIP_TX_PSEG_MAIN_EN                               662,  3, 13 // EDIP_TX_CTLSM_CNTL6_EO_PG :: main bank pseg enable
#define EDIP_TX_NSEG_MAIN_EN                               663,  3, 13 // EDIP_TX_CTLSM_CNTL7_EO_PG :: main bank nseg enable
#define EDIP_TX_WT_EN_ALL_CLK_SEGS_GCRMSG                  646,  0,  1 // EDIP_TX_CTL_CNTLG7_E_PG :: tx clock wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.
#define EDIP_TX_WT_EN_ALL_DATA_SEGS_GCRMSG                 646,  1,  1 // EDIP_TX_CTL_CNTLG7_E_PG :: tx data  wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.
#define EDIP_TX_BAD_LANE1_GCRMSG                           650,  0,  7 // EDIP_TX_CTL_STATG1_E_PG :: encoded bad lane one in relation to the entire tx bus
#define EDIP_TX_BAD_LANE2_GCRMSG                           650,  7,  7 // EDIP_TX_CTL_STATG1_E_PG :: encoded bad lane two in relation to the entire tx bus
#define EDIP_TX_BAD_LANE_CODE_GCRMSG                       650, 14,  2 // EDIP_TX_CTL_STATG1_E_PG :: tx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_TX_SLS_LANE_GCRMSG                            643,  0,  7 // EDIP_TX_CTL_CNTLG4_E_PG :: encoded sls lane in relation to the entire tx bus
#define EDIP_TX_SLS_LANE_VAL_GCRMSG                        643,  7,  1 // EDIP_TX_CTL_CNTLG4_E_PG :: tx sls lane valid
#define EDIP_TX_SLS_LANE_SHDW_GCRMSG                       644,  0,  1 // EDIP_TX_CTL_CNTLG5_E_PG :: sls lane shadowing or unshadowing functional data (used to set up tx mux controls)
#define EDIP_TX_SLV_MV_SLS_SHDW_REQ_GCRMSG                 645,  0,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to move sls lane
#define EDIP_TX_SLV_MV_SLS_SHDW_RPR_REQ_GCRMSG             645,  1,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLV_MV_SLS_UNSHDW_REQ_GCRMSG               645,  2,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to move sls lane
#define EDIP_TX_SLV_MV_SLS_UNSHDW_RPR_REQ_GCRMSG           645,  3,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLV_MV_SLS_RPR_REQ_GCRMSG                  645, 11,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLS_LANE_SEL_LG_GCRMSG                     645, 12,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: sets the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios
#define EDIP_TX_SLS_LANE_UNSEL_LG_GCRMSG                   645, 13,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: clears the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios
#define EDIP_TX_SPR_LNS_PDWN_LITE_GCRMSG                   645, 14,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: signals the tx side to power down lite (data gate) unused spare lanes at the end of static repair
#define EDIP_TX_SLV_LGL_RPR_REQ_GCRMSG                     645, 15,  1 // EDIP_TX_CTL_CNTLG6_E_PG :: request to tx slave to set bad lane register to last good lane of the bus (during recal bad lane scenarios)
#define EDIP_TX_SND_SLS_CMD_GCRMSG                         642,  0,  1 // EDIP_TX_CTL_CNTLG3_E_PG :: send sls command or recalibration data
#define EDIP_TX_DYN_RECAL_TSR_IGNORE_GCRMSG                642,  1,  1 // EDIP_TX_CTL_CNTLG3_E_PG :: send dynamic recal sls commands all the time (not just during the status reporting interval)
#define EDIP_TX_SLS_CMD_GCRMSG                             642,  2,  6 // EDIP_TX_CTL_CNTLG3_E_PG :: tx sls command
#define EDIP_TX_SND_SLS_CMD_PREV_GCRMSG                    642,  8,  1 // EDIP_TX_CTL_CNTLG3_E_PG :: revert to sending previous sls command or recalibration data after recovery repair made
#define EDIP_TX_SND_SLS_USING_REG_SCRAMBLE                 642,  9,  1 // EDIP_TX_CTL_CNTLG3_E_PG :: send sls command using normal scramble pattern instead of calibration or 9th pattern
#define EDIP_TX_TDR_DAC_CNTL                               647,  0,  8 // EDIP_TX_CTL_CNTL8_E_PG :: controls variable threshold receiver for tdr function
#define EDIP_TX_TDR_PHASE_SEL                              647,  9,  1 // EDIP_TX_CTL_CNTL8_E_PG :: controls phase select for tdr function, 0 is for _n leg, 1 is for _p leg.
#define EDIP_TX_TDR_PULSE_OFFSET                           648,  0, 12 // EDIP_TX_CTL_CNTL9_E_PG :: offset value for tdr pulse.
#define EDIP_TX_TDR_PULSE_WIDTH                            649,  0, 12 // EDIP_TX_CTL_CNTL10_E_PG :: width of tdr pulse.
#define EDIP_TX_CLR_PAR_ERRS                               653, 14,  1 // EDIP_TX_FIR_RESET_PG :: clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.
#define EDIP_TX_FIR_RESET                                  653, 15,  1 // EDIP_TX_FIR_RESET_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define EDIP_TX_PG_FIR_ERRS_FULL_REG                       651,  0, 16 // EDIP_TX_FIR_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.
#define EDIP_TX_PG_FIR_ERR_TX_SM_REGS                      651,  0,  1 // EDIP_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_GCR_BUFF                        651,  1,  1 // EDIP_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.
#define EDIP_TX_PG_FIR_ERR_GCRS_LD_SM                      651,  2,  1 // EDIP_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_GCRS_UNLD_SM                    651,  3,  1 // EDIP_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_CTL_REGS                        651,  4,  1 // EDIP_TX_FIR_PG :: iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define EDIP_TX_PL_FIR_ERR                                 651, 15,  1 // EDIP_TX_FIR_PG :: summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define EDIP_TX_PG_FIR_ERR_MASK_FULL_REG                   652,  0, 16 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.
#define EDIP_TX_PG_FIR_ERRS_MASK                           652,  0,  5 // EDIP_TX_FIR_MASK_PG :: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define EDIP_TX_PG_FIR_ERR_MASK_TX_SM_REGS                 652,  0,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_MASK_GCR_BUFF                   652,  1,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr buffer.
#define EDIP_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                 652,  2,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM               652,  3,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_CTL_REGS                   652,  4,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_BIST                       652,  5,  1 // EDIP_TX_FIR_MASK_PG :: iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PL_FIR_ERR_MASK                            652, 15,  1 // EDIP_TX_FIR_MASK_PG :: fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.
#define EDIP_TX_PG_FIR_ERR_INJ_FULL_REG                    654,  0, 16 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.
#define EDIP_TX_PG_FIR_ERR_INJ                             654,  0,  5 // EDIP_TX_FIR_ERROR_INJECT_PG :: tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define EDIP_TX_PG_FIR_ERR_INJ_TX_SM_REGS                  654,  0,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_INJ_GCR_BUFF                    654,  1,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.
#define EDIP_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                  654,  2,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                654,  3,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_CTL_REGS                    654,  4,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_BIST                        654,  5,  1 // EDIP_TX_FIR_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_0                     655,  0,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_1                     655,  1,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_2                     655,  2,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_3                     655,  3,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_4                     655,  4,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_5                     655,  5,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_6                     655,  6,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_7                     655,  7,  1 // EDIP_TX_CTLSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_TX_ZCAL_REQ                                   667,  1,  1 // EDIP_TX_IMPCAL_PB :: impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_DONE                                  667,  2,  1 // EDIP_TX_IMPCAL_PB :: impedance calibration sequence complete\r\n\t results are valid when 1.
#define EDIP_TX_ZCAL_ERROR                                 667,  3,  1 // EDIP_TX_IMPCAL_PB :: impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_BUSY                                  667,  4,  1 // EDIP_TX_IMPCAL_PB :: impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define EDIP_TX_ZCAL_FORCE_SAMPLE                          667,  5,  1 // EDIP_TX_IMPCAL_PB :: impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable
#define EDIP_TX_ZCAL_CMP_OUT                               667,  6,  1 // EDIP_TX_IMPCAL_PB :: calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.
#define EDIP_TX_ZCAL_SAMPLE_CNT                            667,  7,  9 // EDIP_TX_IMPCAL_PB :: calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.
#define EDIP_TX_ZCAL_ANS_NOT_FOUND_ERROR                   668,  1,  1 // EDIP_TX_IMPCAL2_PB :: impedance calibration sequence answer not found error\r\n\t indicates, independent of tx_zcal_done, no calibration answer was found. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_ANS_RANGE_ERROR                       668,  2,  1 // EDIP_TX_IMPCAL2_PB :: impedance calibration sequence range check error\r\n\t indicates, independent of tx_zcal_done, the ans is not in max/min range, only works when tx_zcal_range_check is 1. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_TEST_ENABLE                           668,  5,  1 // EDIP_TX_IMPCAL2_PB :: start impedance bist
#define EDIP_TX_ZCAL_TEST_STATUS                           668,  6,  1 // EDIP_TX_IMPCAL2_PB :: this register stores the result of impedance bist
#define EDIP_TX_ZCAL_TEST_DONE                             668,  7,  1 // EDIP_TX_IMPCAL2_PB :: this register is set to 1 when impedance bist is finished
#define EDIP_TX_ZCAL_N                                     669,  0,  9 // EDIP_TX_IMPCAL_NVAL_PB :: calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_P                                     670,  0,  9 // EDIP_TX_IMPCAL_PVAL_PB :: calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_P_4X                                  671,  0,  5 // EDIP_TX_IMPCAL_P_4X_PB :: calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).
#define EDIP_TX_ZCAL_SWO_EN                                672,  0,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_SWO_CAL_SEGS                          672,  1,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define EDIP_TX_ZCAL_SWO_CMP_INV                           672,  2,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define EDIP_TX_ZCAL_SWO_CMP_OFFSET                        672,  3,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.
#define EDIP_TX_ZCAL_SWO_CMP_RESET                         672,  4,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.
#define EDIP_TX_ZCAL_SWO_POWERDOWN                         672,  5,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.
#define EDIP_TX_ZCAL_SWO_TCOIL                             672,  6,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration software circuit tcoil\r\n\t
#define EDIP_TX_ZCAL_RANGE_CHECK                           672,  7,  1 // EDIP_TX_IMPCAL_SWO1_PB :: controls the usage of tx_zcal_sm_min/max_val, 0 means these two registers are used to define the range of zcal. if 1, the calibration range is from 1 to 80, and the min/max registers are only used to check whether the result is in range
#define EDIP_TX_ZCAL_CYA_DATA_INV                          672,  8,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.
#define EDIP_TX_ZCAL_TEST_OVR_2R                           672,  9,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 2r segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_OVR_1R                           672, 10,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 1r segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_OVR_4X_SEG                       672, 11,  1 // EDIP_TX_IMPCAL_SWO1_PB :: impedance calibration test-only 4x segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_CLK_DIV                          672, 12,  1 // EDIP_TX_IMPCAL_SWO1_PB :: this register controls the clock for impedance bist. 1 means the clock is divided by 32. when this register is 0, pll bypass mode is needed.
#define EDIP_TX_ZCAL_SM_MIN_VAL                            673,  0,  7 // EDIP_TX_IMPCAL_SWO2_PB :: impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_ZCAL_SM_MAX_VAL                            673,  7,  7 // EDIP_TX_IMPCAL_SWO2_PB :: impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_PB_SPARE_MODE_0                               674,  0,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_1                               674,  1,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_2                               674,  2,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_3                               674,  3,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_4                               674,  4,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_5                               674,  5,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_6                               674,  6,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_7                               674,  7,  1 // EDIP_SPARE_MODE_PB :: per-bus spare mode latch.
#define EDIP_RX_MODE_PL_FULL_REG                           697,  0, 16 // EDIP_RX_BIT_MODE1_EO_PL :: alias for entire rx_mode_pl register
#define EDIP_RX_LANE_DIG_PDWN                              697,  0,  1 // EDIP_RX_BIT_MODE1_EO_PL :: used to power down digital logic for a lane. 
#define EDIP_RX_BER_DPIPE_MUX_SEL                          697,  1,  1 // EDIP_RX_BIT_MODE1_EO_PL :: diag ber data pipe mux select. when set to a 1 the xor of the main and alt data is muxed onto the main data path feeding the data pipe.
#define EDIP_RX_LANE_SCRAMBLE_DISABLE                      697,  4,  1 // EDIP_RX_BIT_MODE1_EO_PL :: used to disable the rx descrambler on a specific lane or all lanes by using a per-lane/per-group global write.
#define EDIP_RX_PRBS_SCRAMBLE_MODE                         697,  8,  2 // EDIP_RX_BIT_MODE1_EO_PL :: selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 
#define EDIP_RX_FIFO_HALF_WIDTH_MODE                       697, 10,  1 // EDIP_RX_BIT_MODE1_EO_PL :: selects half width mode for rx fifo for slower frequency connections. \r\n\t0: normal width \r\n\t1: half width (bits starting from 0 used, and the second half is unused)
#define EDIP_RX_FIFO_HALF_DEPTH_MODE                       697, 11,  1 // EDIP_RX_BIT_MODE1_EO_PL :: selects half depth mode for rx fifo for power savings when less drift is expected.  \r\n\t0 normal depth \r\n\t1: half depth
#define EDIP_RX_PRBS_SYNC_MODE                             697, 12,  1 // EDIP_RX_BIT_MODE1_EO_PL :: selects prbs sync sequence length.  \r\n\t0: 24-bit ones sequence (default) \r\n\t1: 12-bit ones sequence (legacy)
#define EDIP_RX_PRBS_SEED_VALUE_0_15                       707,  0, 16 // EDIP_RX_BIT_MODE1_E_PL :: rx per-lane prbs seed value\r\n\tused to specify loading value of the prbs scramble pattern when the sync pattern is detected.  this must be set consistent with tx_prbs_seed_value.  see data scrambling workbook section for details.\r\n\twhen connected to legacy centaur parts, the seed must load such that it matches the sequence of those legacy parts.  the patterns listed here match that, including variants required to seed in 12-bit or 24-bit sync mode.\r\n\t0001000000000000:(pattern_24_a_0_15) 24-bit prbs tap point a\r\n\t1111000000111110:(pattern_24_b_0_15) 24-bit prbs tap point b\r\n\t0000011110111100:(pattern_24_c_0_15) 24-bit prbs tap point c\r\n\t0000011111000111:(pattern_24_d_0_15) 24-bit prbs tap point d\r\n\t0000001111101111:(pattern_24_e_0_15) 24-bit prbs tap point e\r\n\t0001111100001111:(pattern_24_f_0_15) 24-bit prbs tap point f\r\n\t0001100000000000:(pattern_24_g_0_15) 24-bit prbs tap point g\r\n\t1001110000000000:(pattern_24_h_0_15) 24-bit prbs tap point h\r\n\t1000010000000000:(pattern_12_a_0_15) 12-bit prbs tap point a\r\n\t0111110000000000:(pattern_12_b_0_15) 12-bit prbs tap point b\r\n\t0000000000001111:(pattern_12_c_0_15) 12-bit prbs tap point c\r\n\t1100000000001111:(pattern_12_d_0_15) 12-bit prbs tap point d\r\n\t1000000000000111:(pattern_12_e_0_15) 12-bit prbs tap point e\r\n\t1000000000111111:(pattern_12_f_0_15) 12-bit prbs tap point f\r\n\t0000011000000000:(pattern_12_g_0_15) 12-bit prbs tap point g\r\n\t0000011100000000:(pattern_12_h_0_15) 12-bit prbs tap point h
#define EDIP_RX_PRBS_SEED_VALUE_16_22                      708,  0,  7 // EDIP_RX_BIT_MODE2_E_PL :: rx per-lane prbs seed value lsbs\r\n\tsee rx_prbs_seed_value_0_15 for details.\r\n\t1000010:(pattern_24_a_16_22) 24-bit prbs tap point a\r\n\t0111110:(pattern_24_b_16_22) 24-bit prbs tap point b\r\n\t0000000:(pattern_24_c_12_acgh_16_22) 24-bit prbs tap point c, and 12-bit prbs tap points a, c, g, and h\r\n\t1100000:(pattern_24_d_16_22) 24-bit prbs tap point d\r\n\t1000000:(pattern_24_ef_16_22) 24-bit prbs tap points e and f\r\n\t0000011:(pattern_24_gh_16_22) 24-bit prbs tap points g and h\r\n\t0111111:(pattern_12_b_16_22) 12-bit prbs tap point b\r\n\t1111000:(pattern_12_d_16_22) 12-bit prbs tap point d\r\n\t1110000:(pattern_12_ef_16_22) 12-bit prbs tap points e and f
#define EDIP_RX_CAL_LANE_SEL                               700,  0,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: selects which lane to recalibrate.
#define EDIP_RX_LANE_INVERT                                700,  1,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: invert the rx lane data
#define EDIP_RX_LANE_INVALID                               700,  2,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: marks this rx slice as invalid and fences other operations.  use this bit, for example, to broadcast a setting to all good lanes but not bad or disabled ones.
#define EDIP_RX_PIPE_SEL                                   700,  3,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: selects what to mux onto the data pipe bus going to the calibration logic. \r\n\t0:(disabled) data \r\n\t1:(enabled) descrambler output 
#define EDIP_RX_PDWN_LITE                                  700,  5,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: when set, partially powers down unused spare lanes when not being recalibrated
#define EDIP_RX_PRBS_CHECK_SYNC                            700,  6,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: enables checking for the 12/24 ui scramble sync pulse in the descramble prbs block. \r\n\t0:(disabled) disable checking (forces prbs_sync_done to 0)\r\n\t1:(enabled) enable checking (prbs_sync_done may go to 1 after identifying the sync pulse)
#define EDIP_RX_PRBS_SEED_DDC                              700,  7,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: set this bit to enable seeding of the ddc prbs block from the data pipe output (either the data stream or the descramble prbs block depending on the value of rx_pipe_sel).
#define EDIP_RX_PRBS_SEED_DFE                              700,  8,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: set this bit to enable seeding of the dfe prbs block from the incoming data stream.
#define EDIP_RX_DFE_FORCE_LOAD_SEED                        700,  9,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: set this bit to force rx_prbs_seed_value_0_15 & rx_prbs_seed_value_16_22 to load directly into the dfe history vector in the analog front-end for this lane.  note that the rx_prbs_seed_value_* bits are extended by 1 bit and shifted by a fixed value to match the pipeline delays between the analog front end and the rx prbs descrambler.  for a user who wishes to set the dfe history vector to a specific value, they will need to reverse that transformation to determine the value they should write to rx_prbs_seed_value_* to get the result they want in the vector.
#define EDIP_RX_PSAVE_MODE_DISABLE                         700, 10,  1 // EDIP_RX_BIT_CNTLX1_EO_PL :: disable psave mode for this physical lane
#define EDIP_RX_FIFO_L2U_DLY                               710,  0,  4 // EDIP_RX_BIT_CNTL2_E_PL :: rx fifo load-to-unload delay, initailed during fifo init and modified thereafter by the deskew machine.  for setting x, the latency is 4*x to 4*x+4 ui.  default is 20-24 ui
#define EDIP_RX_FIFO_INIT                                  709,  0,  1 // EDIP_RX_BIT_CNTL1_E_PL :: initializes the fifo unload counter with the load counter and initializes the fifo load to unload delay
#define EDIP_RX_FIFO_INC_L2U_DLY                           709,  1,  1 // EDIP_RX_BIT_CNTL1_E_PL :: increment existing fifo load-to-unload delay register
#define EDIP_RX_FIFO_DEC_L2U_DLY                           709,  2,  1 // EDIP_RX_BIT_CNTL1_E_PL :: decrement existing fifo load-to-unload delay register
#define EDIP_RX_PRBS_INC                                   709,  3,  1 // EDIP_RX_BIT_CNTL1_E_PL :: shift the prbs pattern forward in time by one extra local cycle (4ui for edi, 2ui for ei4).
#define EDIP_RX_PRBS_DEC                                   709,  4,  1 // EDIP_RX_BIT_CNTL1_E_PL :: shift the prbs pattern back in time by holding it one local cycle (4ui for edi, 2ui for ei4).
#define EDIP_RX_SET_CAL_LANE_SEL                           709,  5,  1 // EDIP_RX_BIT_CNTL1_E_PL :: set rx_cal_lane_sel register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_CAL_LANE_SEL                           709,  6,  1 // EDIP_RX_BIT_CNTL1_E_PL :: clear rx_cal_lane_sel register bit
#define EDIP_RX_SET_PRBS_CHECK_SYNC                        709,  7,  1 // EDIP_RX_BIT_CNTL1_E_PL :: set rx_prbs_check_sync register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_CHECK_SYNC                        709,  8,  1 // EDIP_RX_BIT_CNTL1_E_PL :: clear rx_prbs_check_sync register bit
#define EDIP_RX_SET_EDGE_TRACK_CNTL                        709,  9,  1 // EDIP_RX_BIT_CNTL1_E_PL :: set rx_edge_track_cntl register bits to 11 if rx_lane_invalid is not set
#define EDIP_RX_CLR_EDGE_TRACK_CNTL                        709, 10,  1 // EDIP_RX_BIT_CNTL1_E_PL :: clear rx_edge_track_cntl register bits to 00
#define EDIP_RX_SET_PRBS_SEED_DDC                          709, 11,  1 // EDIP_RX_BIT_CNTL1_E_PL :: set rx_prbs_seed_ddc register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_SEED_DDC                          709, 12,  1 // EDIP_RX_BIT_CNTL1_E_PL :: clear rx_prbs_seed_ddc register bit
#define EDIP_RX_SET_BER_DPIPE_MUX_SEL                      709, 13,  1 // EDIP_RX_BIT_CNTL1_E_PL :: set rx_ber_dpipe_mux_sel register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_BER_DPIPE_MUX_SEL                      709, 14,  1 // EDIP_RX_BIT_CNTL1_E_PL :: clear rx_ber_dpipe_mux_sel register bit
#define EDIP_RX_SET_PIPE_SEL                               711,  0,  1 // EDIP_RX_BIT_CNTL3_E_PL :: set rx_pipe_sel register bit
#define EDIP_RX_CLR_PIPE_SEL                               711,  1,  1 // EDIP_RX_BIT_CNTL3_E_PL :: clear rx_pipe_sel register bit
#define EDIP_RX_SET_PRBS_SEED_DFE                          711,  2,  1 // EDIP_RX_BIT_CNTL3_E_PL :: set rx_prbs_seed_dfe register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_SEED_DFE                          711,  3,  1 // EDIP_RX_BIT_CNTL3_E_PL :: clear rx_prbs_seed_dfe register bit
#define EDIP_RX_PL_SPARE_MODE_0                            693,  0,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_1                            693,  1,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_2                            693,  2,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_3                            693,  3,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_4                            693,  4,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_5                            693,  5,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_6                            693,  6,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_7                            693,  7,  1 // EDIP_RX_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_0                  713,  0,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_1                  713,  1,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_2                  713,  2,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_3                  713,  3,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_4                  713,  4,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_5                  713,  5,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_6                  713,  6,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_7                  713,  7,  1 // EDIP_RX_DATA_WORK_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_0                   675,  0,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_1                   675,  1,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_2                   675,  2,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_3                   675,  3,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_4                   675,  4,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_5                   675,  5,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_6                   675,  6,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_7                   675,  7,  1 // EDIP_RX_DATA_DAC_SPARE_MODE_PL :: per-lane spare mode latch.
#define EDIP_RX_BAD_EYE_OPT_BER                            714,  0,  1 // EDIP_RX_WORK_STAT1_EO_PL :: eye opt step failed ber test--lane marked bad
#define EDIP_RX_BAD_EYE_OPT_WIDTH                          714,  1,  1 // EDIP_RX_WORK_STAT1_EO_PL :: eye opt step failed width test--lane marked bad
#define EDIP_RX_BAD_EYE_OPT_HEIGHT                         714,  2,  1 // EDIP_RX_WORK_STAT1_EO_PL :: eye opt step failed height test--lane marked bad
#define EDIP_RX_BAD_EYE_OPT_DDC                            714,  3,  1 // EDIP_RX_WORK_STAT1_EO_PL :: eye opt step failed dynamic data centering--lane marked bad
#define EDIP_RX_WT_LANE_DISABLED                           714,  4,  1 // EDIP_RX_WORK_STAT1_EO_PL :: wiretest has disabled this lane
#define EDIP_RX_WT_LANE_BAD_CODE                           714,  6,  3 // EDIP_RX_WORK_STAT1_EO_PL :: wiretest lane bad code concatenate rx_wt_lane_inverted with rx_wt_lane_bad_code to get a full status: \r\n\t0000--good lane--not inverted (edi and ei-4)\r\n\t0001--bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010--bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011--bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100--bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101--bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110--bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111--bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000--good lane--inverted (edi and ei-4) \r\n\t1001--bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010--bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011--bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100--bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101--bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110--bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111--bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_WT_LANE_STATUS_ALIAS                       714,  5,  4 // EDIP_RX_WORK_STAT1_EO_PL :: alias for rx_wt_lane_inverted concatenated with rx_wt_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_BAD_BLOCK_LOCK                             714,  9,  1 // EDIP_RX_WORK_STAT1_EO_PL :: deskew step block lock not established--lane marked bad
#define EDIP_RX_BAD_SKEW                                   714, 10,  1 // EDIP_RX_WORK_STAT1_EO_PL :: deskew step skew value not detected--lane marked bad
#define EDIP_RX_BAD_DESKEW                                 714, 11,  1 // EDIP_RX_WORK_STAT1_EO_PL :: deskew step deskew value
#define EDIP_RX_BIST_ERR                                   714, 15,  1 // EDIP_RX_WORK_STAT1_EO_PL :: indicates that rxbist did not find two data eyes of sufficient width.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define EDIP_RX_A_BAD_DFE_CONV                             715,  0,  1 // EDIP_RX_WORK_STAT2_EO_PL :: eye opt step failed dfd convergence on bank a--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define EDIP_RX_B_BAD_DFE_CONV                             715,  1,  1 // EDIP_RX_WORK_STAT2_EO_PL :: eye opt step failed dfd convergence on bank b--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define EDIP_RX_A_H1AP_AT_LIMIT                            715,  2,  1 // EDIP_RX_WORK_STAT2_EO_PL :: eye opt h1/ap ratio limit hit bank a--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define EDIP_RX_B_H1AP_AT_LIMIT                            715,  3,  1 // EDIP_RX_WORK_STAT2_EO_PL :: eye opt h1/ap ratio limit hit bank_b--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define EDIP_RX_A_AP                                       715,  4,  8 // EDIP_RX_WORK_STAT2_EO_PL :: eye opt stored ap value
#define EDIP_RX_A_PATH_OFF_EVEN                            716,  0,  6 // EDIP_RX_WORK_STAT3_EO_PL :: eye opt a bank even path offset
#define EDIP_RX_A_PATH_OFF_ODD                             716,  6,  6 // EDIP_RX_WORK_STAT3_EO_PL :: eye opt a bank odd  path offset
#define EDIP_RX_PRBS_SYNC_DONE                             704,  0,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that sync is done for the descramble prbs block.
#define EDIP_RX_PRBS_SYNC_DONE_B                           704,  1,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that sync is done for the descramble prbs block. inverted version for use by broadcast reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_PRBS_SEED_DDC_DONE                         704,  2,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that seed is done for the ddc prbs block.
#define EDIP_RX_PRBS_SEED_DDC_DONE_B                       704,  3,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that seed is done for the ddc prbs block. active low to enable global reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_PR_NIBBLE_FOUND                            704,  4,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that nibble alignment is done by the cdr logic.  sticky latch.
#define EDIP_RX_DFE_SYNC_DONE                              704,  6,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that sync or seed is done for the prbs function of the analog front end.
#define EDIP_RX_DFE_SYNC_DONE_B                            704,  7,  1 // EDIP_RX_BIT_STAT1_EO_PL :: indicates that sync or seed is done for the prbs function of the analog front end. inverted version for use by broadcast reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_A_BANK_CONTROLS                            676,  0,  6 // EDIP_RX_DAC_CNTL1_EO_PL :: power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define EDIP_RX_LANE_ANA_PDWN                              676,  6,  1 // EDIP_RX_DAC_CNTL1_EO_PL :: lane power down of analog and custom circuits
#define EDIP_RX_PRBS_TEST_DATA                             676,  7,  3 // EDIP_RX_DAC_CNTL1_EO_PL :: prbs test data
#define EDIP_RX_A_CONTROLS                                 677,  0,  6 // EDIP_RX_DAC_CNTL2_EO_PL :: bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tbit5 disables all the h-dacs when a 1\r\n\tcpg
#define EDIP_RX_CM_CNTL                                    677,  6,  3 // EDIP_RX_DAC_CNTL2_EO_PL :: bit0 enables integrator common mode cal, used in conjunction with integrator cal enable\r\n\tbit1 is the polarity bit\r\n\tbit 2 is common mode even when 1, odd when 0 /ncpg
#define EDIP_RX_PR_HALFRATE_MODE                           677, 10,  1 // EDIP_RX_DAC_CNTL2_EO_PL :: sets the rotator into half rate mode
#define EDIP_RX_PR_IQ_RES_SEL                              677, 11,  3 // EDIP_RX_DAC_CNTL2_EO_PL :: phase rotator iq resistor sellect
#define EDIP_RX_A_OFFSET_E0                                678,  0,  7 // EDIP_RX_DAC_CNTL3_EO_PL :: this is the vertical offset of the even low threshold sampling latch.
#define EDIP_RX_A_OFFSET_E1                                678,  8,  7 // EDIP_RX_DAC_CNTL3_EO_PL :: this is the vertical offset of the even high threshold sampling latch.
#define EDIP_RX_A_OFFSET_O0                                679,  0,  7 // EDIP_RX_DAC_CNTL4_EO_PL :: this is the vertical offset of the odd low threshold sampling latch.
#define EDIP_RX_A_OFFSET_O1                                679,  8,  7 // EDIP_RX_DAC_CNTL4_EO_PL :: this is the vertical offset of the odd high threshold sampling latch.
#define EDIP_RX_A_INTEG_COARSE_GAIN                        680,  0,  4 // EDIP_RX_DAC_CNTL5_EO_PL :: this is integrator coarse gain control used in making common mode adjustments. 
#define EDIP_RX_A_EVEN_INTEG_FINE_GAIN                     680,  4,  5 // EDIP_RX_DAC_CNTL5_EO_PL :: this is integrator gain control used in making common mode adjustments.
#define EDIP_RX_A_ODD_INTEG_FINE_GAIN                      680,  9,  5 // EDIP_RX_DAC_CNTL5_EO_PL :: this is integrator gain control used in making common mode adjustments. 
#define EDIP_RX_A_CTLE_PEAK                                681,  0,  5 // EDIP_RX_DAC_CNTL6_EO_PL :: this is the ctle coarse peak value, only 4 bits currently used thinking future  
#define EDIP_RX_A_CTLE_GAIN                                681,  5,  4 // EDIP_RX_DAC_CNTL6_EO_PL :: this is the ctle gain setting           
#define EDIP_RX_A_H1E_VAL                                  682,  0,  8 // EDIP_RX_DAC_CNTL7_EO_PL :: dfe h1 value for even samplers
#define EDIP_RX_A_H1O_VAL                                  682,  8,  8 // EDIP_RX_DAC_CNTL7_EO_PL :: dfe h1 value for odd samplers
#define EDIP_RX_AMP_VAL                                    683,  0,  8 // EDIP_RX_DAC_CNTL8_EO_PL :: rx ampdac value stored as sign magnitude
#define EDIP_RX_A_H2E_VAL                                  684,  0,  6 // EDIP_RX_DAC_CNTL1_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H2O_VAL                                  684,  8,  6 // EDIP_RX_DAC_CNTL1_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H3E_VAL                                  685,  0,  5 // EDIP_RX_DAC_CNTL2_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H3O_VAL                                  685,  8,  5 // EDIP_RX_DAC_CNTL2_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H4E_VAL                                  686,  0,  5 // EDIP_RX_DAC_CNTL3_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H4O_VAL                                  686,  8,  5 // EDIP_RX_DAC_CNTL3_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H5E_VAL                                  687,  0,  5 // EDIP_RX_DAC_CNTL4_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H5O_VAL                                  687,  8,  5 // EDIP_RX_DAC_CNTL4_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H6_VAL                                   688,  0,  5 // EDIP_RX_DAC_CNTL5_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H7_VAL                                   688,  8,  5 // EDIP_RX_DAC_CNTL5_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H8_VAL                                   689,  0,  5 // EDIP_RX_DAC_CNTL6_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H9_VAL                                   689,  8,  5 // EDIP_RX_DAC_CNTL6_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H10_VAL                                  690,  0,  5 // EDIP_RX_DAC_CNTL7_E_PL :: dfe h1 value for even sampler 1
#define EDIP_RX_A_H11_VAL                                  690,  8,  5 // EDIP_RX_DAC_CNTL7_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H12_VAL                                  691,  0,  5 // EDIP_RX_DAC_CNTL8_E_PL :: dfe h1 value for even sampler 0
#define EDIP_RX_A_H1ARATIO_VAL                             692,  0,  7 // EDIP_RX_DAC_CNTL9_E_PL :: this feeds the dac which is used to make the h1 dac and offset dac match the rest of the dacs
#define EDIP_RX_A_H1CAL_VAL                                692,  7,  6 // EDIP_RX_DAC_CNTL9_E_PL :: this feeds the dac which is used to make the h1 dac match a precision referance current
#define EDIP_RX_A_H1CAL_EN                                 692, 13,  1 // EDIP_RX_DAC_CNTL9_E_PL :: this goes to the analog to set its circuits in a mode for calibrating the h1 dac
#define EDIP_RX_PL_FIR_ERRS_FULL_REG                       694,  0, 16 // EDIP_RX_FIR_PL :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define EDIP_RX_PL_FIR_ERRS                                694,  0,  3 // EDIP_RX_FIR_PL :: a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.
#define EDIP_RX_PL_FIR_ERR_PL_REGS                         694,  0,  1 // EDIP_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_DDC_SM                          694,  1,  1 // EDIP_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx ddc state machine.
#define EDIP_RX_PL_FIR_ERR_DAC_REGS                        694,  2,  1 // EDIP_RX_FIR_PL :: iotk alias: parity error has occurred in the per-lane rx data dac regs.
#define EDIP_RX_PL_FIR_ERRS_MASK_FULL_REG                  695,  0, 16 // EDIP_RX_FIR_MASK_PL :: iotk alias: fir mask for rx_fir_pl errors.
#define EDIP_RX_PL_FIR_ERRS_MASK                           695,  0,  3 // EDIP_RX_FIR_MASK_PL :: fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.
#define EDIP_RX_PL_FIR_ERR_MASK_PL_REGS                    695,  0,  1 // EDIP_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane register parity errors.
#define EDIP_RX_PL_FIR_ERR_MASK_DDC_SM                     695,  1,  1 // EDIP_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane rx ddc state machine parity error.
#define EDIP_RX_PL_FIR_ERR_MASK_DAC_REGS                   695,  2,  1 // EDIP_RX_FIR_MASK_PL :: iotk alias: fir mask for per-lane rx data dac regs parity error.
#define EDIP_RX_PL_FIR_ERR_INJ_FULL_REG                    696,  0, 16 // EDIP_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_INJ                             696,  0,  3 // EDIP_RX_FIR_ERROR_INJECT_PL :: rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tbit2: rx per-lane data dac regs parity error inject.
#define EDIP_RX_PL_FIR_ERR_INJ_PL_REGS                     696,  0,  1 // EDIP_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_INJ_DDC_SM                      696,  1,  1 // EDIP_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.
#define EDIP_RX_PL_FIR_ERR_INJ_DAC_REGS                    696,  2,  1 // EDIP_RX_FIR_ERROR_INJECT_PL :: iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx data dac regs.
#define EDIP_RX_PR_PHASE_STEP                              698, 12,  4 // EDIP_RX_BIT_MODE2_EO_PL :: amount to be added or subtracted from to phase rotator accumulator on each shift left or right.  0000: decoded as b10000 in logic, so pr will update every 4 shifts; other values will update with every 4*(16/phase_step) shifts.
#define EDIP_RX_BER_CFG                                    699,  0,  3 // EDIP_RX_BIT_MODE3_EO_PL :: this register controls the bit error rate threshold used for ddc. 
#define EDIP_RX_FIFO_DLY_CFG                               699,  3,  2 // EDIP_RX_BIT_MODE3_EO_PL :: this register controls how many parallel clock cycles we wait after every change to the phase rotator before we begin using the data again. 
#define EDIP_RX_DDC_CFG                                    699,  5,  2 // EDIP_RX_BIT_MODE3_EO_PL :: this register controls how many parallel clock cycles we wait looking for errors as we march further into the edge.
#define EDIP_RX_INIT_TMR_CFG                               699,  9,  3 // EDIP_RX_BIT_MODE3_EO_PL :: this register controls the time we will take to do the initial block lock. this is the number of cycles we wait for the phase rotator to align on the edge before we check for block lock. during the block lock phase we have a 2 up 2 down square wave coming in to lock on. this should be a fairly easy target. keep in mind that since we are using nothing but data to represent both data and edge we could need to move as much as 32 phase rotator steps to find the edge. while way off the edge we should only be limited by the filter setting. the phase rotator filter will normally be set to 16 meaning it will take at least 512 cycles to slew to the edge. as we approach the edge it may take longer per step. in retrospect we maybe should have spread this across a wider range. something we may wish to do for dd2.\r\n\tto be on the safe side i suggest the max value for bringup. it only takes 2.346 us at the longest setting. 
#define EDIP_RX_PR_EDGE_TRACK_CNTL                         701,  0,  2 // EDIP_RX_BIT_CNTL2_EO_PL :: runs edge tracking on the selected bank.  00: no edge tracking, 01: tracks against a data, 10: tracks against b data, 11: unused.
#define EDIP_RX_PR_WOBBLE_A                                701,  2,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: wobbles the pr position for pr a for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define EDIP_RX_PR_DDC_A                                   701,  5,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: enables ddc state machine to go through its ddc routine on pr a.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges. 
#define EDIP_RX_PR_BUMP_TO_EDGE_A                          701,  7,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: bumps pr a position to the edge => +(16 - clkadj).
#define EDIP_RX_PR_BUMP_TO_CENTER                          701,  8,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: bumps pr a position to the center => -(16-clkadj).
#define EDIP_RX_PR_BUMP_SL_1UI                             701,  9,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: bumps the pr position of all prs to the next eye by shifting 32-steps. (not supported)
#define EDIP_RX_PR_BUMP_SR_1UI                             701, 10,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: bumps the pr position to the previous eye by shifting 32-steps. (not supported)
#define EDIP_RX_PR_BUMP_SL_1STEP                           701, 11,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.
#define EDIP_RX_PR_BUMP_SR_1STEP                           701, 12,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.
#define EDIP_RX_PR_USE_DFE_CLOCK_A                         701, 13,  1 // EDIP_RX_BIT_CNTL2_EO_PL :: rx use a-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define EDIP_RX_PR_DATA_A_OFFSET                           702,  0,  6 // EDIP_RX_BIT_CNTL3_EO_PL :: offset value applied to pr a
#define EDIP_RX_PR_DATA_B_OFFSET                           702,  6,  6 // EDIP_RX_BIT_CNTL3_EO_PL :: offset value applied to pr b
#define EDIP_RX_PR_BIT_LOCK_DONE                           702, 12,  1 // EDIP_RX_BIT_CNTL3_EO_PL :: indicates that bit lock is done, used to gate invalid lock in the cdr logic
#define EDIP_RX_PR_INVALID_LOCK_FILTER_EN                  702, 13,  1 // EDIP_RX_BIT_CNTL3_EO_PL :: enables the filtered invalid_lock phase rotator shift_right. default is on.
#define EDIP_RX_PR_INVALID_LOCK_BUMP_SIZE                  702, 14,  2 // EDIP_RX_BIT_CNTL3_EO_PL :: sets the size of the invalid_lock_bump\r\n\t00: 0 steps\r\n\t01: 1 step\r\n\t10: 2 steps\r\n\t11: 4 steps
#define EDIP_RX_PR_TRACE_DDC_STOP                          703,  0,  1 // EDIP_RX_BIT_CNTL4_EO_PL :: enables the trace debug ddc state to stop the state machines.
#define EDIP_RX_PR_TRACE_DDC_SM                            703,  1,  5 // EDIP_RX_BIT_CNTL4_EO_PL :: determines when to stop the state machine for trace debug.
#define EDIP_RX_PR_TRACE_WOBBLE_STOP                       703,  6,  1 // EDIP_RX_BIT_CNTL4_EO_PL :: enables the trace debug wobble state to stop the state machines.
#define EDIP_RX_PR_TRACE_WOBBLE_SM                         703,  7,  3 // EDIP_RX_BIT_CNTL4_EO_PL :: determines when to stop the state machine for trace debug.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_STOP                 703, 10,  1 // EDIP_RX_BIT_CNTL4_EO_PL :: enables the trace debug ddc-dfe offset switch state to stop the state machines.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_SM                   703, 11,  3 // EDIP_RX_BIT_CNTL4_EO_PL :: determines when to stop the state machine for trace debug.
#define EDIP_RX_PR_WOBBLE_A_IP                             705,  2,  1 // EDIP_RX_BIT_STAT2_EO_PL :: wobble in progress on pr a.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define EDIP_RX_PR_DDC_DONE                                705,  5,  1 // EDIP_RX_BIT_STAT2_EO_PL :: dynamic data centering in done on pr a or b.
#define EDIP_RX_PR_DDC_FAILED                              705,  6,  1 // EDIP_RX_BIT_STAT2_EO_PL :: dynamic data centering in failed on pr a or b.
#define EDIP_RX_PR_BUMP_TO_FROM_EDGE_A_DONE                705,  7,  1 // EDIP_RX_BIT_STAT2_EO_PL :: operation to move data pr a to or from the edge is done. (not supported)
#define EDIP_RX_PR_BUMP_SL_1UI_DONE                        705,  8,  1 // EDIP_RX_BIT_STAT2_EO_PL :: bump forward 1-ui into the next eye done.  becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define EDIP_RX_PR_BUMP_SR_1UI_DONE                        705,  9,  1 // EDIP_RX_BIT_STAT2_EO_PL :: bump minus 1-ui into the next eye done   becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away. 
#define EDIP_RX_PR_TRACE_STOPPED                           705, 10,  1 // EDIP_RX_BIT_STAT2_EO_PL :: indicates that the trace bus stop command has asserted.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_IP                   705, 11,  1 // EDIP_RX_BIT_STAT2_EO_PL :: ddc to dfe offset switch in progress on pr.
#define EDIP_RX_PR_L_R_EDGE_A_ALIAS                        706,  0, 12 // EDIP_RX_BIT_STAT3_EO_PL :: rx phase rotator a bank leftand right edge alias
#define EDIP_RX_PR_LEFT_EDGE_A                             706,  0,  6 // EDIP_RX_BIT_STAT3_EO_PL :: rx phase rotator a bank left edge
#define EDIP_RX_PR_RIGHT_EDGE_A                            706,  6,  6 // EDIP_RX_BIT_STAT3_EO_PL :: rx phase rotator a bankright edge
#define EDIP_RX_A_PR_DFE_CLKADJ                            706, 12,  4 // EDIP_RX_BIT_STAT3_EO_PL :: tweak value in phase rotator steps for the bank a clock offset when doing dfe calibration
#define EDIP_RX_PG_SPARE_MODE_0                            717,  0,  1 // EDIP_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_1                            717,  1,  1 // EDIP_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_2                            717,  2,  1 // EDIP_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_3                            717,  3,  1 // EDIP_RX_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_4                            717,  4,  1 // EDIP_RX_SPARE_MODE_PG :: chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.
#define EDIP_RX_CLKDIST_PDWN                               719,  0,  1 // EDIP_RX_CTL_MODE1_EO_PG :: used to disable the rx group clocks and put them into a low power state.
#define EDIP_RX_BIST_MIN_EYE_WIDTH                         719,  3,  6 // EDIP_RX_CTL_MODE1_EO_PG :: rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass.
#define EDIP_RX_A_BIST_EN                                  719,  9,  1 // EDIP_RX_CTL_MODE1_EO_PG :: bist enable pin
#define EDIP_RX_BISTCLK_EN                                 719, 13,  1 // EDIP_RX_CTL_MODE1_EO_PG :: bist clock enable pin
#define EDIP_RX_DFE_CA_CFG                                 720,  0,  2 // EDIP_RX_CTL_MODE2_EO_PG :: rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 8\r\n\t01 - 10\r\n\t10 - 12\r\n\t11 - 14\r\n\t  lab testing will be required to determine the proper value of k.
#define EDIP_RX_SCOPE_CONTROL                              720,  2,  4 // EDIP_RX_CTL_MODE2_EO_PG :: 4 bit value telling which scope bit we are capturing, valid values 0 through 9
#define EDIP_RX_DATA_PIPE_CLR_ON_READ_MODE                 720, 12,  1 // EDIP_RX_CTL_MODE2_EO_PG :: data pipe capture on read mode.  when set, reading rx_data_pipe_16_31 will automatically capture new data.  otherwise rx_data_pipe_capture must be written.
#define EDIP_RX_MASTER_MODE                                764,  0,  1 // EDIP_RX_CTL_MODE1_E_PG :: master mode\r\n\tused to set a chip bus as the master side of the interface. the master side of the interface is where training is kicked off and coordinated in the logic.\r\n\t0:(slave) slave\r\n\t1:(master) master
#define EDIP_RX_DISABLE_FENCE_RESET                        764,  1,  1 // EDIP_RX_CTL_MODE1_E_PG :: set to disable clearing of the rx and tx fence controls at the end of training. \r\n\t0:(enable) clear the fence bit (default) \r\n\t1:(disable) leave the fence in its current state 
#define EDIP_RX_ACT_CHECK_TIMEOUT_SEL                      764,  4,  3 // EDIP_RX_CTL_MODE1_E_PG :: sets activity check timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(128ui) 128 ui \r\n\t010:(256ui) 256 ui \r\n\t011:(512ui) 512 ui \r\n\t100:(1024ui) 1024 ui \r\n\t101:(2048ui) 2048 ui \r\n\t110:(4096ui) 4096 ui \r\n\t111:(infinite) infinite
#define EDIP_RX_BIST_JITTER_PULSE_SEL                      764,  7,  2 // EDIP_RX_CTL_MODE1_E_PG :: rx bist jitter select\r\n\tthis setting induces artificial jitter into the data of the prbs generator during bist to ensure the deadzone between the two eyes of the bist pattern is at least two pr steps wide.\r\n\t00:(steps4) four jitter steps\r\n\t01: (steps2) two jitter steps\r\n\t10: (steps8) eight jitter steps\r\n\t11: (steps0) no jitter
#define EDIP_RX_FENCE                                      764,  9,  1 // EDIP_RX_CTL_MODE1_E_PG :: rx & tx fence bit\r\n\t0:(unfenced) functional data is being driven to & front nest logic\r\n\t1:(fenced) functional data is gated to zeroes to & from nest logic. also indicates that link training not yet complete.
#define EDIP_RX_PDWN_LITE_DISABLE                          764, 10,  1 // EDIP_RX_CTL_MODE1_E_PG :: disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)
#define EDIP_RX_USE_SLS_AS_SPR                             764, 11,  1 // EDIP_RX_CTL_MODE1_E_PG :: determines whether the rx sls lane can be used as a spare lane on the bus to repair bad lanes (note: if yes, recal is disabled once the sls lane has been used as a spare lane.)\r\n\t(note: applies to tx side as well)
#define EDIP_RX_DYN_RECAL_SUSPEND                          764, 12,  1 // EDIP_RX_CTL_MODE1_E_PG :: suspend dynamic recalibration; otherwise starts automatically after link training
#define EDIP_RX_WT_PATTERN_LENGTH                          764, 14,  2 // EDIP_RX_CTL_MODE1_E_PG :: rx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024
#define EDIP_RX_WTR_MAX_BAD_LANES                          765,  0,  5 // EDIP_RX_CTL_MODE2_E_PG :: wiretest max number of bad lanes allowed per clk group\r\n\talso static repair, dynamic repair & recal max number of bad lanes per rx bus (note: should match tx side)
#define EDIP_RX_SLS_EXTEND_SEL                             765,  5,  4 // EDIP_RX_CTL_MODE2_E_PG :: how long to extend sending of the tx sls command (i.e. delay the gcr_wrt_done to the sending sm, see workbook table 4.3 for timer settings)
#define EDIP_RX_DYN_RPR_ENC_BAD_DATA_LANE_SHFT_AMT         765,  9,  7 // EDIP_RX_CTL_MODE2_E_PG :: crc/ecc dynamic repair: programmable register value that is subtracted from the enc_bad_data_lane value provided from the crc/ecc check logic (except for the all 1s clear pattern).  (e.g. should be set to 0x07 for the zmci logic to compensate for disabled lanes, but otherwise generally 0x00.  note: always check figtree for current settings, though, and not this comment!).
#define EDIP_RX_INT_RETURN                                 794, 13,  1 // EDIP_RX_GLBSM_CNTL1_EO_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define EDIP_RX_CLR_PAR_ERRS                               794, 14,  1 // EDIP_RX_GLBSM_CNTL1_EO_PG :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define EDIP_RX_FIR_RESET                                  794, 15,  1 // EDIP_RX_GLBSM_CNTL1_EO_PG :: fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.
#define EDIP_RX_BUS_ID                                     718,  0,  6 // EDIP_RX_ID1_PG :: this field is used to programmably set the bus number that a clkgrp belongs to.
#define EDIP_RX_START_LANE_ID                              763,  1,  7 // EDIP_RX_ID2_PG :: this field is used to programmably set the first lane position in the group but relative to the bus.
#define EDIP_RX_END_LANE_ID                                763,  9,  7 // EDIP_RX_ID2_PG :: this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_RX_TX_BUS_WIDTH                               769,  0,  7 // EDIP_RX_CTL_MODE6_E_PG :: tx bus width
#define EDIP_RX_RX_BUS_WIDTH                               769,  7,  7 // EDIP_RX_CTL_MODE6_E_PG :: rx bus width
#define EDIP_RX_SLS_DISABLE                                770,  0,  1 // EDIP_RX_CTL_MODE7_E_PG :: disables receiving & decoding of sls commands
#define EDIP_TX_SLS_DISABLE                                770,  1,  1 // EDIP_RX_CTL_MODE7_E_PG :: if set, the sls command being sent will always just be a nop.  to truly disable the full sls logic path, also do some combination of the following (depending on what exactly you are trying to do): set the rx_sls_disable, manually override the tx_snd_sls_cmd_gcrmsg per pack registers (if you do not also disable the various sending sms, though, this will eventually get overwritten), set tx_sls_lane_val_gcrmsg to 0 (if there is no valid tx sls lane, no sls command will get sent on it), and/or disable the recal, repair, recovery sms (rx_dyn_recal_suspend, rx_dyn_rpr_disable, rx_sls_rcvy_disable) that initiate the sending of sls commands
#define EDIP_RX_SLS_CNTR_TAP_PTS                           770,  2,  2 // EDIP_RX_CTL_MODE7_E_PG :: how long the sls rx command needs to be stable for.\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) 16 c8 clks\r\n\t01:(tap2) 32 c8 clks\r\n\t10:(tap3) 64 c8 clks\r\n\t11:(tap4) 128 c8 clks
#define EDIP_RX_NONSLS_CNTR_TAP_PTS                        770,  4,  2 // EDIP_RX_CTL_MODE7_E_PG :: how long a non-sls rx command needs to be stable for (to know we have switched from an sls command to data).\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) 32 c8 clks\r\n\t01:(tap2) 64 c8 clks\r\n\t10:(tap3) 128 c8 clks\r\n\t11:(tap4) 256 c8 clks
#define EDIP_RX_SR_FINAL_NOP_TIMEOUT_SEL                   770,  8,  3 // EDIP_RX_CTL_MODE7_E_PG :: hw232404: for ei4 in the case of 2 bad lanes, so no sls lane, how long to wait for final nop during static repair. \r\n\t000:(tap0) 0.8ns (one cycle chicken switch) \r\n\t001:(tap1) 1.7us \r\n\t010:(tap2) 3.4us \r\n\t011:(tap3) 6.8us \r\n\t100:(tap4) 13.6us \r\n\t101:(tap5) 27.2us \r\n\t110:(tap6) 54.6us \r\n\t111:(tap7) infinite
#define EDIP_RX_SLS_EXCEPTION2_CS                          770, 11,  1 // EDIP_RX_CTL_MODE7_E_PG :: hw235842: added chicken switch for new sls exception2 command.  need to set this when mixing allv3 and later logic with logic previous to allv3\r\n\tif set to 1, should set rx_sls_timeout_sel > 4x recal_overall_timeout_sel so avoid sending exception on sr interval and seeing false exception resmr
#define EDIP_RX_START_WDERF_ALIAS                          776,  0,  5 // EDIP_RX_CTL_CNTL1_E_PG :: alias for rx_start_* bits
#define EDIP_RX_START_WIRETEST                             776,  0,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the wiretest portion of the training states.
#define EDIP_RX_START_DESKEW                               776,  1,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the deskew portion of the training states.
#define EDIP_RX_START_EYE_OPT                              776,  2,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the data eye optimization portion of the training states.
#define EDIP_RX_START_REPAIR                               776,  3,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the static lane repair portion of the training states.
#define EDIP_RX_START_FUNC_MODE                            776,  4,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the transition to functional data portion of the training states.
#define EDIP_RX_START_DC_CALIBRATE                         776,  5,  1 // EDIP_RX_CTL_CNTL1_E_PG :: when this register is written to a 1 the training state machine will run the dc calibrate substeps definedin eye optimizations.
#define EDIP_RX_WDERF_DONE_ALIAS                           782,  0,  5 // EDIP_RX_CTL_STAT1_E_PG :: alias for rx_*_done bits
#define EDIP_RX_WIRETEST_DONE                              782,  0,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the wiretest training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_DESKEW_DONE                                782,  1,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the deskew training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_EYE_OPT_DONE                               782,  2,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the eye optimization training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_REPAIR_DONE                                782,  3,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the static lane repair training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_FUNC_MODE_DONE                             782,  4,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the transition to functional data training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_DC_CALIBRATE_DONE                          782,  5,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the dc calibration steps have been completed. check the corresponding rx_dc_calibration_failed register field for the pass/fail status of operation state.
#define EDIP_RX_WDERF_FAILED_ALIAS                         782,  8,  5 // EDIP_RX_CTL_STAT1_E_PG :: alias for rx_*_failed bits
#define EDIP_RX_WIRETEST_FAILED                            782,  8,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the wiretest training state encountered an error.
#define EDIP_RX_DESKEW_FAILED                              782,  9,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the deskew training state encountered an error.
#define EDIP_RX_EYE_OPT_FAILED                             782, 10,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the eye optimization training state encountered an error.
#define EDIP_RX_REPAIR_FAILED                              782, 11,  1 // EDIP_RX_CTL_STAT1_E_PG :: when this bit is read as a 1, the static lane repair training state encountered an error.
#define EDIP_RX_WT_CHECK_COUNT                             767,  0,  5 // EDIP_RX_CTL_MODE4_E_PG :: selects number of extra times the wiretest pattern is checked for a good lane 
#define EDIP_RX_PGOOD_TIMEOUT_SEL                          767,  5,  4 // EDIP_RX_CTL_MODE4_E_PG :: selects pll pgood reset timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite
#define EDIP_RX_PLL_LOCK_TIMEOUT_SEL                       767,  9,  4 // EDIP_RX_CTL_MODE4_E_PG :: selects pll lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite
#define EDIP_RX_PSAVE_TIMER_WAKEUP_MODE                    767, 13,  1 // EDIP_RX_CTL_MODE4_E_PG :: enable wakeup timer on psave mode wakeup
#define EDIP_RX_PSAVE_WAKEUP_LANE0_ENABLE                  767, 14,  1 // EDIP_RX_CTL_MODE4_E_PG :: enable lane 0 at all times as the wakeup lane from psave mode
#define EDIP_RX_SLS_TIMEOUT_SEL                            766,  0,  4 // EDIP_RX_CTL_MODE3_E_PG :: selects spare lane signalling timeout value (how long to wait for a sls handshake command).  value must be 4x larger than tx_dyn_recal_interval_timeout_sel when doing recal aborts and 4x rx_dyn_recal_overall_timeout_sel. (see workbook table 4.4 for timer settings)
#define EDIP_RX_CL_TIMEOUT_SEL                             766,  4,  4 // EDIP_RX_CTL_MODE3_E_PG :: selects clock lock timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DS_SKEW_TIMEOUT_SEL                        766,  8,  4 // EDIP_RX_CTL_MODE3_E_PG :: selects deskew  timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DS_TIMEOUT_SEL                             766, 12,  4 // EDIP_RX_CTL_MODE3_E_PG :: selects deskew  timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DYN_RECAL_OVERALL_TIMEOUT_SEL              721,  0,  3 // EDIP_RX_CTL_MODE5_EO_PG :: dynamic recalibration overall timeout selects\r\n\t000:(tap0) 27.30us - really small value for sim\r\n\t001:(tap1) 436.73us - smallest value for normal operation\r\n\t010:(tap2) 873.46us\r\n\t011:(tap3) 1.75ms\r\n\t100:(tap4) 3.49ms - recal should be around 2ms\r\n\t101:(tap5) 13.97ms\r\n\t110:(tap6) 55.90ms - largest value for normal operation\r\n\t111:(tap7) infinite- for debug purposes
#define EDIP_RX_DYN_RECAL_INTERVAL_TIMEOUT_SEL             721,  3,  3 // EDIP_RX_CTL_MODE5_EO_PG :: rx dynamic recalibration interval timeout selects \r\n\t this timeout determines the time between status reporting timeouts. \r\n\t the actual time of sending a message is selected with rx_dyn_recal_status_rpt_timeout_sel. \r\n\t000:(tap0) 1024ui or 106.5ns\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite
#define EDIP_RX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL           721,  6,  2 // EDIP_RX_CTL_MODE5_EO_PG :: rx dynamic recalibration status reporting timeout selects\r\n\t this timeout determines the time that a status reporting timeout lasts.  the first 1/4 is a blank period, the middle 1/2 is the command message, and the last 1/4 is another blank period. \r\n\t the time between messages is selected with rx_dyn_recal_interval_timeout_sel. \r\n\t00:(tap0) 512ui or 53.2ns\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns
#define EDIP_RX_TRACKING_TIMEOUT_SEL                       721,  8,  4 // EDIP_RX_CTL_MODE5_EO_PG :: time to wait for phase tracking to lock on the edge before proceding in the state machine (see workbook table 4.3 for timer settings)
#define EDIP_RX_PUP_LITE_WAIT_SEL                          721, 12,  4 // EDIP_RX_CTL_MODE5_EO_PG :: how long to wait for analog logic to power up an unused spare lane for recal and repair (see workbook table 4.3 for timer settings)
#define EDIP_RX_ABORT_CHECK_TIMEOUT_SEL                    723,  0,  4 // EDIP_RX_CTL_MODE7_EO_PG :: selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_POLLING_TIMEOUT_SEL                        723,  4,  4 // EDIP_RX_CTL_MODE7_EO_PG :: selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_PSAVE_MODE_TIMEOUT_SEL                     723,  8,  4 // EDIP_RX_CTL_MODE7_EO_PG :: how long to wait for analog logic to power up an unused spare lane for recal and repair (see workbook table 4.3 for timer settings and divide by 8)
#define EDIP_RX_DFE_CONVERGED_CNT_MAX                      736,  0,  4 // EDIP_RX_CTL_MODE20_EO_PG :: number of iterations through dfe h1 and kh1ap adjust before ending dfe unless ended by rx_ap110ap010_delta criteria met\r\n\trjr
#define EDIP_RX_AP110_AP010_DELTA_MAX                      736,  4,  4 // EDIP_RX_CTL_MODE20_EO_PG :: maximum delta between apx110 and apx010 measurements to end dfe h1 and kh1ap adjust unless ended by dfe_converged_cnt_max\r\n\trjr
#define EDIP_RX_EO_CONVERGED_END_COUNT                     722,  0,  4 // EDIP_RX_CTL_MODE6_EO_PG :: rx eye optimization covergence counter end value\r\n\trjr
#define EDIP_RX_HIST_MIN_EYE_WIDTH_MODE                    722,  4,  2 // EDIP_RX_CTL_MODE6_EO_PG :: rx historic eye width and height minimum measurement mode \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_width_lane and  rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_MODE                   722,  6,  2 // EDIP_RX_CTL_MODE6_EO_PG :: rx historic eye height minimum measurement mode--inoperative on naples dd1 hardware--use the rx_hist_min_eye_width_mode control instead--set both the width and height_mode controls to the same value in test routines to maintain compatibiliy \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define EDIP_RX_AMP_GAIN_CNT_MAX                           722,  8,  4 // EDIP_RX_CTL_MODE6_EO_PG :: maximum number of attempts to adjust vga gain before giving up. \r\n\t0000:1 \r\n\t0001: 2 \r\n\t0010:3  \r\n\t0011: 4 \r\n\t0100: 5 \r\n\t0101: 6 \r\n\t0110:7 \r\n\t0111:8  \r\n\t1000:9  \r\n\t1001:10  \r\n\t1010:11  \r\n\t1011:12  \r\n\t1100:13 \r\n\t1101:14 \r\n\t1110:15 \r\n\t1111:16 \r\n\trjr
#define EDIP_RX_RC_SLOWDOWN_TIMEOUT_SEL                    722, 12,  4 // EDIP_RX_CTL_MODE6_EO_PG :: selects recal  slowdown      timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 0   ui or   0us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDIP_RX_FIFO_INITIAL_L2U_DLY                       768,  0,  4 // EDIP_RX_CTL_MODE5_E_PG :: rx fifo initial load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 16-20 ui
#define EDIP_RX_FIFO_FINAL_L2U_DLY                         768,  4,  4 // EDIP_RX_CTL_MODE5_E_PG :: rx fifo final load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 8-12 ui
#define EDIP_RX_WT_TIMEOUT_SEL                             768,  8,  4 // EDIP_RX_CTL_MODE5_E_PG :: selects wiretest timeout value. (see workbook table 4.3 for timer settings)
#define EDIP_RX_SLS_CMD_VAL                                807,  0,  1 // EDIP_RX_GLBSM_STAT7_E_PG :: current sls command valid
#define EDIP_RX_SLS_CMD_ENCODE                             807,  2,  6 // EDIP_RX_GLBSM_STAT7_E_PG :: current sls command
#define EDIP_RX_RECAL_CNT                                  796,  0, 16 // EDIP_RX_GLBSM_STAT2_EO_PG :: number of times bus has been recalibrated since initialization
#define EDIP_RX_DACTEST_ISGT                               797,  0,  1 // EDIP_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is greater than
#define EDIP_RX_DACTEST_ISLT                               797,  1,  1 // EDIP_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is lesser than
#define EDIP_RX_DACTEST_ISEQ                               797,  2,  1 // EDIP_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : is equal to
#define EDIP_RX_DACTEST_DIFF                               797,  3,  9 // EDIP_RX_GLBSM_STAT3_EO_PG :: rx dactest control register : difference 
#define EDIP_RX_INT_REQ                                    798,  0, 16 // EDIP_RX_GLBSM_STAT4_EO_PG :: rx interrupt request isolation latch
#define EDIP_RX_PG_GLBSM_SPARE_MODE_0                      788,  0,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_1                      788,  1,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_2                      788,  2,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_3                      788,  3,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_4                      788,  4,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_5                      788,  5,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_6                      788,  6,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_7                      788,  7,  1 // EDIP_RX_GLBSM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_FIR_TRAINING_ERROR                      792,  0,  1 // EDIP_RX_FIR_TRAINING_PG :: this field is now defunct and is permanently masked in the rx_fir_training_mask_pg fir isolation register.
#define EDIP_RX_PG_FIR_STATIC_SPARE_DEPLOYED               792,  1,  1 // EDIP_RX_FIR_TRAINING_PG :: a spare lane has been deployed during training to heal a lane that was detected as bad. rx_static_spare_deployed (ssd) will be set after the repair training step if during training either wiretest, deskew, eyeopt or repair has detected one or more bad lanes have been detected. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed and the rx_bad_lane.
#define EDIP_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED          792,  2,  1 // EDIP_RX_FIR_TRAINING_PG :: a lane has been detected as bad during training but there are no spare lanes available to heal it. this fir will not be set until the repair training step has been run. this is a catastrophic failure for the bus when in mission mode but all training steps will still be run on whatever good lanes there are. rx_static_max_spares_exceeded will be set if wiretest, deskew, eyeopt or repair find the excessive number of bad lanes.
#define EDIP_RX_PG_FIR_DYNAMIC_REPAIR_ERROR                792,  3,  1 // EDIP_RX_FIR_TRAINING_PG :: a dynamic repair error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.
#define EDIP_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED              792,  4,  1 // EDIP_RX_FIR_TRAINING_PG :: a spare lane has been deployed by ecc/crc logic to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.
#define EDIP_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED         792,  5,  1 // EDIP_RX_FIR_TRAINING_PG :: a lane has been detected as bad by ecc/crc logic but there are no spare lanes to heal it. this is a catastrophic failure for the bus.
#define EDIP_RX_PG_FIR_RECAL_ERROR                         792,  6,  1 // EDIP_RX_FIR_TRAINING_PG :: a recalibration error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.
#define EDIP_RX_PG_FIR_RECAL_SPARE_DEPLOYED                792,  7,  1 // EDIP_RX_FIR_TRAINING_PG :: a spare lane has been deployed during recal to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.
#define EDIP_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED           792,  8,  1 // EDIP_RX_FIR_TRAINING_PG :: a lane has been detected as bad during recal but there are no spare lanes to heal it. this is a catastrophic failure for the bus.
#define EDIP_RX_PG_FIR_TOO_MANY_BUS_ERRORS                 792,  9,  1 // EDIP_RX_FIR_TRAINING_PG :: more than one lane has been detected as having too many errors during functional operation. this is a catastrophic failure for the bus.
#define EDIP_RX_PG_FIR_TRAINING_ERROR_MASK                 793,  0,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_training_error.
#define EDIP_RX_PG_FIR_STATIC_SPARE_DEPLOYED_MASK          793,  1,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_spare_deployed.
#define EDIP_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED_MASK     793,  2,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_static_max_spares_exceeded.
#define EDIP_RX_PG_FIR_DYNAMIC_REPAIR_ERROR_MASK           793,  3,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_repair_error
#define EDIP_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED_MASK         793,  4,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_spare_deployed.
#define EDIP_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED_MASK    793,  5,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_dynamic_max_spares_exceeded.
#define EDIP_RX_PG_FIR_RECAL_ERROR_MASK                    793,  6,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_error.
#define EDIP_RX_PG_FIR_RECAL_SPARE_DEPLOYED_MASK           793,  7,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_spare_deployed.
#define EDIP_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED_MASK      793,  8,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_recal_max_spares_exceeded.
#define EDIP_RX_PG_FIR_TOO_MANY_BUS_ERRORS_MASK            793,  9,  1 // EDIP_RX_FIR_TRAINING_MASK_PG :: fir mask for rx_pg_fir_too_many_bus_errors.
#define EDIP_RX_PG_FIR1_ERRS_FULL_REG                      789,  0, 16 // EDIP_RX_FIR1_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define EDIP_RX_PG_FIR_ERR_PG_REGS                         789,  0,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rxctl registers.
#define EDIP_RX_PG_FIR_ERR_GCR_BUFF                        789,  1,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr buffer.
#define EDIP_RX_PG_FIR_ERR_GCRS_LD_SM                      789,  2,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr load state machine.
#define EDIP_RX_PG_FIR_ERR_GCRS_UNLD_SM                    789,  3,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr unload state machine.
#define EDIP_RX_PG_FIR_ERR_GLBSM_REGS                      789,  4,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_GLBSM_REGRW                     789,  5,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_DATASM_REGS                     789,  6,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_DATASM_REGRW                    789,  7,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_EYEOPT_SM                       789,  8,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_BIST_MAIN_STATE                 789,  9,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_BIST_INIT_STATE                 789, 10,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_RX_SERVO_SM                     789, 11,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_WORK_REGS                       789, 12,  1 // EDIP_RX_FIR1_PG :: iotk alias: parity error has occurred in the per-group rx work regs.
#define EDIP_RX_PL_FIR_ERR                                 789, 13,  1 // EDIP_RX_FIR1_PG :: summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define EDIP_FIR1_ERRS_MASK_FULL_REG                       790,  0, 16 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for rx_fir1_pg errors.
#define EDIP_RX_PG_FIR1_ERRS_MASK                          790,  0, 13 // EDIP_RX_FIR1_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.
#define EDIP_FIR_ERR_MASK_PG_REGS                          790,  0,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl register checker.
#define EDIP_FIR_ERR_MASK_GCR_BUFF                         790,  1,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr buffer.
#define EDIP_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                 790,  2,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr load state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM               790,  3,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GLBSM_REGS                 790,  4,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GLBSM_REGRW                790,  5,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DATASM_REGS                790,  6,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DATASM_REGRW               790,  7,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_EYEOPT_SM                  790,  8,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_BIST_MAIN_STATE            790,  9,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_BIST_INIT_STATE            790, 10,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_RX_SERVO_SM                790, 11,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_WORK_REGS                  790, 12,  1 // EDIP_RX_FIR1_MASK_PG :: iotk alias: fir mask for the per-group rxctl work regs checker.
#define EDIP_RX_PL_FIR_ERR_MASK                            790, 13,  1 // EDIP_RX_FIR1_MASK_PG :: fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.
#define EDIP_RX_PG_FIR1_ERR_INJ_FULL_REG                   791,  0, 16 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PG_FIR1_ERR_INJ                            791,  0, 13 // EDIP_RX_FIR1_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.
#define EDIP_RX_PG_FIR_ERR_INJ_PG_REGS                     791,  0,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GCR_BUFF                    791,  1,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.
#define EDIP_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                  791,  2,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                791,  3,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLBSM_REGS                  791,  4,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLBSM_REGRW                 791,  5,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DATASM_REGS                 791,  6,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DATASM_REGRW                791,  7,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_EYEOPT_SM                   791,  8,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_BIST_MAIN_STATE             791,  9,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_BIST_INIT_STATE             791, 10,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RX_SERVO_SM                 791, 11,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WORK_REGS                   791, 12,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl work regs checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WTM_SM                      791,  7,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WTR_SM                      791,  8,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WTL_SM                      791,  9,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RPR_SM                      791, 10,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DSM_SM                      791, 12,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RXDSM_SM                    791, 13,  1 // EDIP_RX_FIR1_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.
#define EDIP_RX_PG_FIR2_ERRS_FULL_REG                      799,  0,  9 // EDIP_RX_FIR2_PG :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define EDIP_RX_PG_FIR2_ERRS                               799,  0,  9 // EDIP_RX_FIR2_PG :: a per-group register or state machine parity error has occurred.\r\n\tbit0: (err_dyn_rpr_sm) rxctl dynamic repair sm parity error.\r\n\tbit1: (err_sls_hndshk_sm) rxctl sls handshake sm parity error.\r\n\tbit2: (err_rpr_snd_msg_sm) rxctl repair send message sm parity error.\r\n\tbit3: (err_recal_sm) rxctl recal state machine parity error.\r\n\tbit4: reserved.\r\n\tbit5: reserved.\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define EDIP_RX_PG_FIR_ERR_DYN_RPR_SM                      799,  0,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic state machine.
#define EDIP_RX_PG_FIR_ERR_SLS_HNDSHK_SM                   799,  1,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic sls state machine.
#define EDIP_RX_PG_FIR_ERR_DYN_RPR_SND_MSG_SM              799,  2,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group lane repair logic gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_RECAL_SM                        799,  3,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_SLS_ENC_SND_MSG_SM              799,  4,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group sls encode gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_GLB_CAL_SND_MSG_SM              799,  5,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group global cal gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM             799,  6,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_SLS_RCVY_SM                     799,  7,  1 // EDIP_RX_FIR2_PG :: iotk alias: parity error has occurred in the per-group stat repair sls recovery state machine.
#define EDIP_RX_PG_FIR2_ERRS_MASK_FULL_REG                 800,  0,  9 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for rx_fir2_pg errors.
#define EDIP_RX_PG_FIR2_ERRS_MASK                          800,  0,  9 // EDIP_RX_FIR2_MASK_PG :: fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_dyn_rpr_sm) rxctl dynamic repair sm parity error mask.\r\n\tbit1: (mask_sls_hndshk_sm) rxctl sls handshake sm parity error mask.\r\n\tbit2: (mask_rpr_snd_msg_sm) rxctl repair send message sm parity error mask.\r\n\tbit3: (mask_recal_sm) rxctl recal state machine parity error mask.
#define EDIP_RX_PG_FIR_ERR_MASK_DYN_RPR_SM                 800,  0,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_HNDSHK_SM              800,  1,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group lane repair logic sls state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_DYN_RPR_SND_MSG_SM         800,  2,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group dynamic lane repair logic gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_RECAL_SM                   800,  3,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_ENC_SND_MSG_SM         800,  4,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls encode gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_GLB_CAL_SND_MSG_SM         800,  5,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group global cal gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM        800,  6,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group stat repair gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_RCVY_SM                800,  7,  1 // EDIP_RX_FIR2_MASK_PG :: iotk alias: fir mask for the per-group sls recovery state machine.
#define EDIP_RX_PG_FIR2_ERR_INJ_FULL_REG                   801,  0,  9 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PG_FIR2_ERR_INJ                            801,  0,  9 // EDIP_RX_FIR2_ERROR_INJECT_PG :: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_dyn_rpr_sm) rxctl dynamic repair sm parity error inject.\r\n\tbit1: (inj_sls_hndshk_sm) rxctl sls handshake sm parity error inject.\r\n\tbit2: (inj_rpr_snd_msg_sm) rxctl repair send message sm parity error inject.\r\n\tbit3: (inj_recal_sm) rxctl recal state machine parity error inject.
#define EDIP_RX_PG_FIR_ERR_INJ_DYN_RPR_SM                  801,  0,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on per-group lane repair logic state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_HNDSHK_SM               801,  1,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group lane repair logic sls state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DYN_RPR_SND_MSG_SM          801,  2,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group dynamic lane repair logic gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RECAL_SM                    801,  3,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_ENC_SND_MSG_SM          801,  4,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls encode gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLB_CAL_SND_MSG_SM          801,  5,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group global cal gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM         801,  6,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group stat repair gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_RCVY_SM                 801,  7,  1 // EDIP_RX_FIR2_ERROR_INJECT_PG :: iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls recovery state machine parity checker.
#define EDIP_RX_LANE_BAD_VEC_0_15                          783,  0, 16 // EDIP_RX_CTL_STAT2_E_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).  the bad_lane vector is only updated during initial training.  
#define EDIP_RX_LANE_BAD_VEC_16_23                         784,  0,  8 // EDIP_RX_CTL_STAT4_E_PG :: lanes found bad by hw (status) or method to force lane bad from software (control).
#define EDIP_RX_LANE_DISABLED_VEC_0_15                     774,  0, 16 // EDIP_RX_CTL_MODE11_E_PG :: used to set which of group lanes 0-15 are ignored by training logic.  these do not affect powerdown. assumption: static repair assumes lanes are either all disabled at the beginning of the bus or all disabled at the end of the bus.  disabled lanes must be consecutive and start at either the end or beginning of the bus.
#define EDIP_RX_LANE_DISABLED_VEC_16_23                    775,  0,  8 // EDIP_RX_CTL_MODE12_E_PG :: used to set which of group lanes 16-23 are ignored by training logic.  these do not affect powerdown. assumption: static repair assumes lanes are either all disabled at the beginning of the bus or all disabled at the end of the bus.  disabled lanes must be consecutive and start at either the end or beginning of the bus.
#define EDIP_RX_MAIN_INIT_STATE                            802,  0,  4 // EDIP_RX_GLBSM_STAT1_E_PG :: main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused
#define EDIP_RX_WTM_STATE                                  802,  4,  6 // EDIP_RX_GLBSM_STAT1_E_PG :: main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail 
#define EDIP_RX_WTR_STATE                                  802, 10,  5 // EDIP_RX_GLBSM_STAT1_E_PG :: receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused
#define EDIP_RX_WT_CU_PLL_LOCK                             802, 15,  1 // EDIP_RX_GLBSM_STAT1_E_PG :: rx pll locked
#define EDIP_RX_WTR_CUR_LANE                               803,  0,  5 // EDIP_RX_GLBSM_STAT2_E_PG :: wiretest current lane under test
#define EDIP_RX_WTR_BAD_LANE_COUNT                         803, 11,  5 // EDIP_RX_GLBSM_STAT2_E_PG :: wiretest current number of bad lanes in this clk group
#define EDIP_RX_WT_PREV_DONE_GCRMSG                        787,  0,  1 // EDIP_RX_CTL_STATX8_E_PG :: previous clk group has completed wiretest
#define EDIP_RX_WT_ALL_DONE_GCRMSG                         787,  1,  1 // EDIP_RX_CTL_STATX8_E_PG :: all clk groups have completed wiretest
#define EDIP_RX_CD_PREV_DONE_GCRMSG                        787,  2,  1 // EDIP_RX_CTL_STATX8_E_PG :: previous clk group has finished sending & receiving 4 clk/data sls commands
#define EDIP_RX_CD_ALL_DONE_GCRMSG                         787,  3,  1 // EDIP_RX_CTL_STATX8_E_PG :: all clk groups have completed sending & receiving 4 clk/data sls commands.  in the case of the slave side, also the final nop has been received.
#define EDIP_RX_CNTLS_PREV_LDED_GCRMSG                     787,  4,  1 // EDIP_RX_CTL_STATX8_E_PG :: previous clk group has finished updating rx sls/bad lane & repair controls
#define EDIP_RX_WT_CU_PLL_PGOOD                            777,  0,  1 // EDIP_RX_CTL_CNTL4_E_PG :: rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset
#define EDIP_RX_WT_CU_PLL_RESET                            777,  1,  1 // EDIP_RX_CTL_CNTL4_E_PG :: rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing
#define EDIP_RX_WT_CU_PLL_PGOODDLY                         777,  2,  3 // EDIP_RX_CTL_CNTL4_E_PG :: rx pll/dll pgood delay selects length of reset periof after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking periof \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset
#define EDIP_RX_WT_CU_BYP_PLL_LOCK                         777,  6,  1 // EDIP_RX_CTL_CNTL4_E_PG :: override rx pll/dll lock.  this should be ored into places where pll locked is checked (i.e. wt state machine), used to bypass waiting for a pll lock
#define EDIP_RX_WT_PLL_REFCLKSEL                           777,  7,  1 // EDIP_RX_CTL_CNTL4_E_PG :: select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock
#define EDIP_RX_PLL_REFCLKSEL_SCOM_EN                      777,  8,  1 // EDIP_RX_CTL_CNTL4_E_PG :: selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock
#define EDIP_RX_DESKEW_SEQ_GCRMSG                          781,  0,  3 // EDIP_RX_CTL_CNTLX11_E_PG :: rx deskew sequencer gcr messages\r\n\t000:(dsprevdeskewed) indicate prior group deskewed.\r\n\t001:(dsalldeskewed) indicate all groups deskewed.\r\n\t010:(dsprevdone) indicate prior group completed deskew.\r\n\t011:(dsalldone) indicate all groups completed deskew.\r\n\t100:(dsprevskew) transmit skew values from prior group.\r\n\t101:(dsmaxskew) transmit max skew values to all groups.\r\n\t110:(unused) unused.\r\n\t111:(dsnomsg) no message.
#define EDIP_RX_DESKEW_SKMIN_GCRMSG                        781,  4,  6 // EDIP_RX_CTL_CNTLX11_E_PG :: min skew value for deskew sequence.
#define EDIP_RX_DESKEW_SKMAX_GCRMSG                        781, 10,  6 // EDIP_RX_CTL_CNTLX11_E_PG :: max skew value for deskew sequence.
#define EDIP_RX_WTL_SM_STATUS                              759,  0,  5 // EDIP_RX_CTL_STAT3_EO_PG :: wiretest lane machine status    
#define EDIP_RX_WTL_TEST_CLOCK                             756,  0,  1 // EDIP_RX_CTL_CNTL15_EO_PG :: signal from main wt machine to start testing clock lane
#define EDIP_RX_WTL_TEST_DATA                              756,  1,  1 // EDIP_RX_CTL_CNTL15_EO_PG :: signal from main wt machine to start testing data lane
#define EDIP_RX_WT_BS_CLOCK_EN_BYP                         756,  2,  1 // EDIP_RX_CTL_CNTL15_EO_PG :: when asserted, will force the bs enable for the clock, can be used to override the wt state machine controls
#define EDIP_RX_WT_BS_DATA_EN_BYP                          756,  3,  1 // EDIP_RX_CTL_CNTL15_EO_PG :: when asserted, will force the bs enable for the data, can be used to override the wt state machine controls
#define EDIP_RX_DSM_STATE                                  804,  2,  6 // EDIP_RX_GLBSM_STAT3_E_PG :: main deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init tx fifo\r\n\tx02: master driver patt b\r\n\tx03:block lock\r\n\tx04: check skew\r\n\tx05:send skew to other groups\r\n\tx06: wait for max skew message\r\n\tx07: check max skew\r\n\tx08: deskew group\r\n\tx09: send deskewed message\r\n\tx0a: wait for all deskewd message\r\n\tx0b: deskew group\r\n\tx0c: drive prbs sync\r\n\tx0d: wait for prbs synced\r\n\tx0e: send done message\r\n\tx0f: wait for all done message\r\n\tx10: slave drive patt a\r\n\tx11: enable prbs sync checking\r\n\t:x12-x1e: unused\r\n\tx1f: deskew done\r\n\tx20-x22: unused\r\n\tx23: block lock failed\r\n\tx24: group skew measure fail--timeout\r\n\tx25: group skew fail-rxdsm fail\r\n\tx25: bus deskew fail\r\n\tx27: max skew in group fail\r\n\tx28: group deskew timeout fail\r\n\tx29: unused\r\n\tx2a: bus deskew timeout fail\r\n\tx2b-x2c: unused\r\n\tx2d: wait prbs sync timeout fail\r\n\tx2e: timeout while sending done message fail\r\n\tx2f: timeout waiting for bus deskew all done message fail\r\n\tx30-x3f: unused
#define EDIP_RX_RXDSM_STATE                                804,  9,  7 // EDIP_RX_GLBSM_STAT3_E_PG :: rx deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init rx fifo\r\n\tx02: start block lock\r\n\tx03:read block lock status\r\n\tx04: check block lock status\r\n\tx05:check lane valid\r\n\tx06: check max lane count\r\n\tx07: lane block lock status\r\n\tx08: write bad lane block lock\r\n\tx09: block lock done\r\n\tx0a: start check skew\r\n\tx0b: read skew status\r\n\tx0c: check skew status\r\n\tx0d: check valid lanes for skew\r\n\tx0e: check max lane count\r\n\tx0f: read first valid lane skew status\r\n\tx10: write bad skew status\r\n\tx11: check lane count\r\n\t:x12: check other lanes valid\r\n\tx13: read lane skew status\r\n\tx14: write lane bad skew stus\r\n\tx15: send rx skew valid to main deskew machine\r\n\tx16: check lane valid for deskew\r\n\tx17: read skew for deskewing\r\n\tx18:  write new rx fifo load-unload delay\r\n\tx19: write bad skew status\r\n\tx1a check last lane for done\r\n\tx1bb: clear skew status\r\n\tx1c: read global skew status\r\n\tx1d: check global skew status\r\n\tx1e: check lane valid for deskew check\r\n\tx1f: read lane deskew status\r\n\tx20: check lane count for done\r\n\tx21: stop checking skew\r\n\tx22: wait for check prbs sync signal\r\n\tx23: read prbs sync status\r\n\tx24: check prbs sync status\r\n\tx25: prbs synced/deskew done\r\n\tx26: clear deskew control\r\n\tx27: write bad deskew status\r\n\tx28-4d: unused\r\n\tx4e: skew error oddbadd fail\r\n\tx4f-7f: unused
#define EDIP_RX_DESKEW_MAX_LIMIT                           773,  0,  6 // EDIP_RX_CTL_MODE10_E_PG :: maximum deskewable skew fail threshold \r\n\t000000:   0 ui \r\n\t000001:   2 ui \r\n\t000010:   4 ui \r\n\t000011:   6 ui \r\n\t000100:   8 ui \r\n\t000101:  10 ui \r\n\t000110:  12 ui \r\n\t000111:  14 ui \r\n\t001000:  16 ui \r\n\t001001:  18 ui \r\n\t001010:  20 ui \r\n\t001011:  22 ui > ei-4 max \r\n\t001100:  24 ui > ei-4 max \r\n\t001101:  26 ui > ei-4 max \r\n\t001110:  28 ui > ei-4 max \r\n\t001111:  30 ui > ei-4 max \r\n\t010000:  32 ui > ei-4 max \r\n\t010001:  34 ui > ei-4 max \r\n\t010010:  36 ui > ei-4 max \r\n\t010011:  38 ui > ei-4 max \r\n\t010100:  40 ui > ei-4 max \r\n\t010101:  42 ui > ei-4 max \r\n\t010110:  44 ui > ei-4 max \r\n\t010111:  46 ui > ei-4 & edi max \r\n\t011000:  48 ui > ei-4 & edi max \r\n\t011001:  50 ui > ei-4 & edi max \r\n\t011010:  52 ui > ei-4 & edi max \r\n\t011011:  54 ui > ei-4 & edi max \r\n\t011100:  56 ui > ei-4 & edi max \r\n\t011101:  58 ui > ei-4 & edi max \r\n\t011110:  60 ui > ei-4 & edi max \r\n\t011111:  62 ui > ei-4 & edi max \r\n\t100000:  64 ui > ei-4 & edi max \r\n\t100001:  66 ui > ei-4 & edi max \r\n\t100010:  68 ui > ei-4 & edi max \r\n\t100011:  70 ui > ei-4 & edi max \r\n\t100100:  72 ui > ei-4 & edi max \r\n\t100101:  74 ui > ei-4 & edi max \r\n\t100110:  76 ui > ei-4 & edi max \r\n\t100111:  78 ui > ei-4 & edi max \r\n\t101000:  80 ui > ei-4 & edi max \r\n\t101001:  82 ui > ei-4 & edi max \r\n\t101010:  84 ui > ei-4 & edi max \r\n\t101011:  86 ui > ei-4 & edi max \r\n\t101100:  88 ui > ei-4 max \r\n\t101101:  90 ui > ei-4 max \r\n\t101110:  92 ui > ei-4 max \r\n\t101111:  94 ui > ei-4 max \r\n\t110000:  96 ui > ei-4 max \r\n\t110001:  98 ui > ei-4 max \r\n\t110010: 100 ui > ei-4 max \r\n\t110011: 102 ui > ei-4 max \r\n\t110100: 104 ui > ei-4 max \r\n\t110101: 106 ui > ei-4 max \r\n\t110110: 108 ui > ei-4 max \r\n\t110111: 110 ui > ei-4 max \r\n\t111000: 112 ui > ei-4 & edi max \r\n\t111001: 114 ui > ei-4 & edi max \r\n\t111010: 116 ui > ei-4 & edi max \r\n\t111011: 118 ui > ei-4 & edi max \r\n\t111100: 120 ui > ei-4 & edi max \r\n\t111101: 122 ui > ei-4 & edi max \r\n\t111110: 124 ui > ei-4 & edi max \r\n\t111111: 126 ui > ei-4 & edi max 
#define EDIP_RX_DESKEW_MINSKEW_GRP                         786,  0,  6 // EDIP_RX_CTL_STAT6_E_PG :: deskew per-group raw skew min
#define EDIP_RX_DESKEW_MAXSKEW_GRP                         786,  6,  6 // EDIP_RX_CTL_STAT6_E_PG :: deskew per-group raw skew max
#define EDIP_RX_BAD_LANE1                                  809,  0,  7 // EDIP_RX_GLBSM_STAT9_E_PG :: encoded bad lane one in relation to the entire rx bus
#define EDIP_RX_BAD_LANE2                                  809,  7,  7 // EDIP_RX_GLBSM_STAT9_E_PG :: encoded bad lane two in relation to the entire rx bus
#define EDIP_RX_BAD_LANE_CODE                              809, 14,  2 // EDIP_RX_GLBSM_STAT9_E_PG :: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_RX_RPR_STATE                                  805,  0,  7 // EDIP_RX_GLBSM_STAT4_E_PG :: static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state
#define EDIP_RX_SLS_RCVY_STATE                             805,  8,  5 // EDIP_RX_GLBSM_STAT4_E_PG :: sls recovery state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_rcvy_state
#define EDIP_RX_CAL_LANE_GCRMSG                            748,  0,  7 // EDIP_RX_CTL_CNTLX7_EO_PG :: encoded calibration lane in relation to the entire rx bus (including multi-groups or partial groups)
#define EDIP_RX_CAL_LANE_VAL_GCRMSG                        748,  7,  1 // EDIP_RX_CTL_CNTLX7_EO_PG :: rx calibration lane valid
#define EDIP_RX_CAL_LANE_PG_PHY_GCRMSG                     748,  8,  5 // EDIP_RX_CTL_CNTLX7_EO_PG :: encoded calibration lane in relation to the local, physical group.
#define EDIP_RX_QUAD_SEL                                   739,  0,  2 // EDIP_RX_CTL_MODE23_EO_PG :: select 1 of 4 possible phases for the deserialized rx io clock to send along with the data for integration flexibility and tuning for slack into the rx digital logic.
#define EDIP_RX_PEAK_TUNE                                  739, 11,  1 // EDIP_RX_CTL_MODE23_EO_PG :: peak tune bit to analog             
#define EDIP_RX_LTE_EN                                     739, 12,  1 // EDIP_RX_CTL_MODE23_EO_PG :: lte enable                          
#define EDIP_RX_IQHISPD_EN                                 739, 13,  1 // EDIP_RX_CTL_MODE23_EO_PG :: when 1, put the phase rotator in high speed mode  
#define EDIP_RX_DFEHISPD_EN                                739, 14,  1 // EDIP_RX_CTL_MODE23_EO_PG :: when 1, put the dfe in high speed mode according to per-system settings in customer_matrix.xls
#define EDIP_RX_DFE12_EN                                   739, 15,  1 // EDIP_RX_CTL_MODE23_EO_PG :: when 1, we enable logic for dfe h2-h12  
#define EDIP_RX_SLS_USED_AS_SPR                            808,  0,  1 // EDIP_RX_GLBSM_STAT8_E_PG :: when 1, indicates that the sls lane has been used as a spare lane, which disables recal on all lanes.  enabled by rx_use_sls_as_spr.
#define EDIP_RX_DYN_RPR_STATE                              808,  2,  6 // EDIP_RX_GLBSM_STAT8_E_PG :: dynamic repair main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_rpr_state
#define EDIP_RX_SLS_HNDSHK_STATE                           808,  8,  8 // EDIP_RX_GLBSM_STAT8_E_PG :: sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_hndshk_state
#define EDIP_RX_DYN_RPR_REQ_GCRMSG                         778,  0,  1 // EDIP_RX_CTL_CNTLX5_E_PG :: crc/ecc tallying logic has a dynamic repair request
#define EDIP_RX_DYN_RPR_LANE2RPR_GCRMSG                    778,  1,  7 // EDIP_RX_CTL_CNTLX5_E_PG :: crc/ecc tallying logic bad lane to repair
#define EDIP_RX_DYN_RPR_IP_GCRMSG                          778,  8,  1 // EDIP_RX_CTL_CNTLX5_E_PG :: crc/ecc bad lane repair in progress
#define EDIP_RX_DYN_RPR_COMPLETE_GCRMSG                    778,  9,  1 // EDIP_RX_CTL_CNTLX5_E_PG :: crc/ecc bad lane repaired
#define EDIP_RX_DYN_RPR_BAD_LANE_MAX                       771,  0,  7 // EDIP_RX_CTL_MODE8_E_PG :: crc/ecc dynamic repair: max number of times a lane can be found bad before repaired
#define EDIP_RX_DYN_RPR_ERR_CNTR1_DURATION                 771,  7,  4 // EDIP_RX_CTL_MODE8_E_PG :: crc/ecc dynamic repair: duration the lane error counter1 can run before being cleared (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite
#define EDIP_RX_DYN_RPR_CLR_ERR_CNTR1                      771, 11,  1 // EDIP_RX_CTL_MODE8_E_PG :: crc/ecc dynamic repair: firmware-based clear of lane error counter1 register
#define EDIP_RX_DYN_RPR_DISABLE                            771, 12,  1 // EDIP_RX_CTL_MODE8_E_PG :: crc/ecc dynamic repair: when set, disables dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2)
#define EDIP_RX_DYN_RPR_ENC_BAD_DATA_LANE_WIDTH            771, 13,  3 // EDIP_RX_CTL_MODE8_E_PG :: crc/ecc dynamic repair: width of the enc_bad_data_lane vector used to determine number of 1s in clear code
#define EDIP_RX_SERVO_RECAL_IP                             810,  0,  1 // EDIP_RX_GLBSM_STAT10_E_PG :: rx servo lane calibration in progress
#define EDIP_RX_DYN_RECAL_MAIN_STATE                       810,  2,  6 // EDIP_RX_GLBSM_STAT10_E_PG :: dynamic recalibration main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_main_state
#define EDIP_RX_DYN_RECAL_HNDSHK_STATE                     810,  9,  7 // EDIP_RX_GLBSM_STAT10_E_PG :: dynamic recalibration handshake state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_hndshk_state
#define EDIP_RX_DACTEST_LLMT                               752,  0,  9 // EDIP_RX_CTL_CNTL11_EO_PG :: rx dactest control register : lower threshold limit
#define EDIP_RX_DACTEST_RESET                              752,  9,  1 // EDIP_RX_CTL_CNTL11_EO_PG :: rx dactest control register : reset
#define EDIP_RX_DACTEST_START                              752, 10,  1 // EDIP_RX_CTL_CNTL11_EO_PG :: rx dactest control register : start
#define EDIP_RX_DACTEST_HLMT                               753,  0,  9 // EDIP_RX_CTL_CNTL12_EO_PG :: rx dactest control register : higher threshold limit
#define EDIP_RX_EYE_OPT_STATE                              795,  0, 12 // EDIP_RX_GLBSM_STAT1_EO_PG :: eye optimizaton state machine current state 
#define EDIP_RX_WT_CLK_LANE_INVERTED                       785,  1,  1 // EDIP_RX_CTL_STAT5_E_PG :: clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted
#define EDIP_RX_WT_CLK_LANE_BAD_CODE                       785,  2,  3 // EDIP_RX_CTL_STAT5_E_PG :: clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused
#define EDIP_RX_WT_CLK_LANE_STATUS_ALIAS                   785,  1,  4 // EDIP_RX_CTL_STAT5_E_PG :: alias for rx_wt_clk_lane_inverted concatenated with rx_wt_clk_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not swapped/inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--swapped or inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--swapped or inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--swapped or inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--swapped or inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_EO_ENABLE_INTEG_LATCH_OFFSET_CAL           737,  0,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization latch offset adjustment enable with integrator-based disable
#define EDIP_RX_EO_ENABLE_CTLE_COARSE_CAL                  737,  1,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization coarse ctle/peakin enable
#define EDIP_RX_EO_ENABLE_DAC_H1_CAL                       737,  2,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization h! dac calibration to reference
#define EDIP_RX_EO_ENABLE_VGA_CAL                          737,  3,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization vga gainand offset adjust enable
#define EDIP_RX_EO_ENABLE_DFE_H1_CAL                       737,  4,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization dfe h1  adjust enable
#define EDIP_RX_EO_ENABLE_H1AP_TWEAK                       737,  5,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization h1/an pr adjust enable
#define EDIP_RX_EO_ENABLE_DDC                              737,  6,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization dynamic data centering enable
#define EDIP_RX_EO_ENABLE_BER_TEST                         737,  7,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization bit error rate test enable
#define EDIP_RX_EO_ENABLE_RESULT_CHECK                     737,  8,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization final results check enable
#define EDIP_RX_EO_ENABLE_CM_COARSE_CAL                    737,  9,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization common mode coarse calibration enable
#define EDIP_RX_EO_ENABLE_CM_FINE_CAL                      737, 10,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization common mode fine calibration enable
#define EDIP_RX_EO_ENABLE_CTLE_EDGE_TRACK_ONLY             737, 11,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization ctle/peakin enable with edge tracking only
#define EDIP_RX_EO_ENABLE_FINAL_L2U_ADJ                    737, 12,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization final rx fifo load-to-unload delay adjustment enable
#define EDIP_RX_EO_ENABLE_DFE_H2_H12_CAL                   737, 13,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization dfe h2 to h12 calibration enable
#define EDIP_RX_EO_ENABLE_DONE_SIGNALING                   737, 14,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization eye opt done signaling enable
#define EDIP_RX_EO_ENABLE_DAC_H1_TO_A_CAL                  737, 15,  1 // EDIP_RX_CTL_MODE21_EO_PG :: rx eye optimization h! dac to amplitude dac cross-calibration
#define EDIP_RX_EO_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        760,  0,  1 // EDIP_RX_CTL_MODE26_EO_PG :: rx eye optimization first latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_EO_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        760,  1,  1 // EDIP_RX_CTL_MODE26_EO_PG :: rx eye optimization second latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_EO_ENABLE_DFE_H2_H12_SUBSTEP               760,  2, 11 // EDIP_RX_CTL_MODE26_EO_PG :: rx eye optimization individual controls for dfe h2 to h12 tap optimization
#define EDIP_RX_EO_ENABLE_DFE_VOLTAGE_MODE                 760, 13,  1 // EDIP_RX_CTL_MODE26_EO_PG :: rx eye optimization dfe h2 to h12 voltage-mode adjustment enable \r\n\t0: ap an h dual servo mode \r\n\t1: ap1 and ap0 measure mode
#define EDIP_RX_EO_ENABLE_VGA_AMAX_MODE                    760, 14,  1 // EDIP_RX_CTL_MODE26_EO_PG :: rx eye optimization vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define EDIP_RX_RC_ENABLE_INTEG_LATCH_OFFSET_CAL           738,  0,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    latch offset adjustment enable with integrator-based disable
#define EDIP_RX_RC_ENABLE_CTLE_COARSE_CAL                  738,  1,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    coarse ctle/peakin enable
#define EDIP_RX_RC_ENABLE_DAC_H1_CAL                       738,  2,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    h! dac calibration to reference
#define EDIP_RX_RC_ENABLE_VGA_CAL                          738,  3,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    vga gainand offset adjust enable
#define EDIP_RX_RC_ENABLE_DFE_H1_CAL                       738,  4,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    dfe h1  adjust enable
#define EDIP_RX_RC_ENABLE_H1AP_TWEAK                       738,  5,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    h1/an pr adjust enable
#define EDIP_RX_RC_ENABLE_DDC                              738,  6,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    dynamic data centering enable
#define EDIP_RX_RC_ENABLE_BER_TEST                         738,  7,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    bit error rate test enable
#define EDIP_RX_RC_ENABLE_RESULT_CHECK                     738,  8,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    final results check enable
#define EDIP_RX_RC_ENABLE_CM_COARSE_CAL                    738,  9,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    common mode coarse calibration enable
#define EDIP_RX_RC_ENABLE_CM_FINE_CAL                      738, 10,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    common mode fine calibration enable
#define EDIP_RX_RC_ENABLE_CTLE_EDGE_TRACK_ONLY             738, 11,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    ctle/peaking enable with edge tracking only
#define EDIP_RX_RC_ENABLE_DFE_H2_H12_CAL                   738, 13,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    dfe h2 to h12 calibration enable
#define EDIP_RX_RC_ENABLE_DAC_H1_TO_A_CAL                  738, 15,  1 // EDIP_RX_CTL_MODE22_EO_PG :: rx recalibration    h! dac to amplitude dac cross-calibration
#define EDIP_RX_RC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        761,  0,  1 // EDIP_RX_CTL_MODE27_EO_PG :: rx recalibration    first latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_RC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        761,  1,  1 // EDIP_RX_CTL_MODE27_EO_PG :: rx recalibratoin    second latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_RC_ENABLE_DFE_H2_H12_SUBSTEP               761,  2, 11 // EDIP_RX_CTL_MODE27_EO_PG :: rx recalibration    individual controls for dfe h2 to h12 tap optimization
#define EDIP_RX_RC_ENABLE_DFE_VOLTAGE_MODE                 761, 13,  1 // EDIP_RX_CTL_MODE27_EO_PG :: rx recalibration    dfe h2 to h12 voltage-mode adjustment enable \r\n\t0: ap an h dual servo mode \r\n\t1: ap1 and ap0 measure mode
#define EDIP_RX_RC_ENABLE_VGA_AMAX_MODE                    761, 14,  1 // EDIP_RX_CTL_MODE27_EO_PG :: rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define EDIP_RX_DC_ENABLE_CM_COARSE_CAL                    762,  0,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization common mode coarse calibration enable
#define EDIP_RX_DC_ENABLE_CM_FINE_CAL                      762,  1,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization common mode fine calibration enable
#define EDIP_RX_DC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        762,  2,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done prior to ctle
#define EDIP_RX_DC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        762,  3,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done after to ctle
#define EDIP_RX_DC_ENABLE_DAC_H1_CAL                       762,  4,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization h1 dac calibration
#define EDIP_RX_DC_ENABLE_DAC_H1_TO_A_CAL                  762,  5,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization h1 dac to amplitude dac calibration
#define EDIP_RX_DC_ENABLE_INTEG_LATCH_OFFSET_CAL           762,  6,  1 // EDIP_RX_CTL_MODE28_EO_PG :: rx dc cal eye optimization latch offset adjustment enable done prior to integrator
#define EDIP_RX_AMAX_HIGH                                  733,  0,  8 // EDIP_RX_CTL_MODE17_EO_PG :: rx amax high target in amplitude dac steps (as measured by 2ap-amin method) default d120
#define EDIP_RX_AMAX_LOW                                   733,  8,  8 // EDIP_RX_CTL_MODE17_EO_PG :: rx amax low target in amplitude dac steps (as measured by 2ap-amin method)  defaulot d80
#define EDIP_RX_APX111_HIGH                                741,  0,  8 // EDIP_RX_CTL_MODE29_EO_PG :: rx amax high target in amplitude dac steps (as measured by ap_x111 and an_x000) default d102
#define EDIP_RX_APX111_LOW                                 741,  8,  8 // EDIP_RX_CTL_MODE29_EO_PG :: rx amax low target in amplitude dac steps (as measured by ap_x111 and an_x000)  default d68
#define EDIP_RX_CTLE_GAIN_MAX                              735,  0,  4 // EDIP_RX_CTL_MODE19_EO_PG :: rx ctle (vga) gain maximum allowable gain value
#define EDIP_RX_AMP_START_VAL                              735,  8,  8 // EDIP_RX_CTL_MODE19_EO_PG :: rx amp start value, used when making amplitude measurements as the starting point
#define EDIP_RX_TRC_MODE                                   743,  0,  4 // EDIP_RX_CTL_CNTL2_EO_PG :: rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd
#define EDIP_RX_BAD_BUS_LANE_ERR_CNTR_DIS_CLR              806,  0,  1 // EDIP_RX_GLBSM_STAT6_E_PG :: disable clearing of the bad bus lane error counter (aka counter1) when the next crc/ecc error comes in on a new lane
#define EDIP_RX_BAD_BUS_LANE_ERR_CNTR                      806,  1,  7 // EDIP_RX_GLBSM_STAT6_E_PG :: bad bus lane error counter (aka counter1)
#define EDIP_RX_LAST_BAD_BUS_LANE                          806,  9,  7 // EDIP_RX_GLBSM_STAT6_E_PG :: last bad bus lane (bus lane causing the last crc or ecc error)
#define EDIP_RX_DYN_RPR_BAD_BUS_MAX                        772,  0,  7 // EDIP_RX_CTL_MODE9_E_PG :: crc/ecc dynamic repair: max number of times crc or ecc errors can be found on the bus (not included in the bad lane cntr1 tally) before setting a fir error
#define EDIP_RX_DYN_RPR_ERR_CNTR2_DURATION                 772,  7,  4 // EDIP_RX_CTL_MODE9_E_PG :: crc/ecc dynamic repair: duration the bad bus cntr2 error counter can run before being divided by 2 (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite
#define EDIP_RX_DYN_RPR_CLR_ERR_CNTR2                      772, 11,  1 // EDIP_RX_CTL_MODE9_E_PG :: crc/ecc dynamic repair: firmware-based clear of bus error counter2 register
#define EDIP_RX_DYN_RPR_DISABLE2                           772, 12,  1 // EDIP_RX_CTL_MODE9_E_PG :: crc/ecc dynamic repair: when set, disables the repair from the dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2), however leaves the counters running
#define EDIP_RX_MIN_EYE_WIDTH                              725,  2,  6 // EDIP_RX_CTL_MODE9_EO_PG :: minimum acceptable eye width used during init or recal results checking--edi or ei4
#define EDIP_RX_MIN_EYE_HEIGHT                             725,  8,  8 // EDIP_RX_CTL_MODE9_EO_PG :: minimum acceptable eye height used during init or recal results checking--edi only
#define EDIP_RX_MAX_BER_CHECK_COUNT                        724,  8,  8 // EDIP_RX_CTL_MODE8_EO_PG :: maximum acceptable number of bit errors allowable after recal.
#define EDIP_RX_INT_MODE                                   744,  0,  4 // EDIP_RX_CTL_CNTL3_EO_PG :: rx interrupt mode setting
#define EDIP_RX_INT_CURRENT_STATE                          744,  4, 12 // EDIP_RX_CTL_CNTL3_EO_PG :: rx interrupt current state to stop on
#define EDIP_RX_INT_ENABLE_ENC                             745,  0,  4 // EDIP_RX_CTL_CNTL4_EO_PG :: rx interrupt encoded enable
#define EDIP_RX_INT_NEXT_STATE                             745,  4, 12 // EDIP_RX_CTL_CNTL4_EO_PG :: rx interrupt next state to stop on
#define EDIP_RX_INT_GOTO_STATE                             746,  4, 12 // EDIP_RX_CTL_CNTL5_EO_PG :: rx interrupt state to go to upon interrupt trigger
#define EDIP_RX_INT_RETURN_STATE                           747,  4, 12 // EDIP_RX_CTL_CNTL6_EO_PG :: rx interrupt state to go to upon return from interrupt code
#define EDIP_RX_SLV_SHDW_DONE_FIN_GCRMSG                   780,  0,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_done
#define EDIP_RX_SLV_SHDW_NOP_FIN_GCRMSG                    780,  1,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop
#define EDIP_RX_SLV_SHDW_RPR_DONE_FIN_GCRMSG               780,  2,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_rpr_done
#define EDIP_RX_SLV_SHDW_RPR_NOP_FIN_GCRMSG                780,  3,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop
#define EDIP_RX_SLV_UNSHDW_DONE_FIN_GCRMSG                 780,  4,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_done
#define EDIP_RX_SLV_UNSHDW_NOP_FIN_GCRMSG                  780,  5,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop
#define EDIP_RX_SLV_UNSHDW_RPR_DONE_FIN_GCRMSG             780,  6,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_rpr_done
#define EDIP_RX_SLV_UNSHDW_RPR_NOP_FIN_GCRMSG              780,  7,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop
#define EDIP_RX_SLV_RECAL_DONE_NOP_FIN_GCRMSG              780,  8,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal done; need to finish slave recal handshake starting with waiting for nop
#define EDIP_RX_SLV_RECAL_FAIL_NOP_FIN_GCRMSG              780,  9,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal fail; need to finish slave recal handshake starting with waiting for nop
#define EDIP_RX_SLV_RECAL_FRESULTS_FIN_GCRMSG              780, 11,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal fail results; need to finish slave recal handshake starting with waiting for results
#define EDIP_RX_SLV_RECAL_ABORT_ACK_FIN_GCRMSG             780, 12,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal abort; need to finish slave recal handshake starting with waiting for nop
#define EDIP_RX_SLV_RECAL_ABORT_MNOP_FIN_GCRMSG            780, 13,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal abort; need to finish slave recal handshake starting with waiting for nop
#define EDIP_RX_SLV_RECAL_ABORT_SNOP_FIN_GCRMSG            780, 14,  1 // EDIP_RX_CTL_CNTLX10_E_PG :: slave recal abort; need to finish slave recal handshake starting with waiting for nop
#define EDIP_RX_AMP_INIT_TIMEOUT                           730,  0,  4 // EDIP_RX_CTL_MODE14_EO_PG :: rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.3 for timer settings)
#define EDIP_RX_AMP_RECAL_TIMEOUT                          730,  4,  4 // EDIP_RX_CTL_MODE14_EO_PG :: rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.3 for timer settings)
#define EDIP_RX_PEAK_INIT_TIMEOUT                          730,  8,  4 // EDIP_RX_CTL_MODE14_EO_PG :: rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.3 for timer settings)
#define EDIP_RX_PEAK_RECAL_TIMEOUT                         730, 12,  4 // EDIP_RX_CTL_MODE14_EO_PG :: rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.3 for timer settings)
#define EDIP_RX_OFF_INIT_TIMEOUT                           731,  0,  4 // EDIP_RX_CTL_MODE15_EO_PG :: rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.3 for timer settings)
#define EDIP_RX_OFF_RECAL_TIMEOUT                          731,  4,  4 // EDIP_RX_CTL_MODE15_EO_PG :: rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.3 for timer settings)
#define EDIP_RX_CM_TIMEOUT                                 731,  8,  4 // EDIP_RX_CTL_MODE15_EO_PG :: rx_cm_timeout            used for common mode measurements         (see workbook table 4.3 for timer settings)
#define EDIP_RX_AMIN_TIMEOUT                               731, 12,  4 // EDIP_RX_CTL_MODE15_EO_PG :: rx_amin_timeout        used for amin masurements                   (see workbook table 4.3 for timer settings)
#define EDIP_RX_AMP_TIMEOUT                                732,  0,  4 // EDIP_RX_CTL_MODE16_EO_PG :: rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.3 for timer settings)
#define EDIP_RX_USERDEF_TIMEOUT                            732,  4,  4 // EDIP_RX_CTL_MODE16_EO_PG :: rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.3 for timer settings)
#define EDIP_RX_BER_TIMEOUT                                732,  8,  4 // EDIP_RX_CTL_MODE16_EO_PG :: rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.3 for timer settings)
#define EDIP_RX_SPARE4_TIMEOUT                             732, 12,  4 // EDIP_RX_CTL_MODE16_EO_PG :: rx_spare4_timeout just a spare for now                              (see workbook table 4.3 for timer settings)
#define EDIP_RX_AMP_INIT_CFG                               726,  0,  3 // EDIP_RX_CTL_MODE10_EO_PG :: rx_amp_init_cfg   this register controls the servo filter for amplitude measurements during init. see workbook table 4.4 for settings
#define EDIP_RX_AMP_RECAL_CFG                              726,  3,  3 // EDIP_RX_CTL_MODE10_EO_PG :: rx_amp_recal_cfg      this register controls the servo filter for amplitude measurements during recal. see workbook table 4.4 for settings
#define EDIP_RX_PEAK_INIT_CFG                              726,  6,  3 // EDIP_RX_CTL_MODE10_EO_PG :: rx_peak_init_cfg  this register controls the servo filter for peaking during init. see workbook table 4.4 for settings
#define EDIP_RX_PEAK_RECAL_CFG                             726,  9,  3 // EDIP_RX_CTL_MODE10_EO_PG :: rx_peak_recal_cfg      this register controls the servo filter for peaking during recal. see workbook table 4.4 for settings
#define EDIP_RX_AMP_CFG                                    726, 12,  4 // EDIP_RX_CTL_MODE10_EO_PG :: rx_amp_cfg   this register controls the servo filter for rx_amp_0 and rx_amp_1 servo ops. see workbook table 4.4 for settings
#define EDIP_RX_OFF_INIT_CFG                               727,  0,  3 // EDIP_RX_CTL_MODE11_EO_PG :: rx_off_init_cfg   this register controls the servo filter for offset measurements during init. see workbook table 4.4 for settings
#define EDIP_RX_OFF_RECAL_CFG                              727,  3,  3 // EDIP_RX_CTL_MODE11_EO_PG :: rx_off_recal_cfg  this register controls the servo filter for offset measurements during recal. see workbook table 4.4 for settings
#define EDIP_RX_CM_CFG                                     727,  6,  3 // EDIP_RX_CTL_MODE11_EO_PG :: rx_cm_cfg          this register controls the servo during common mode measurement. see workbook table 4.4 for settings
#define EDIP_RX_AMIN_CFG                                   727,  9,  3 // EDIP_RX_CTL_MODE11_EO_PG :: rx_amin_cfg        this register controls the servo filtering used for amin measuremnts. see workbook table 4.4 for settings
#define EDIP_RX_USERDEF_CFG                                727, 12,  4 // EDIP_RX_CTL_MODE11_EO_PG :: rx_user_cfg      this register controls the servo filtering when running the user defined servo ops table 4.4 for settings
#define EDIP_RX_H1AP_CFG                                   740,  0,  2 // EDIP_RX_CTL_MODE24_EO_PG :: this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. \r\n\t00:.5 \r\n\t01:.625 \r\n\t10:.25 \r\n\t11:.375
#define EDIP_RX_CTLE_UPDATE_MODE                           740,  2,  1 // EDIP_RX_CTL_MODE24_EO_PG :: controls updating of ctle_coarse (peaking) values: \r\n\t0: update edge and a or b peaking values while servoing \r\n\t1: update a or b peaking values after edge bank servoing complete
#define EDIP_RX_USER_FILTER_MASK                           740,  8,  8 // EDIP_RX_CTL_MODE24_EO_PG :: rx_user_filter_mask   this register controls the filter and mask for user defined servo ops.
#define EDIP_RX_AMP0_FILTER_MASK                           734,  0,  8 // EDIP_RX_CTL_MODE18_EO_PG :: rx_amp_0_filter_mask   this register controls the filter and mask for the amp_0 servo ops.
#define EDIP_RX_AMP1_FILTER_MASK                           734,  8,  8 // EDIP_RX_CTL_MODE18_EO_PG :: rx_amp_1_filter_mask   this register controls the filter and mask for the amp_1 servo ops.
#define EDIP_RX_SERVO_CHG_CFG                              728,  0,  4 // EDIP_RX_CTL_MODE12_EO_PG :: this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point. 
#define EDIP_RX_DAC_BO_CFG                                 728,  4,  3 // EDIP_RX_CTL_MODE12_EO_PG :: this register controls the time of the dac black out time.  see workbook dfe section
#define EDIP_RX_FILTER_MODE                                728,  7,  2 // EDIP_RX_CTL_MODE12_EO_PG :: servo filter mode. 00 means normal filter duirng entire op. 01 means use the 1/4-1/2 mode, 10 means 1/8-1/4 mode and 11 means the automatic convergence detect mode
#define EDIP_RX_MISC_CFG                                   728,  9,  2 // EDIP_RX_CTL_MODE12_EO_PG :: per group rx misc configureation bits, bit 0 is chicken bit to re-enable the progressive filter mode for peaking, bit 1 when a 1 will enable the clearing of h1 during the amp0, amp1, and usrdef servo ops
#define EDIP_RX_DISABLE_H1_CLEAR                           728, 11,  1 // EDIP_RX_CTL_MODE12_EO_PG :: per group when set will disable the clearing when running servo ops which normally clear and restore the h1 registers
#define EDIP_RX_VOFF_CFG                                   728, 12,  3 // EDIP_RX_CTL_MODE12_EO_PG :: per group configuration regiseter for setting the filter value when running the vref version of offset on edge latches
#define EDIP_RX_LOFF_AMP_EN                                728, 15,  1 // EDIP_RX_CTL_MODE12_EO_PG :: when set to a 1 the amp dac will be enabled during the loff versions of local latch offset cancellation
#define EDIP_RX_CM_OFFSET_VAL                              729,  1,  7 // EDIP_RX_CTL_MODE13_EO_PG :: value used to offset the amp dac when running common mode
#define EDIP_RX_SERVO_THRESH1                              729,  8,  4 // EDIP_RX_CTL_MODE13_EO_PG :: value used as threshold of when to switch to normal filtering mode
#define EDIP_RX_SERVO_THRESH2                              729, 12,  4 // EDIP_RX_CTL_MODE13_EO_PG :: value used as threshold of when we think the servo has converged
#define EDIP_RX_BIST_EN                                    750,  0,  1 // EDIP_RX_CTL_CNTL9_EO_PG :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define EDIP_RX_BIST_EXT_START_MODE                        750,  1,  1 // EDIP_RX_CTL_CNTL9_EO_PG :: this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define EDIP_RX_BIST_INIT_DISABLE                          750,  2,  3 // EDIP_RX_CTL_CNTL9_EO_PG :: each bit disables an individual step of the rx bist init state machine when raised; bit 0 disables the cu pll lock, bit 1 disables the rx fifo init, and bit 2 disables eye opt/training
#define EDIP_RX_BIST_CUPLL_LOCK_CHECK_EN                   750,  5,  1 // EDIP_RX_CTL_CNTL9_EO_PG :: this bit enables the cu pll lock check mode of the rx bist init state machine. when set high, the test will check for the pll lock signal and set an error if it is not present.
#define EDIP_RX_BIST_STORE_EYES_LANE_SEL                   750,  6,  6 // EDIP_RX_CTL_CNTL9_EO_PG :: this register selects which lane to store rx bist eye width data from. the data is stored in the rx_bist_eye_a_width and rx_bist_eye_b_width registers.
#define EDIP_RX_BIST_STORE_EYES_BANK_SEL                   750, 12,  2 // EDIP_RX_CTL_CNTL9_EO_PG :: this register selects which bank to store rx bist eye width data from. \r\n\t00:(bank_a) store bank a widths\r\n\t01:(bank_b) store bank b widths\r\n\t10:(bank_e) store bank e widths\r\n\t11:(unused) unused
#define EDIP_RX_BIST_LL_TEST_EN                            750, 14,  1 // EDIP_RX_CTL_CNTL9_EO_PG :: this bit enables the link test portion of rx bist
#define EDIP_RX_PERVASIVE_CAPT                             750, 15,  1 // EDIP_RX_CTL_CNTL9_EO_PG :: this bit latches glb_ctl and jtag_bndy pervasive signals in iocrc_pervasive_capt when set high. ro reg bit rx_prvcpt_change_det goes high when latched values differ from pervasive inputs.
#define EDIP_RX_BIST_PRBS_TEST_TIME                        751,  0,  4 // EDIP_RX_CTL_CNTL10_EO_PG :: controls how long rx bist will test the prbs7 data for errors. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_BIST_BUS_DATA_MODE                         751,  4,  1 // EDIP_RX_CTL_CNTL10_EO_PG :: this bit enables a mode where rx bist tests data from the bus
#define EDIP_RX_BIST_PRBS_PROP_TIME                        751,  5,  4 // EDIP_RX_CTL_CNTL10_EO_PG :: controls how long rx bist waits between incrementing a phaserot and begining to test the prbs data. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_BIST_PLL_LOCK_TIMEOUT                      751,  9,  4 // EDIP_RX_CTL_CNTL10_EO_PG :: controls how long rx bist init will wait for pll lock signal before timing out. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_BIST_INIT_DONE                             758,  0,  1 // EDIP_RX_CTL_STAT2_EO_PG :: this bit signals completion of the rx bist init state machine.
#define EDIP_RX_BIST_DONE                                  758,  1,  1 // EDIP_RX_CTL_STAT2_EO_PG :: this bit signals completion of the entire rx bist procedure.
#define EDIP_RX_BIST_LL_ERR                                758,  2,  1 // EDIP_RX_CTL_STAT2_EO_PG :: this bit indicates an error was detected during the link layer test portion of rx bist.
#define EDIP_RX_BIST_NO_EDGE_DET                           758,  3,  1 // EDIP_RX_CTL_STAT2_EO_PG :: this bit indicates that one eye was counted to be significantly large (over 60 phase rotator steps).
#define EDIP_RX_BIST_EYE_A_WIDTH                           758,  4,  6 // EDIP_RX_CTL_STAT2_EO_PG :: this register holds the counted eye a width of one particular lane.
#define EDIP_RX_BIST_EYE_B_WIDTH                           758, 10,  6 // EDIP_RX_CTL_STAT2_EO_PG :: this register holds the counted eye b width of one particular lane.
#define EDIP_RX_BER_COUNT_CLR                              812,  1,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define EDIP_RX_BER_TIMER_CLR                              812,  2,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: diag ber timer clear pulse. when written to a 1 the timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define EDIP_RX_SCOPE_CAPTURE                              812,  3,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: when written to a 1 it will cause the scope capture register to copy the current main input
#define EDIP_RX_DATA_PIPE_CAPTURE                          812,  4,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define EDIP_RX_RESET_SERVO_STATUS                         812,  5,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define EDIP_RX_BER_RESET                                  812,  6,  1 // EDIP_RX_DATASM_CNTLX1_EO_PG :: diag ber reset pulse. when written to a 1 it will clear both the error counter and timer.
#define EDIP_RX_PG_PRBS_SCRAMBLE_MODE                      824,  0,  2 // EDIP_RX_DATASM_CNTL1_E_PG :: selects prbs scramble sequence length. \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 
#define EDIP_RX_PG_PRBS_SEED_MODE                          824,  2,  1 // EDIP_RX_DATASM_CNTL1_E_PG :: set this bit to enable seeding of the descramble prbs block from the incoming data stream.
#define EDIP_RX_DESKEW_RATE                                824,  3,  1 // EDIP_RX_DATASM_CNTL1_E_PG :: tx deskew rate\r\n\tselects between a div1 (1100) and div2 (11110000) deskew pattern rate for both pattern a and b. \r\n\t0: (div2) divided deskew pattern for p9\r\n\t1: (div1) regular deskew pattern for centaur
#define EDIP_RX_RUN_DYN_RECAL_TIMER                        824,  4,  1 // EDIP_RX_DATASM_CNTL1_E_PG :: enables checking for the 12/24 ui scramble sync pulse that enables the sls status reporting timer. \r\n\tthis bit should remain set to '1' to run the dynamic recal interval timer until a new full initialization is attempted. \r\n\t0:(disabled) disable checking (forces run_dyn_recal_timer to 0)\r\n\t1:(enabled) enable checking (run_dyn_recal_timer may go to 1 and stay that way after identifying the sync pulse)
#define EDIP_RX_PG_PRBS_SLS_EXPECT                         824,  6,  8 // EDIP_RX_DATASM_CNTL1_E_PG :: when an sls message is expected on the incoming data stream but it must be masked to complete prbs seeding, write the expected value here and it will be reverted and the pure prbs pattern will enter the prbs block.
#define EDIP_RX_BER_EN                                     742,  0,  1 // EDIP_RX_CTL_CNTL1_EO_PG :: diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.
#define EDIP_RX_BER_TIMER_FREEZE_EN                        742,  1,  1 // EDIP_RX_CTL_CNTL1_EO_PG :: diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the timer is frozen when any lane error count saturates in that pack.
#define EDIP_RX_BER_COUNT_FREEZE_EN                        742,  2,  1 // EDIP_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.
#define EDIP_RX_BER_COUNT_SEL                              742,  3,  4 // EDIP_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t0000:(1) 1\r\n\t0001:(2) 2\r\n\t0010:(4) 4\r\n\t0011:(8) 8\r\n\t0100:(16) 16\r\n\t0101:(32) 32\r\n\t0110:(64) 64\r\n\t0111:(128) 128\r\n\t1000: (256) 256\r\n\t1001: (512) 512\r\n\t1010: (1024) 1024\r\n\t1011: (unused1) unused1\r\n\t1100: (unused2) unused2\r\n\t1101: (unused3) unused3\r\n\t1110: (unused4) unused4\r\n\t1111: (unused5) unused5
#define EDIP_RX_BER_TIMER_SEL                              742,  8,  3 // EDIP_RX_CTL_CNTL1_EO_PG :: diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t000:(2tothe31st) 2^31\r\n\t001:(2tothe27th) 2^27\r\n\t010:(2tothe23rd) 2^23\r\n\t011:(2tothe19th) 2^19\r\n\t100:(2tothe17th) 2^17\r\n\t101:(2tothe13th) 2^13\r\n\t110:(2tothe9th) 2^9\r\n\t111:(2tothe5th) 2^5
#define EDIP_RX_BER_CLR_COUNT_ON_READ_EN                   742, 11,  1 // EDIP_RX_CTL_CNTL1_EO_PG :: diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.
#define EDIP_RX_BER_CLR_TIMER_ON_READ_EN                   742, 12,  1 // EDIP_RX_CTL_CNTL1_EO_PG :: diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes timer when it is read from any lane in the pack.
#define EDIP_RX_DATA_PIPE_0_15                             816,  0, 16 // EDIP_RX_DATASM_STAT4_EO_PG :: data pipe captured output bits 0-15.
#define EDIP_RX_DATA_PIPE_16_31                            817,  0, 16 // EDIP_RX_DATASM_STAT5_EO_PG :: data pipe captured output bits 16-31.
#define EDIP_RX_SERVO_OP                                   749,  0, 15 // EDIP_RX_CTL_CNTL8_EO_PG :: servo operation code, written by global training state machine
#define EDIP_RX_SERVO_DONE                                 749, 15,  1 // EDIP_RX_CTL_CNTL8_EO_PG :: servo op completed, read by global training state machine
#define EDIP_RX_SERVO_RESULT                               757,  0,  8 // EDIP_RX_CTL_STAT1_EO_PG :: servo op result, read by global training state machine
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   754,  0,  1 // EDIP_RX_CTL_CNTL13_EO_PG :: rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    754,  1,  5 // EDIP_RX_CTL_CNTL13_EO_PG :: rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         754,  6,  8 // EDIP_RX_CTL_CNTL13_EO_PG :: rx historic eye width minimum value.
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_VALID                  755,  0,  1 // EDIP_RX_CTL_CNTL14_EO_PG :: rx historic eye height minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_LANE                   755,  1,  5 // EDIP_RX_CTL_CNTL14_EO_PG :: rx historic eye height lane number.
#define EDIP_RX_HIST_MIN_EYE_HEIGHT                        755,  6,  8 // EDIP_RX_CTL_CNTL14_EO_PG :: rx historic eye height minimum value (peak-to-peak).
#define EDIP_RX_SERVO_STATUS                               818,  0, 16 // EDIP_RX_DATASM_STAT6_EO_PG :: per group servo status. , bits 0-10 are the servo op captured, bits 11-15 are the lane captured. no error if bits 0 to 10 are all zeroes
#define EDIP_RX_SERVO_CHG_CNT                              819,  0,  4 // EDIP_RX_DATASM_STAT7_EO_PG :: per group servo status. 4 bit value of the number of times the accumulator reversed directions during op, value is fluid except when bit 0 of servo_status is a 1.
#define EDIP_RX_PG_PRBS_SEED_DONE                          819,  5,  1 // EDIP_RX_DATASM_STAT7_EO_PG :: indicates that seed is done for the group prbs block.
#define EDIP_RX_PG_PRBS_SYNC_DONE                          819,  6,  1 // EDIP_RX_DATASM_STAT7_EO_PG :: indicates that sync is done for the per-group prbs block.
#define EDIP_RX_PRVCPT_CHANGE_DET                          819, 15,  1 // EDIP_RX_DATASM_STAT7_EO_PG :: read only bit that signals when a change has been detected in the captured pervasive signals in iocrc_pervasive_capt
#define EDIP_RX_SCAN_P_0_15                                820,  0, 16 // EDIP_RX_DATASM_STAT8_EO_PG :: rx boundary scan ovservation : p  0 to 15
#define EDIP_RX_SCAN_P_16_23                               821,  0,  9 // EDIP_RX_DATASM_STAT9_EO_PG :: rx boundary scan ovservation : p 16 to 23
#define EDIP_RX_SCAN_N_16_23                               822,  8,  8 // EDIP_RX_DATASM_STAT10_EO_PG :: rx boundary scan ovservation : n 16 to 23
#define EDIP_RX_SCAN_N_0_15                                823,  0, 16 // EDIP_RX_DATASM_STAT11_EO_PG :: rx boundary scan ovservation : n  0 to 15
#define EDIP_RX_BER_COUNT                                  813,  0, 11 // EDIP_RX_DATASM_STAT1_EO_PG :: per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.
#define EDIP_RX_BER_COUNT_SATURATED                        813, 11,  1 // EDIP_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter saturation indicator. when 1 indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.
#define EDIP_RX_BER_COUNT_FROZEN_BY_ERR_CNT                813, 12,  1 // EDIP_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter and or pp timer has been frozen by another lanes error counter being saturated.
#define EDIP_RX_BER_COUNT_FROZEN_BY_TIMER                  813, 13,  1 // EDIP_RX_DATASM_STAT1_EO_PG :: pl diag ber error counter has been frozen by a diag ber timer becoming saturated.
#define EDIP_RX_BER_TIMER_SATURATED                        813, 14,  1 // EDIP_RX_DATASM_STAT1_EO_PG :: pl diag ber timer saturation indicator. when 1 indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.
#define EDIP_RX_BER_TIMER_VALUE_0_15                       814,  0, 16 // EDIP_RX_DATASM_STAT2_EO_PG :: pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.
#define EDIP_RX_BER_TIMER_VALUE_16_31                      815,  0, 16 // EDIP_RX_DATASM_STAT3_EO_PG :: pl diag ber timer value, bits 16-31.
#define EDIP_RX_PG_DATASM_SPARE_MODE_0                     811,  0,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_1                     811,  1,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_2                     811,  2,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_3                     811,  3,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_4                     811,  4,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_5                     811,  5,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_6                     811,  6,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_7                     811,  7,  1 // EDIP_RX_DATASM_SPARE_MODE_PG :: per-group spare mode latch.
#define EDIP_RX_INTR_MSG                                   829,  0, 16 // EDIP_RX_INTR_MSG_PB :: dummy intr gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define EDIP_RX_FIR_MSG                                    830,  0,  8 // EDIP_RX_FIR_MSG_PB :: dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define EDIP_RX_PB_CLR_PAR_ERRS                            825, 14,  1 // EDIP_RX_FIR_RESET_PB :: clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.
#define EDIP_RX_PB_FIR_RESET                               825, 15,  1 // EDIP_RX_FIR_RESET_PB :: fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.
#define EDIP_RX_PB_FIR_ERRS_FULL_REG                       826,  0, 10 // EDIP_RX_FIR_PB :: iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.
#define EDIP_RX_PB_FIR_ERRS                                826,  0, 10 // EDIP_RX_FIR_PB :: a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_PB_REGS                         826,  0,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF0                       826,  1,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr buffer.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF1                       826,  2,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF2                       826,  3,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM0                     826,  4,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM1                     826,  5,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM2                     826,  6,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM0                   826,  7,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM1                   826,  8,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM2                   826,  9,  1 // EDIP_RX_FIR_PB :: iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_RX_PB_FIR_ERRS_MASK_FULL_REG                  827,  0, 10 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for rx_fir_pb errors.
#define EDIP_RX_PB_FIR_ERRS_MASK                           827,  0, 10 // EDIP_RX_FIR_MASK_PB :: fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_MASK_PB_REGS                    827,  0,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF0                  827,  1,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr buffer.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF1                  827,  2,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF2                  827,  3,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                827,  4,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                827,  5,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                827,  6,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0              827,  7,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1              827,  8,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2              827,  9,  1 // EDIP_RX_FIR_MASK_PB :: iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_RX_PB_FIR_ERRS_INJ_FULL_REG                   828,  0, 10 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PB_FIR_ERRS_INJ                            828,  0, 10 // EDIP_RX_FIR_ERROR_INJECT_PB :: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_INJ_PB_REGS                     828,  0,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_INJ_GCR_BUFF0                   828,  1,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr buffer.
#define EDIP_RX_PB_FIR_ERR_INJ_GCR_BUFF1                   828,  2,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1.
#define EDIP_RX_PB_FIR_ERR_INJ_GCR_BUFF2                   828,  3,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                 828,  4,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                 828,  5,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                 828,  6,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0               828,  7,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1               828,  8,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2               828,  9,  1 // EDIP_RX_FIR_ERROR_INJECT_PB :: iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_GCR_TEST_MODE                                 831,  0,  1 // EDIP_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define EDIP_ENABLE_GCR_OFL_BUFF                           831,  1,  1 // EDIP_SCOM_MODE_PB :: enables 2nd gcr overflow buffer, one is used by default.
#define EDIP_IORESET_HARD_BUS0                             831,  2,  1 // EDIP_SCOM_MODE_PB :: io hard reset per-bus and gcr reset
#define EDIP_MMIO_PG_REG_ACCESS                            831,  3,  1 // EDIP_SCOM_MODE_PB :: mmio pg register access is blocked by default. setting this bit high grants mmio access to the pg regs.
#define EDIP_SCOM_MODE_PB_SPARES1                          831,  4,  4 // EDIP_SCOM_MODE_PB :: scom mode reg spares.
#define EDIP_GCR_HANG_DET_SEL                              831,  8,  3 // EDIP_SCOM_MODE_PB :: gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 63 cycles\r\n\t010: 127 cycles\r\n\t011: 255 cycles\r\n\t100: 511 cycles\r\n\t101: 1023 cycles\r\n\t110: 2047 cycles\r\n\t111: 4096 cycles.
#define EDIP_GCR_BUFFER_ENABLED                            831, 11,  1 // EDIP_SCOM_MODE_PB :: flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.
#define EDIP_GCR_HANG_ERROR_MASK                           831, 12,  1 // EDIP_SCOM_MODE_PB :: mask for gcr hang error when 2nd buffer is enabled.
#define EDIP_GCR_HANG_ERROR_INJ                            831, 13,  1 // EDIP_SCOM_MODE_PB :: inject for gcr hang error.
#define EDIP_PPE_GCR_MODE                                  831, 14,  1 // EDIP_SCOM_MODE_PB :: gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define EDIP_CHAN_FAIL_MASK                                831, 15,  8 // EDIP_SCOM_MODE_PB :: scom mode reg spares.
#define EDIP_SCOM_MODE_PB_SPARES2                          831, 23,  8 // EDIP_SCOM_MODE_PB :: scom mode reg spares.
#define EDIP_SCOM_PPE_XCR_NONE_0_63                        841,  0, 64 // EDIP_SCOM_PPE_XCR_NONE :: ppe register
#define EDIP_SCOM_PPE_XCR_SPRG0_0_63                       842,  0, 64 // EDIP_SCOM_PPE_XCR_SPRG0 :: ppe register
#define EDIP_SCOM_PPE_IR_SPRG0_0_63                        843,  0, 64 // EDIP_SCOM_PPE_IR_SPRG0 :: ppe register
#define EDIP_SCOM_PPE_XSR_SPRG0_0_63                       844,  0, 64 // EDIP_SCOM_PPE_XSR_SPRG0 :: ppe register
#define EDIP_SCOM_PPE_IR_EDR_0_63                          845,  0, 64 // EDIP_SCOM_PPE_IR_EDR :: ppe register
#define EDIP_SCOM_PPE_XSR_IAR_0_63                         846,  0, 64 // EDIP_SCOM_PPE_XSR_IAR :: ppe register
#define EDIP_SCOM_PPE_MEM_ARB_CSAR_0_63                    847,  0, 64 // EDIP_SCOM_PPE_MEM_ARB_CSAR :: ppe register
#define EDIP_SCOM_PPE_MEM_ARB_CSDR_0_63                    848,  0, 64 // EDIP_SCOM_PPE_MEM_ARB_CSDR :: ppe register
#define EDIP_SCOM_PPE_MEM_ARB_SCR_0_63                     849,  0, 64 // EDIP_SCOM_PPE_MEM_ARB_SCR :: ppe register
#define EDIP_SCOM_PPE_IORESET                              850,  0,  1 // EDIP_SCOM_PPE_CNTL :: ppe register
#define EDIP_SCOM_PPE_PDWN                                 850,  1,  1 // EDIP_SCOM_PPE_CNTL :: ppe register
#define EDIP_SCOM_PPE_INTERRUPT                            850,  2,  1 // EDIP_SCOM_PPE_CNTL :: ppe register
#define EDIP_SCOM_PPE_ARB_ECC_INJECT_ERR                   850,  3,  1 // EDIP_SCOM_PPE_CNTL :: ppe register
#define EDIP_SCOM_PPE_SPARES                               850,  4, 12 // EDIP_SCOM_PPE_CNTL :: ppe register
#define EDIP_SCOM_PPE_WORK1                                851,  0, 32 // EDIP_SCOM_PPE_WORK_REG1 :: ppe register
#define EDIP_SCOM_PPE_WORK2                                852,  0, 32 // EDIP_SCOM_PPE_WORK_REG2 :: ppe register
#define EDIP_SCOM_PPE_FLAGS                                853,  0, 16 // EDIP_SCOM_PPE_FLAGS_REG :: ppe register
#define EDIP_SCOM_PPE_FLAGS_SET                            854,  0, 16 // EDIP_SCOM_PPE_FLAGS_SET_REG :: ppe register
#define EDIP_SCOM_PPE_FLAGS_CLR                            855,  0, 16 // EDIP_SCOM_PPE_FLAGS_CLR_REG :: ppe register

#endif /*P9_IO_REGS_H_*/
