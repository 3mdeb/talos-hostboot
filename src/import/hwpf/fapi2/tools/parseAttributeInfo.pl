#!/usr/bin/perl
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: hwpf/fapi2/tools/parseAttributeInfo.pl $
#
# IBM CONFIDENTIAL
#
# EKB Project
#
# COPYRIGHT 2015,2016
# [+] International Business Machines Corp.
#
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# IBM_PROLOG_END_TAG

use strict;
use Getopt::Long;

#------------------------------------------------------------------------------
# Print Command Line Help
#------------------------------------------------------------------------------
my $arg_output_dir = undef;

# Get the options from the command line - the rest of @ARGV will
# be filenames
GetOptions("output-dir=s" => \$arg_output_dir);

my $numArgs = $#ARGV + 1;
if (($numArgs < 1) || ($arg_output_dir eq undef))
{
    print ("Usage: parseAttributeInfo.pl --output-dir=<output dir> <attr-xml-file1> [<attr-xml-file2> ...]\n");
    print ("  This perl script will parse attribute XML files and create the following files:\n");
    print ("  - attribute_ids.H.          Contains IDs, type, value enums and other information\n");
    print ("  - fapi2_chip_ec_feature.H   Contains a function to query chip EC features\n");
    print ("  - attribute_plat_check.H    Contains compile time checks that all attributes are\n");
    print ("                              handled by the platform\n");
    print ("  - attributesSupported.html  Contains the HWPF attributes supported\n");
    print ("  - attrInfo.csv              Used to process Attribute Override Text files\n");
    print ("  - attrEnumInfo.csv          Used to process Attribute Override Text files\n");
    exit(1);
}

#------------------------------------------------------------------------------
# Specify perl modules to use
#------------------------------------------------------------------------------
use Digest::MD5 qw(md5_hex);
use XML::Simple;
my $xml = new XML::Simple (KeyAttr=>[]);

# Uncomment to enable debug output
#use Data::Dumper;

#------------------------------------------------------------------------------
# Set PREFERRED_PARSER to XML::Parser. Otherwise it uses XML::SAX which contains
# bugs that result in XML parse errors that can be fixed by adjusting white-
# space (i.e. parse errors that do not make sense).
#------------------------------------------------------------------------------
$XML::Simple::PREFERRED_PARSER = 'XML::Parser';

#------------------------------------------------------------------------------
# Open output files for writing
#------------------------------------------------------------------------------
my $aiFile = $arg_output_dir;
$aiFile .= "/";
$aiFile .= "attribute_ids.H";
open(AIFILE, ">", $aiFile);

my $ecHFile = $arg_output_dir;
$ecHFile .= "/";
$ecHFile .= "fapi2_chip_ec_feature.H";
open(ECHFILE, ">", $ecHFile);


my $acFile = $arg_output_dir;
$acFile .= "/";
$acFile .= "attribute_plat_check.H";
open(ACFILE, ">", $acFile);

my $asFile = $arg_output_dir;
$asFile .= "/";
$asFile .= "attributesSupported.html";
open(ASFILE, ">", $asFile);

my $itFile = $arg_output_dir;
$itFile .= "/";
$itFile .= "attrInfo.csv";
open(ITFILE, ">", $itFile);

my $etFile = $arg_output_dir;
$etFile .= "/";
$etFile .= "attrEnumInfo.csv";
open(ETFILE, ">", $etFile);

# TODO: This for platform use only, will support later via RTC 128106 for HB
my $fmFile = $arg_output_dir;
$fmFile .= "/";
$fmFile .= "fapi2AttrOverrideData.H";
open(FMFILE, ">", $fmFile);

my $feFile = $arg_output_dir;
$feFile .= "/";
$feFile .= "fapi2AttrOverrideEnums.H";
open(FEFILE, ">", $feFile);


#------------------------------------------------------------------------------
# Print Start of file information to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "// attribute_ids.H\n";
print AIFILE "// This file is generated by perl script parseAttributeInfo.pl\n\n";
print AIFILE "#ifndef ATTRIBUTEIDS_H_\n";
print AIFILE "#define ATTRIBUTEIDS_H_\n\n";
print AIFILE "#include <target_types.H>\n\n";
print AIFILE "namespace fapi2\n";
print AIFILE "{\n\n";
print AIFILE "\/**\n";
print AIFILE " * \@brief Enumeration of attribute IDs\n";
print AIFILE " *\/\n";
print AIFILE "enum AttributeId\n{\n";

#------------------------------------------------------------------------------
# Print Start of file information to fapi2_chip_ec_feature.H
#------------------------------------------------------------------------------
print ECHFILE "// This file is generated by perl script parseAttributeInfo.pl\n";
print ECHFILE "// It implements the fapi2_chip_ec_feature function\n\n";
print ECHFILE "#ifndef __FAPI2_CHIP_EC_FEATURE_H_\n";
print ECHFILE "#define __FAPI2_CHIP_EC_FEATURE_H_\n";
print ECHFILE "#include <fapi2_attribute_service.H>\n";
print ECHFILE "#include <attribute_ids.H>\n";
print ECHFILE "namespace fapi2\n";
print ECHFILE "{\n\n";
print ECHFILE "// create a unique type from an int ( or attribute id) \n";
print ECHFILE "template<int I>\n";
print ECHFILE  "struct int2Type {\n";
print ECHFILE  "enum { value = I };\n";
print ECHFILE "};\n";
print ECHFILE "ReturnCode queryChipEcAndName(\n";
print ECHFILE "                    const Target<fapi2::TARGET_TYPE_PROC_CHIP |\n";
print ECHFILE "                    fapi2::TARGET_TYPE_MEMBUF_CHIP>& i_target,\n";
print ECHFILE "                    fapi2::ATTR_NAME_Type& , fapi2::ATTR_EC_Type & );\n\n";
print ECHFILE "template<int T>\n";
print ECHFILE "ReturnCode queryChipEcFeature(int2Type<T> id,\n";
print ECHFILE "                    const Target<fapi2::TARGET_TYPE_PROC_CHIP |\n";
print ECHFILE "                    fapi2::TARGET_TYPE_MEMBUF_CHIP>& i_target,\n";
print ECHFILE "                    uint8_t & o_hasFeature)\n";
print ECHFILE "{\n";
print ECHFILE "    fapi2::ATTR_NAME_Type l_chipName;\n";
print ECHFILE "    fapi2::ATTR_EC_Type l_chipEc;\n\n";
print ECHFILE "    o_hasFeature = 0;\n\n";
print ECHFILE "    ReturnCode l_rc = queryChipEcAndName(i_target, l_chipName, l_chipEc);\n";
print ECHFILE "    if (l_rc)\n";
print ECHFILE "    {\n";
print ECHFILE "        FAPI_ERR(\"queryChipEcFeature: error getting chip name\");\n";
print ECHFILE "    }\n";
print ECHFILE "    else\n";
print ECHFILE "    {\n";
print ECHFILE "        o_hasFeature = hasFeature(int2Type<T>(), l_chipName, l_chipEc);\n";
print ECHFILE "    }\n";
print ECHFILE "    return l_rc;\n";
print ECHFILE "}\n\n";

#------------------------------------------------------------------------------
# Print Start of file information to attribute_plat_check.H
#------------------------------------------------------------------------------
print ACFILE "// attribute_plat_check.H\n";
print ACFILE "// This file is generated by perl script parseAttributeInfo.pl\n";
print ACFILE "// A platform can include it to ensure that it handles all HWPF\n";
print ACFILE "// attributes\n\n";
print ACFILE "#ifndef ATTRIBUTEPLATCHECK_H_\n";
print ACFILE "#define ATTRIBUTEPLATCHECK_H_\n\n";

#------------------------------------------------------------------------------
# Print Start of file information to attributesSupported.html
#------------------------------------------------------------------------------
print ASFILE "<html>\n";
print ASFILE "<body>\n\n";
print ASFILE "<!-- attributesSupported.html -->\n";
print ASFILE "<!-- This file is generated by perl script parseAttributeInfo.pl -->\n";
print ASFILE "<!-- It lists all HWPF attributes supported -->\n\n";
print ASFILE "<h4>HWPF Attributes supported by this build.</h4>\n";
print ASFILE "<table border=\"4\">\n";
print ASFILE "<tr><th>Attribute ID</th><th>Attribute Description</th></tr>";

#------------------------------------------------------------------------------
# Print Start of file information to attrInfo.csv
#------------------------------------------------------------------------------
print ITFILE "# attrInfo.csv\n";
print ITFILE "# This file is generated by perl script parseAttributeInfo.pl\n";
print ITFILE "# It lists information about FAPI attributes and is used to\n";
print ITFILE "# process FAPI Attribute text files (overrides/syncs)\n";
print ITFILE "# Format:\n";
print ITFILE "# <FAPI-ATTR-ID-STR>,<LAYER-ATTR-ID-STR>,<ATTR-ID-VAL>,<ATTR-TYPE>\n";
print ITFILE "# Note that for the AttributeTanks at the FAPI layer, the\n";
print ITFILE "# FAPI-ATTR-ID-STR and LAYER-ATTR-ID-STR will be identical\n";

#------------------------------------------------------------------------------
# Print Start of file information to attrEnumInfo.csv
#------------------------------------------------------------------------------
print ETFILE "# attrEnumInfo.csv\n";
print ETFILE "# This file is generated by perl script parseAttributeInfo.pl\n";
print ETFILE "# It lists information about FAPI attribute enumerators and is\n";
print ETFILE "# used to process FAPI Attribute text files (overrides/syncs)\n";
print ETFILE "# Format:\n";
print ETFILE "# <ENUM-STR>,<ENUM-VAL>\n";

#-------------------------------------------------------------------------------
# Print header of getFapiAttrData.C
# ------------------------------------------------------------------------------
print FMFILE "const AttributeData g_FapiAttrs[] = {\n";
my %attrOverrideData = ();

#-------------------------------------------------------------------------------
# Print header of getFapiAttrEnumData.C
# ------------------------------------------------------------------------------
print FEFILE "const AttributeEnum g_FapiEnums[] = {\n";
my @attrOverrideEnums = ();

my %attrIdHash;  # Records which Attribute IDs have been used
my %attrValHash; # Records which Attribute values have been used

#------------------------------------------------------------------------------
# For each XML file
#------------------------------------------------------------------------------
foreach my $argnum (0 .. $#ARGV)
{
    my $infile = $ARGV[$argnum];

    # read XML file. The ForceArray option ensures that there is an array of
    # elements even if there is only one such element in the file
    my $attributes = $xml->XMLin($infile, ForceArray => ['attribute']);

    # Uncomment to get debug output of all attributes
    #print "\nFile: ", $infile, "\n", Dumper($attributes), "\n";

    #--------------------------------------------------------------------------
    # For each Attribute
    #--------------------------------------------------------------------------
    foreach my $attr (@{$attributes->{attribute}})
    {
        #----------------------------------------------------------------------
        # Print the Attribute ID and calculated value to attribute_ids.H and
        # attribute_ids.txt. The value for an attribute is a hash value
        # generated from the attribute name, this ties a specific value to a
        # specific attribute name. This is done for Cronus so that if a HWP is
        # not recompiled against a new eCMD/Cronus version where the attributes
        # have changed then there will not be a mismatch in enumerator values.
        # Historically in P8, this is a 28bit hash value because the Initfile
        # compiler has a requirement that the top nibble of the 32 bit attribute
        # ID be zero to store flags.  In P9, this may change because the
        # Initfile compiler is re-designed.
        #----------------------------------------------------------------------
        if (! exists $attr->{id})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'id' missing\n");
            exit(1);
        }

        if (exists($attrIdHash{$attr->{id}}))
        {
            # Two different attributes with the same id!
            print ("parseAttributeInfo.pl ERROR. Duplicate attr id ",
                $attr->{id}, "\n");
            exit(1);
        }

        # Calculate a 28 bit hash value.
        my $attrHash128Bit = md5_hex($attr->{id});
        my $attrHash28Bit = substr($attrHash128Bit, 0, 7);

        # Print the attribute ID/value to attribute_ids.H
        print AIFILE "    $attr->{id} = 0x$attrHash28Bit,\n";

        if (exists($attrValHash{$attrHash28Bit}))
        {
            # Two different attributes generate the same hash-value!
            print ("parseAttributeInfo.pl ERROR. Duplicate attr id hash value for ",
                   $attr->{id}, "\n");
            exit(1);
        }

        $attrIdHash{$attr->{id}} = $attrHash28Bit;
        $attrValHash{$attrHash28Bit} = 1;
    };
}

#------------------------------------------------------------------------------
# Print AttributeId enumeration end to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "};\n\n";

#------------------------------------------------------------------------------
# Print Attribute Information comment to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "\/**\n";
print AIFILE " * \@brief Attribute Information\n";
print AIFILE " *\/\n";

#------------------------------------------------------------------------------
# For each XML file
#------------------------------------------------------------------------------
foreach my $argnum (0 .. $#ARGV)
{
    my $infile = $ARGV[$argnum];

    # read XML file. The ForceArray option ensures that there is an array of
    # elements even if there is only one such element in the file
    my $attributes = $xml->XMLin($infile, ForceArray => ['attribute', 'chip']);

    #--------------------------------------------------------------------------
    # For each Attribute
    #--------------------------------------------------------------------------

    foreach my $attr
        (@{$attributes->{attribute}})
    {
        my $attrOverride = "";
        #----------------------------------------------------------------------
        # Print a comment with the attribute ID attribute_ids.H
        #----------------------------------------------------------------------
        print AIFILE "/* $attr->{id} */\n";

        #----------------------------------------------------------------------
        # Print the AttributeId and description to attributesSupported.html
        #----------------------------------------------------------------------
        if (! exists $attr->{description})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'description' missing\n");
            exit(1);
        }

        print ASFILE "<tr>\n";
        print ASFILE "  <td>$attr->{id}</td>\n";
        print ASFILE "  <td>$attr->{description}</td>\n";
        print ASFILE "</tr>\n";

        #----------------------------------------------------------------------
        # Print the assignment of each attribute to the local l_name
        #----------------------------------------------------------------------
         $attrOverride .= "\t{\n";
         $attrOverride .= "\t\t\"$attr->{id}\",\n";

        #----------------------------------------------------------------------
        # Figure out the attribute array dimensions (if array)
        #----------------------------------------------------------------------
        my $arrayDimensions = "";
        my @arrayDims = ();
        if ($attr->{array})
        {
            # Remove leading whitespace
            my $dimText = $attr->{array};
            $dimText =~ s/^\s+//;

            # Split on commas or whitespace
            @arrayDims = split(/\s*,\s*|\s+/, $dimText);


            foreach my $val (@arrayDims)
            {
                $arrayDimensions .= "[${val}]";
            }
        }
        until ($#arrayDims == 3)
        {
            push @arrayDims, 1;
        }
        my $arrayDimString = join(", ", @arrayDims);

        #----------------------------------------------------------------------
        # Print the typedef for each attribute's val type to attribute_ids.H
        # Print the attribute information to attrInfo.csv
        #----------------------------------------------------------------------
        if (exists $attr->{chipEcFeature})
        {
            # The value type of chip EC feature attributes is uint8_t
            print AIFILE "typedef uint8_t $attr->{id}_Type;\n";
            print ITFILE "$attr->{id},$attr->{id},";
            print ITFILE "0x$attrIdHash{$attr->{id}},u8\n";
            $attrOverride .= "\t\t0x$attrIdHash{$attr->{id}},\n";
            $attrOverride .= "\t\tsizeof(uint8_t),\n";
            $attrOverride .= "\t\t{ $arrayDimString }\n";
            $attrOverride .= "\t},\n";
        }
        else
        {
            if (! exists $attr->{valueType})
            {
                print ("parseAttributeInfo.pl ERROR. Att 'valueType' missing\n");
                exit(1);
            }

            my @sizes = ( 'uint8', 'uint16', 'uint32', 'uint64', 'int8', 'int16', 'int32', 'int64' );
            my $actualSize = '';
            foreach my $size (@sizes)
            {
                if ($attr->{valueType} eq $size)
                {
                    $actualSize = $size;
                    last;
                }
            }
            if ($actualSize ne '')
            {

                print AIFILE "typedef ${actualSize}_t $attr->{id}_Type$arrayDimensions;\n";
                print ITFILE "$attr->{id},$attr->{id},0x$attrIdHash{$attr->{id}},u8" .
                             "$arrayDimensions\n";
                $attrOverride .= "\t\t0x$attrIdHash{$attr->{id}},\n";
                $attrOverride .= "\t\tsizeof(${actualSize}_t),\n";
            }
            else
            {
                print ("parseAttributeInfo.pl ERROR. valueType not recognized: ");
                print $attr->{valueType}, "\n";
                exit(1);
            }
            $attrOverride .= "\t\t{ $arrayDimString }\n";
            $attrOverride .= "\t},\n";
        }

        #----------------------------------------------------------------------
        # Print if the attribute is privileged
        #----------------------------------------------------------------------
        if (exists $attr->{privileged})
        {
            print AIFILE "const bool $attr->{id}_Privileged = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_Privileged = false;\n";
        }

        #----------------------------------------------------------------------
        # Print if the attribute is a initToZero attribute
        #----------------------------------------------------------------------
        if (exists $attr->{initToZero})
        {
            print AIFILE "const bool $attr->{id}_InitToZero = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_InitToZero = false;\n";
        }

        #----------------------------------------------------------------------
        # Print the target type(s) that the attribute is associated with
        #----------------------------------------------------------------------
        if (! exists $attr->{targetType})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'targetType' missing\n");
            exit(1);
        }

        print AIFILE "const fapi2::TargetType $attr->{id}_TargetType = ";

        # Split on commas
        my @targTypes = split(',', $attr->{targetType});

        my $targTypeCount = 0;
        foreach my $targType (@targTypes)
        {
            # Remove newlines and leading/trailing whitespace
            $targType =~ s/\n//;
            $targType =~ s/^\s+//;
            $targType =~ s/\s+$//;

            if ($targTypeCount != 0)
            {
                print AIFILE " | ";
            }
            print AIFILE "fapi2::$targType";
            $targTypeCount++;
        }
        print AIFILE ";\n";

        #----------------------------------------------------------------------
        # Print if the attribute is a platInit attribute
        #----------------------------------------------------------------------
        if (exists $attr->{platInit})
        {
            print AIFILE "const bool $attr->{id}_PlatInit = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_PlatInit = false;\n";
        }

        #----------------------------------------------------------------------
        # Print the value enumeration (if specified) to attribute_ids.H and
        # attributeEnums.txt
        #----------------------------------------------------------------------
        if (exists $attr->{enum})
        {
            print AIFILE "enum $attr->{id}_Enum\n{\n";

            # Values must be separated by commas to allow for values to be
            # specified: <enum>VAL_A = 3, VAL_B = 5, VAL_C = 0x23</enum>
            my @vals = split(',', $attr->{enum});

            foreach my $val (@vals)
            {
                # Remove newlines and leading/trailing whitespace
                $val =~ s/\n//;
                $val =~ s/^\s+//;
                $val =~ s/\s+$//;

                my @values = split('=', ${val});
                # Remove newlines and leading/trailing whitespace

                foreach my $value (@values)
                {
                    $value =~ s/\n//;
                    $value =~ s/^\s+//;
                    $value =~ s/\s+$//;
                }

                push @attrOverrideEnums,
                    "\t{ \"$attr->{id}_$values[0]\", $values[1] },\n";

                # Print the attribute enum to attribute_ids.H
                print AIFILE "    ENUM_$attr->{id}_${val}";

                # Print the attribute enum to attrEnumInfo.csv
                my $attrEnumTxt = "$attr->{id}_${val}\n";


                $attrEnumTxt =~ s/ = /,/;
                print ETFILE $attrEnumTxt;


                if ($attr->{valueType} eq 'uint64')
                {
                    print AIFILE "ULL";
                }
                elsif ($attr->{valueType} eq 'int64')
                {
                    print AIFILE "LL";
                }

                print AIFILE ",\n";
            }

            print AIFILE "};\n";
        }

        #----------------------------------------------------------------------
        # Print _GETMACRO and _SETMACRO where appropriate to attribute_ids.H
        #----------------------------------------------------------------------
        if (exists $attr->{chipEcFeature})
        {
            #------------------------------------------------------------------
            # The attribute is a Chip EC Feature, define _GETMACRO to call a
            # fapi2 function and define _SETMACRO to something that will cause a
            # compile failure if a set is attempted
            #------------------------------------------------------------------
            print AIFILE "#define $attr->{id}_GETMACRO(ID, PTARGET, VAL) \\\n";
            print AIFILE "    PLAT_GET_CHIP_EC_FEATURE_OVERRIDE(ID, PTARGET, VAL) ? fapi2::ReturnCode() : \\\n";
            print AIFILE "    queryChipEcFeature(fapi2::int2Type<ID>(), PTARGET, VAL)\n";
            print AIFILE "#define $attr->{id}_SETMACRO(ID, PTARGET, VAL) ";
            print AIFILE "CHIP_EC_FEATURE_ATTRIBUTE_NOT_WRITABLE\n";
        }
        elsif (! exists $attr->{writeable})
        {
            #------------------------------------------------------------------
            # The attribute is read-only, define the _SETMACRO to something
            # that will cause a compile failure if a set is attempted
            #------------------------------------------------------------------
            if (! exists $attr->{writeable})
            {
                print AIFILE "#define $attr->{id}_SETMACRO ATTRIBUTE_NOT_WRITABLE\n";
            }
        }

        #----------------------------------------------------------------------
        # If the attribute is a Chip EC Feature, print the chip EC feature
        # query to fapi2_chip_ec_feature.H
        #----------------------------------------------------------------------
        # Each EC attribute will generate a new inline overloaded version of
        # hasFeature with the attribute specific logic
        if (exists $attr->{chipEcFeature})
        {
            my $chipCount = 0;
            print ECHFILE " inline uint8_t hasFeature(int2Type<$attr->{id}>,\n";
            print ECHFILE "                       fapi2::ATTR_NAME_Type i_name,\n";
            print ECHFILE "                       fapi2::ATTR_EC_Type i_ec)\n";
            print ECHFILE " {\n";
            print ECHFILE "    uint8_t hasFeature = 0;\n\n";
            print ECHFILE "    if(";

            foreach my $chip (@{$attr->{chipEcFeature}->{chip}})
            {
                $chipCount++;

                if (! exists $chip->{name})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'name' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'ec' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec}->{value})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'value' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec}->{test})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'test' missing\n");
                    exit(1);
                }

                my $test;
                if ($chip->{ec}->{test} eq 'EQUAL')
                {
                    $test = '==';
                }
                elsif ($chip->{ec}->{test} eq 'GREATER_THAN')
                {
                    $test = '>';
                }
                elsif ($chip->{ec}->{test} eq 'GREATER_THAN_OR_EQUAL')
                {
                    $test = '>=';
                }
                elsif ($chip->{ec}->{test} eq 'LESS_THAN')
                {
                    $test = '<';
                }
                elsif ($chip->{ec}->{test} eq 'LESS_THAN_OR_EQUAL')
                {
                    $test = '<=';
                }
                else
                {
                    print ("parseAttributeInfo.pl ERROR. test '$chip->{ec}->{test}' unrecognized\n");
                    exit(1);
                }

                if ($chipCount > 1)
                {
                    print ECHFILE " ||\n\t";
                }
                print ECHFILE "((i_name == $chip->{name}) && ";
                print ECHFILE " (i_ec $test $chip->{ec}->{value}))";
            }
            print ECHFILE ")\n";
            print ECHFILE "     {\n";
            print ECHFILE "         hasFeature = 1;\n";
            print ECHFILE "     }\n";
            print ECHFILE "     return hasFeature;\n";
            print ECHFILE " };\n";
        }

        #----------------------------------------------------------------------
        # Print the platform attribute checks to attribute_plat_check.H
        #----------------------------------------------------------------------
        if (exists $attr->{writeable})
        {
            print ACFILE "#ifndef $attr->{id}_SETMACRO\n";
            print ACFILE "#error Platform does not support set of HWPF attr $attr->{id}\n";
            print ACFILE "#endif\n";
        }

        print ACFILE "#ifndef $attr->{id}_GETMACRO\n";
        print ACFILE "#error Platform does not support get of HWPF attr $attr->{id}\n";
        print ACFILE "#endif\n\n";

        #----------------------------------------------------------------------
        # Print newline between each attribute's info to attribute_ids.H
        #----------------------------------------------------------------------
        print AIFILE "\n";

        #----------------------------------------------------------------------
        # Add attribute override string to map.
        #----------------------------------------------------------------------
        $attrOverrideData{$attr->{id}} = $attrOverride;
    };
}

#------------------------------------------------------------------------------
# Print End of file information to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "}\n\n";
print AIFILE "#endif\n";

print ECHFILE "}\n";
print ECHFILE "#endif\n";


#------------------------------------------------------------------------------
# Print End of file information to attribute_plat_check.H
#------------------------------------------------------------------------------
print ACFILE "#endif\n";

#------------------------------------------------------------------------------
# Print End of file information to attributesSupported.html
#------------------------------------------------------------------------------
print ASFILE "</table>\n\n";
print ASFILE "</body>\n";
print ASFILE "</html>\n";

#------------------------------------------------------------------------------
# Print content for getFapiAttrData.C
#------------------------------------------------------------------------------
foreach my $override (sort keys %attrOverrideData)
{
    print FMFILE $attrOverrideData{$override};
}
print FMFILE "};\n";

#------------------------------------------------------------------------------
# Print footer for getFapiAttrEnumData.C
#------------------------------------------------------------------------------
foreach my $override (sort @attrOverrideEnums)
{
    print FEFILE $override;
}
print FEFILE "};\n";

#------------------------------------------------------------------------------
# Close output files
#------------------------------------------------------------------------------
close(AIFILE);
close(ECHFILE);
close(ACFILE);
close(ASFILE);
close(ITFILE);
close(ETFILE);
close(FMFILE);
close(FEFILE);

