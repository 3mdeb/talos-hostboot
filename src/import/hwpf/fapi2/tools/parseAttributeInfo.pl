#!/usr/bin/perl
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: hwpf/fapi2/tools/parseAttributeInfo.pl $
#
# IBM CONFIDENTIAL
#
# EKB Project
#
# COPYRIGHT 2015
# [+] International Business Machines Corp.
#
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# IBM_PROLOG_END_TAG

use strict;
use Getopt::Long;

#------------------------------------------------------------------------------
# Print Command Line Help
#------------------------------------------------------------------------------
my $arg_output_dir = undef;

# Get the options from the command line - the rest of @ARGV will
# be filenames
GetOptions("output-dir=s" => \$arg_output_dir);

my $numArgs = $#ARGV + 1;
if (($numArgs < 1) || ($arg_output_dir eq undef))
{
    print ("Usage: parseAttributeInfo.pl --output-dir=<output dir> <attr-xml-file1> [<attr-xml-file2> ...]\n");
    print ("  This perl script will parse attribute XML files and create the following files:\n");
    print ("  - attribute_ids.H.          Contains IDs, type, value enums and other information\n");
    print ("  - fapi2_chip_ec_feature.C. Contains a function to query chip EC features\n");
    print ("  - attribute_plat_check.H   Contains compile time checks that all attributes are\n");
    print ("                             handled by the platform\n");
    print ("  - attributesSupported.html Contains the HWPF attributes supported\n");
    print ("  - attrInfo.csv             Used to process Attribute Override Text files\n");
    print ("  - attrEnumInfo.csv         Used to process Attribute Override Text files\n");
    exit(1);
}

#------------------------------------------------------------------------------
# Specify perl modules to use
#------------------------------------------------------------------------------
use Digest::MD5 qw(md5_hex);
use XML::Simple;
my $xml = new XML::Simple (KeyAttr=>[]);

# Uncomment to enable debug output
#use Data::Dumper;

#------------------------------------------------------------------------------
# Set PREFERRED_PARSER to XML::Parser. Otherwise it uses XML::SAX which contains
# bugs that result in XML parse errors that can be fixed by adjusting white-
# space (i.e. parse errors that do not make sense).
#------------------------------------------------------------------------------
$XML::Simple::PREFERRED_PARSER = 'XML::Parser';

#------------------------------------------------------------------------------
# Open output files for writing
#------------------------------------------------------------------------------
my $aiFile = $arg_output_dir;
$aiFile .= "/";
$aiFile .= "attribute_ids.H";
open(AIFILE, ">", $aiFile);

my $ecFile = $arg_output_dir;
$ecFile .= "/";
$ecFile .= "fapi2_chip_ec_feature.C";
open(ECFILE, ">", $ecFile);

my $acFile = $arg_output_dir;
$acFile .= "/";
$acFile .= "attribute_plat_check.H";
open(ACFILE, ">", $acFile);

my $asFile = $arg_output_dir;
$asFile .= "/";
$asFile .= "attributesSupported.html";
open(ASFILE, ">", $asFile);

my $itFile = $arg_output_dir;
$itFile .= "/";
$itFile .= "attrInfo.csv";
open(ITFILE, ">", $itFile);

my $etFile = $arg_output_dir;
$etFile .= "/";
$etFile .= "attrEnumInfo.csv";
open(ETFILE, ">", $etFile);

# TODO: This for platform use only, will support later via RTC 128106 for HB
my $fmFile = $arg_output_dir;
$fmFile .= "/";
$fmFile .= "fapi2AttrOverrideData.H";
open(FMFILE, ">", $fmFile);

my $feFile = $arg_output_dir;
$feFile .= "/";
$feFile .= "fapi2AttrOverrideEnums.H";
open(FEFILE, ">", $feFile);


#------------------------------------------------------------------------------
# Print Start of file information to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "// attribute_ids.H\n";
print AIFILE "// This file is generated by perl script parseAttributeInfo.pl\n\n";
print AIFILE "#ifndef ATTRIBUTEIDS_H_\n";
print AIFILE "#define ATTRIBUTEIDS_H_\n\n";
print AIFILE "#include <target_types.H>\n\n";
print AIFILE "namespace fapi2\n";
print AIFILE "{\n\n";
print AIFILE "\/**\n";
print AIFILE " * \@brief Enumeration of attribute IDs\n";
print AIFILE " *\/\n";
print AIFILE "enum AttributeId\n{\n";

#------------------------------------------------------------------------------
# Print Start of file information to fapi2_chip_ec_feature.C
#------------------------------------------------------------------------------
print ECFILE "// fapi2_chip_ec_feature.C\n";
print ECFILE "// This file is generated by perl script parseAttributeInfo.pl\n";
print ECFILE "// It implements the queryfapi2_chip_ec_feature function\n\n";
print ECFILE "#include <fapi2_chip_ec_feature.H>\n";
print ECFILE "#include <fapi2_attribute_service.H>\n";
print ECFILE "#include <plat_trace.H>\n\n";
print ECFILE "namespace fapi2\n";
print ECFILE "{\n\n";
print ECFILE "template< TargetType K >\n";
print ECFILE "ReturnCode queryChipEcFeature(AttributeId i_id,\n";
print ECFILE "                    const Target<K>& i_pTarget,\n";
print ECFILE "                    uint8_t & o_hasFeature)\n";
print ECFILE "{\n";
print ECFILE "    o_hasFeature = false;\n";
print ECFILE "    ReturnCode l_rc;\n";
print ECFILE "    uint8_t l_chipName = 0;\n";
print ECFILE "    uint8_t l_chipEc = 0;\n\n";
print ECFILE "    if (i_pTarget.isChiplet())\n";
print ECFILE "    {\n";
print ECFILE "        Target<TARGET_TYPE_ALL> l_target = i_pTarget.getParent();\n";
print ECFILE "    }\n\n";
print ECFILE "    if (!l_rc)\n";
print ECFILE "    {\n";
print ECFILE "        l_rc = FAPI_ATTR_GET_PRIVILEGED(ATTR_NAME, &l_target, l_chipName);\n\n";
print ECFILE "        if (l_rc)\n";
print ECFILE "        {\n";
print ECFILE "            FAPI_ERR(\"queryChipEcFeature: error getting chip name\");\n";
print ECFILE "        }\n";
print ECFILE "        else\n";
print ECFILE "        {\n";
print ECFILE "            l_rc = FAPI_ATTR_GET_PRIVILEGED(ATTR_EC, &l_target, l_chipEc);\n\n";
print ECFILE "            if (l_rc)\n";
print ECFILE "            {\n";
print ECFILE "                FAPI_ERR(\"queryChipEcFeature: error getting chip ec\");\n";
print ECFILE "            }\n";
print ECFILE "            else\n";
print ECFILE "            {\n";
print ECFILE "                switch (i_id)\n";
print ECFILE "                {\n";

#------------------------------------------------------------------------------
# Print Start of file information to attribute_plat_check.H
#------------------------------------------------------------------------------
print ACFILE "// attribute_plat_check.H\n";
print ACFILE "// This file is generated by perl script parseAttributeInfo.pl\n";
print ACFILE "// A platform can include it to ensure that it handles all HWPF\n";
print ACFILE "// attributes\n\n";
print ACFILE "#ifndef ATTRIBUTEPLATCHECK_H_\n";
print ACFILE "#define ATTRIBUTEPLATCHECK_H_\n\n";

#------------------------------------------------------------------------------
# Print Start of file information to attributesSupported.html
#------------------------------------------------------------------------------
print ASFILE "<html>\n";
print ASFILE "<body>\n\n";
print ASFILE "<!-- attributesSupported.html -->\n";
print ASFILE "<!-- This file is generated by perl script parseAttributeInfo.pl -->\n";
print ASFILE "<!-- It lists all HWPF attributes supported -->\n\n";
print ASFILE "<h4>HWPF Attributes supported by this build.</h4>\n";
print ASFILE "<table border=\"4\">\n";
print ASFILE "<tr><th>Attribute ID</th><th>Attribute Description</th></tr>";

#------------------------------------------------------------------------------
# Print Start of file information to attrInfo.csv
#------------------------------------------------------------------------------
print ITFILE "# attrInfo.csv\n";
print ITFILE "# This file is generated by perl script parseAttributeInfo.pl\n";
print ITFILE "# It lists information about FAPI attributes and is used to\n";
print ITFILE "# process FAPI Attribute text files (overrides/syncs)\n";
print ITFILE "# Format:\n";
print ITFILE "# <FAPI-ATTR-ID-STR>,<LAYER-ATTR-ID-STR>,<ATTR-ID-VAL>,<ATTR-TYPE>\n";
print ITFILE "# Note that for the AttributeTanks at the FAPI layer, the\n";
print ITFILE "# FAPI-ATTR-ID-STR and LAYER-ATTR-ID-STR will be identical\n";

#------------------------------------------------------------------------------
# Print Start of file information to attrEnumInfo.csv
#------------------------------------------------------------------------------
print ETFILE "# attrEnumInfo.csv\n";
print ETFILE "# This file is generated by perl script parseAttributeInfo.pl\n";
print ETFILE "# It lists information about FAPI attribute enumerators and is\n";
print ETFILE "# used to process FAPI Attribute text files (overrides/syncs)\n";
print ETFILE "# Format:\n";
print ETFILE "# <ENUM-STR>,<ENUM-VAL>\n";

#-------------------------------------------------------------------------------
# Print header of getFapiAttrData.C
# ------------------------------------------------------------------------------
print FMFILE "const AttributeData g_FapiAttrs[] = {\n";
my %attrOverrideData = ();

#-------------------------------------------------------------------------------
# Print header of getFapiAttrEnumData.C
# ------------------------------------------------------------------------------
print FEFILE "const AttributeEnum g_FapiEnums[] = {\n";
my @attrOverrideEnums = ();

my %attrIdHash;  # Records which Attribute IDs have been used
my %attrValHash; # Records which Attribute values have been used

#------------------------------------------------------------------------------
# For each XML file
#------------------------------------------------------------------------------
foreach my $argnum (0 .. $#ARGV)
{
    my $infile = $ARGV[$argnum];

    # read XML file. The ForceArray option ensures that there is an array of
    # elements even if there is only one such element in the file
    my $attributes = $xml->XMLin($infile, ForceArray => ['attribute']);

    # Uncomment to get debug output of all attributes
    #print "\nFile: ", $infile, "\n", Dumper($attributes), "\n";

    #--------------------------------------------------------------------------
    # For each Attribute
    #--------------------------------------------------------------------------
    foreach my $attr (@{$attributes->{attribute}})
    {
        #----------------------------------------------------------------------
        # Print the Attribute ID and calculated value to attribute_ids.H and
        # attribute_ids.txt. The value for an attribute is a hash value
        # generated from the attribute name, this ties a specific value to a
        # specific attribute name. This is done for Cronus so that if a HWP is
        # not recompiled against a new eCMD/Cronus version where the attributes
        # have changed then there will not be a mismatch in enumerator values.
        # Historically in P8, this is a 28bit hash value because the Initfile
        # compiler has a requirement that the top nibble of the 32 bit attribute
        # ID be zero to store flags.  In P9, this may change because the
        # Initfile compiler is re-designed.
        #----------------------------------------------------------------------
        if (! exists $attr->{id})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'id' missing\n");
            exit(1);
        }

        if (exists($attrIdHash{$attr->{id}}))
        {
            # Two different attributes with the same id!
            print ("parseAttributeInfo.pl ERROR. Duplicate attr id ",
                $attr->{id}, "\n");
            exit(1);
        }

        # Calculate a 28 bit hash value.
        my $attrHash128Bit = md5_hex($attr->{id});
        my $attrHash28Bit = substr($attrHash128Bit, 0, 7);

        # Print the attribute ID/value to attribute_ids.H
        print AIFILE "    $attr->{id} = 0x$attrHash28Bit,\n";

        if (exists($attrValHash{$attrHash28Bit}))
        {
            # Two different attributes generate the same hash-value!
            print ("parseAttributeInfo.pl ERROR. Duplicate attr id hash value for ",
                   $attr->{id}, "\n");
            exit(1);
        }

        $attrIdHash{$attr->{id}} = $attrHash28Bit;
        $attrValHash{$attrHash28Bit} = 1;
    };
}

#------------------------------------------------------------------------------
# Print AttributeId enumeration end to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "};\n\n";

#------------------------------------------------------------------------------
# Print Attribute Information comment to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "\/**\n";
print AIFILE " * \@brief Attribute Information\n";
print AIFILE " *\/\n";

#------------------------------------------------------------------------------
# For each XML file
#------------------------------------------------------------------------------
foreach my $argnum (0 .. $#ARGV)
{
    my $infile = $ARGV[$argnum];

    # read XML file. The ForceArray option ensures that there is an array of
    # elements even if there is only one such element in the file
    my $attributes = $xml->XMLin($infile, ForceArray => ['attribute', 'chip']);

    #--------------------------------------------------------------------------
    # For each Attribute
    #--------------------------------------------------------------------------

    foreach my $attr
        (@{$attributes->{attribute}})
    {
        my $attrOverride = "";
        #----------------------------------------------------------------------
        # Print a comment with the attribute ID attribute_ids.H
        #----------------------------------------------------------------------
        print AIFILE "/* $attr->{id} */\n";

        #----------------------------------------------------------------------
        # Print the AttributeId and description to attributesSupported.html
        #----------------------------------------------------------------------
        if (! exists $attr->{description})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'description' missing\n");
            exit(1);
        }

        print ASFILE "<tr>\n";
        print ASFILE "  <td>$attr->{id}</td>\n";
        print ASFILE "  <td>$attr->{description}</td>\n";
        print ASFILE "</tr>\n";

        #----------------------------------------------------------------------
        # Print the assignment of each attribute to the local l_name
        #----------------------------------------------------------------------
         $attrOverride .= "\t{\n";
         $attrOverride .= "\t\t\"$attr->{id}\",\n";

        #----------------------------------------------------------------------
        # Figure out the attribute array dimensions (if array)
        #----------------------------------------------------------------------
        my $arrayDimensions = "";
        my @arrayDims = ();
        if ($attr->{array})
        {
            # Remove leading whitespace
            my $dimText = $attr->{array};
            $dimText =~ s/^\s+//;

            # Split on commas or whitespace
            @arrayDims = split(/\s*,\s*|\s+/, $dimText);


            foreach my $val (@arrayDims)
            {
                $arrayDimensions .= "[${val}]";
            }
        }
        until ($#arrayDims == 3)
        {
            push @arrayDims, 1;
        }
        my $arrayDimString = join(", ", @arrayDims);

        #----------------------------------------------------------------------
        # Print the typedef for each attribute's val type to attribute_ids.H
        # Print the attribute information to attrInfo.csv
        #----------------------------------------------------------------------
        if (exists $attr->{chipEcFeature})
        {
            # The value type of chip EC feature attributes is uint8_t
            print AIFILE "typedef uint8_t $attr->{id}_Type;\n";
            print ITFILE "$attr->{id},$attr->{id},";
            print ITFILE "0x$attrIdHash{$attr->{id}},u8\n";
            $attrOverride .= "\t\t0x$attrIdHash{$attr->{id}},\n";
            $attrOverride .= "\t\tsizeof(uint8_t),\n";
            $attrOverride .= "\t\t{ $arrayDimString }\n";
            $attrOverride .= "\t},\n";
        }
        else
        {
            if (! exists $attr->{valueType})
            {
                print ("parseAttributeInfo.pl ERROR. Att 'valueType' missing\n");
                exit(1);
            }

            my @sizes = ( 'uint8', 'uint32', 'uint64', 'int8', 'int32', 'int64' );
            my $actualSize = '';
            foreach my $size (@sizes)
            {
                if ($attr->{valueType} eq $size)
                {
                    $actualSize = $size;
                    last;
                }
            }
            if ($actualSize ne '')
            {

                print AIFILE "typedef ${actualSize}_t $attr->{id}_Type$arrayDimensions;\n";
                print ITFILE "$attr->{id},$attr->{id},0x$attrIdHash{$attr->{id}},u8" .
                             "$arrayDimensions\n";
                $attrOverride .= "\t\t0x$attrIdHash{$attr->{id}},\n";
                $attrOverride .= "\t\tsizeof(${actualSize}_t),\n";
            }
            else
            {
                print ("parseAttributeInfo.pl ERROR. valueType not recognized: ");
                print $attr->{valueType}, "\n";
                exit(1);
            }
            $attrOverride .= "\t\t{ $arrayDimString }\n";
            $attrOverride .= "\t},\n";
        }

        #----------------------------------------------------------------------
        # Print if the attribute is privileged
        #----------------------------------------------------------------------
        if (exists $attr->{privileged})
        {
            print AIFILE "const bool $attr->{id}_Privileged = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_Privileged = false;\n";
        }

        #----------------------------------------------------------------------
        # Print if the attribute is a initToZero attribute
        #----------------------------------------------------------------------
        if (exists $attr->{initToZero})
        {
            print AIFILE "const bool $attr->{id}_InitToZero = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_InitToZero = false;\n";
        }

        #----------------------------------------------------------------------
        # Print the target type(s) that the attribute is associated with
        #----------------------------------------------------------------------
        if (! exists $attr->{targetType})
        {
            print ("parseAttributeInfo.pl ERROR. Att 'targetType' missing\n");
            exit(1);
        }

        print AIFILE "const fapi2::TargetType $attr->{id}_TargetType = ";

        # Split on commas
        my @targTypes = split(',', $attr->{targetType});

        my $targTypeCount = 0;
        foreach my $targType (@targTypes)
        {
            # Remove newlines and leading/trailing whitespace
            $targType =~ s/\n//;
            $targType =~ s/^\s+//;
            $targType =~ s/\s+$//;

            if ($targTypeCount != 0)
            {
                print AIFILE " | ";
            }
            print AIFILE "fapi2::$targType";
            $targTypeCount++;
        }
        print AIFILE ";\n";

        #----------------------------------------------------------------------
        # Print if the attribute is a platInit attribute
        #----------------------------------------------------------------------
        if (exists $attr->{platInit})
        {
            print AIFILE "const bool $attr->{id}_PlatInit = true;\n";
        }
        else
        {
            print AIFILE "const bool $attr->{id}_PlatInit = false;\n";
        }

        #----------------------------------------------------------------------
        # Print the value enumeration (if specified) to attribute_ids.H and
        # attributeEnums.txt
        #----------------------------------------------------------------------
        if (exists $attr->{enum})
        {
            print AIFILE "enum $attr->{id}_Enum\n{\n";

            # Values must be separated by commas to allow for values to be
            # specified: <enum>VAL_A = 3, VAL_B = 5, VAL_C = 0x23</enum>
            my @vals = split(',', $attr->{enum});

            foreach my $val (@vals)
            {
                # Remove newlines and leading/trailing whitespace
                $val =~ s/\n//;
                $val =~ s/^\s+//;
                $val =~ s/\s+$//;

                my @values = split('=', ${val});
                # Remove newlines and leading/trailing whitespace

                foreach my $value (@values)
                {
                    $value =~ s/\n//;
                    $value =~ s/^\s+//;
                    $value =~ s/\s+$//;
                }

                push @attrOverrideEnums,
                    "\t{ \"$attr->{id}_$values[0]\", $values[1] },\n";

                # Print the attribute enum to attribute_ids.H
                print AIFILE "    ENUM_$attr->{id}_${val}";

                # Print the attribute enum to attrEnumInfo.csv
                my $attrEnumTxt = "$attr->{id}_${val}\n";


                $attrEnumTxt =~ s/ = /,/;
                print ETFILE $attrEnumTxt;


                if ($attr->{valueType} eq 'uint64')
                {
                    print AIFILE "ULL";
                }
                elsif ($attr->{valueType} eq 'int64')
                {
                    print AIFILE "LL";
                }

                print AIFILE ",\n";
            }

            print AIFILE "};\n";
        }

        #----------------------------------------------------------------------
        # Print _GETMACRO and _SETMACRO where appropriate to attribute_ids.H
        #----------------------------------------------------------------------
        if (exists $attr->{chipEcFeature})
        {
            #------------------------------------------------------------------
            # The attribute is a Chip EC Feature, define _GETMACRO to call a
            # fapi2 function and define _SETMACRO to something that will cause a
            # compile failure if a set is attempted
            #------------------------------------------------------------------
            print AIFILE "#define $attr->{id}_GETMACRO(ID, PTARGET, VAL) \\\n";
            print AIFILE "    PLAT_GET_CHIP_EC_FEATURE_OVERRIDE(ID, PTARGET, VAL) ? fapi2::FAPI2_RC_SUCCESS : \\\n";
            print AIFILE "    fapi2::queryChipEcFeature(ID, PTARGET, VAL)\n";
            print AIFILE "#define $attr->{id}_SETMACRO(ID, PTARGET, VAL) ";
            print AIFILE "CHIP_EC_FEATURE_ATTRIBUTE_NOT_WRITABLE\n";
        }
        elsif (! exists $attr->{writeable})
        {
            #------------------------------------------------------------------
            # The attribute is read-only, define the _SETMACRO to something
            # that will cause a compile failure if a set is attempted
            #------------------------------------------------------------------
            if (! exists $attr->{writeable})
            {
                print AIFILE "#define $attr->{id}_SETMACRO ATTRIBUTE_NOT_WRITABLE\n";
            }
        }

        #----------------------------------------------------------------------
        # If the attribute is a Chip EC Feature, print the chip EC feature
        # query to fapi2_chip_ec_feature.C
        #----------------------------------------------------------------------
        if (exists $attr->{chipEcFeature})
        {
            my $chipCount = 0;
            print ECFILE "                case $attr->{id}:\n";
            print ECFILE "                    if (\n";

            foreach my $chip (@{$attr->{chipEcFeature}->{chip}})
            {
                $chipCount++;

                if (! exists $chip->{name})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'name' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'ec' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec}->{value})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'value' missing\n");
                    exit(1);
                }

                if (! exists $chip->{ec}->{test})
                {
                    print ("parseAttributeInfo.pl ERROR. Att 'test' missing\n");
                    exit(1);
                }

                my $test;
                if ($chip->{ec}->{test} eq 'EQUAL')
                {
                    $test = '==';
                }
                elsif ($chip->{ec}->{test} eq 'GREATER_THAN')
                {
                    $test = '>';
                }
                elsif ($chip->{ec}->{test} eq 'GREATER_THAN_OR_EQUAL')
                {
                    $test = '>=';
                }
                elsif ($chip->{ec}->{test} eq 'LESS_THAN')
                {
                    $test = '<';
                }
                elsif ($chip->{ec}->{test} eq 'LESS_THAN_OR_EQUAL')
                {
                    $test = '<=';
                }
                else
                {
                    print ("parseAttributeInfo.pl ERROR. test '$chip->{ec}->{test}' unrecognized\n");
                    exit(1);
                }

                if ($chipCount > 1)
                {
                    print ECFILE "                    ||\n";
                }
                print ECFILE "                        ((l_chipName == $chip->{name}) &&\n";
                print ECFILE "                         (l_chipEc $test $chip->{ec}->{value}))\n";
            }

            print ECFILE "                       )\n";
            print ECFILE "                    {\n";
            print ECFILE "                        o_hasFeature = true;\n";
            print ECFILE "                    }\n";
            print ECFILE "                    break;\n";
        }

        #----------------------------------------------------------------------
        # Print the platform attribute checks to attribute_plat_check.H
        #----------------------------------------------------------------------
        if (exists $attr->{writeable})
        {
            print ACFILE "#ifndef $attr->{id}_SETMACRO\n";
            print ACFILE "#error Platform does not support set of HWPF attr $attr->{id}\n";
            print ACFILE "#endif\n";
        }

        print ACFILE "#ifndef $attr->{id}_GETMACRO\n";
        print ACFILE "#error Platform does not support get of HWPF attr $attr->{id}\n";
        print ACFILE "#endif\n\n";

        #----------------------------------------------------------------------
        # Print newline between each attribute's info to attribute_ids.H
        #----------------------------------------------------------------------
        print AIFILE "\n";

        #----------------------------------------------------------------------
        # Add attribute override string to map.
        #----------------------------------------------------------------------
        $attrOverrideData{$attr->{id}} = $attrOverride;
    };
}

#------------------------------------------------------------------------------
# Print End of file information to attribute_ids.H
#------------------------------------------------------------------------------
print AIFILE "}\n\n";
print AIFILE "#endif\n";

#------------------------------------------------------------------------------
# Print End of file information to fapi2_chip_ec_feature.C
#------------------------------------------------------------------------------
print ECFILE "                default:\n";
print ECFILE "                    FAPI_ERR(\"queryChipEcFeature: Unknown feature 0x%x\",\n";
print ECFILE "                        i_id);\n";
print ECFILE "                    l_rc.setFapiError(FAPI_RC_INVALID_CHIP_EC_FEATURE_GET);\n";
print ECFILE "                    l_rc.addEIFfdc(0, &i_id, sizeof(i_id));\n";
print ECFILE "                    break;\n";
print ECFILE "                }\n\n";
print ECFILE "                if (o_hasFeature)\n";
print ECFILE "                {\n";
print ECFILE "                    FAPI_INF(\"queryChipEcFeature: Chip (0x%x:0x%x) has ";
print ECFILE "feature (0x%x)\", l_chipName, l_chipEc, i_id);\n";
print ECFILE "                }\n";
print ECFILE "                else\n";
print ECFILE "                {\n";
print ECFILE "                    FAPI_INF(\"queryChipEcFeature: Chip (0x%x:0x%x) does not ";
print ECFILE "have feature (0x%x)\", l_chipName, l_chipEc, i_id);\n";
print ECFILE "                }\n";
print ECFILE "            }\n";
print ECFILE "        }\n";
print ECFILE "    }\n";
print ECFILE "    return l_rc;\n";
print ECFILE "}\n\n";
print ECFILE "}\n";


#------------------------------------------------------------------------------
# Print End of file information to attribute_plat_check.H
#------------------------------------------------------------------------------
print ACFILE "#endif\n";

#------------------------------------------------------------------------------
# Print End of file information to attributesSupported.html
#------------------------------------------------------------------------------
print ASFILE "</table>\n\n";
print ASFILE "</body>\n";
print ASFILE "</html>\n";

#------------------------------------------------------------------------------
# Print content for getFapiAttrData.C
#------------------------------------------------------------------------------
foreach my $override (sort keys %attrOverrideData)
{
    print FMFILE $attrOverrideData{$override};
}
print FMFILE "};\n";

#------------------------------------------------------------------------------
# Print footer for getFapiAttrEnumData.C
#------------------------------------------------------------------------------
foreach my $override (sort @attrOverrideEnums)
{
    print FEFILE $override;
}
print FEFILE "};\n";

#------------------------------------------------------------------------------
# Close output files
#------------------------------------------------------------------------------
close(AIFILE);
close(ECFILE);
close(ACFILE);
close(ASFILE);
close(ITFILE);
close(ETFILE);
close(FMFILE);
close(FEFILE);

