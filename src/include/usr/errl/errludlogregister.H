/*  IBM_PROLOG_BEGIN_TAG
 *  This is an automatically generated prolog.
 *
 *  $Source: src/include/usr/errl/errludlogregister.H $
 *
 *  IBM CONFIDENTIAL
 *
 *  COPYRIGHT International Business Machines Corp. 2012
 *
 *  p1
 *
 *  Object Code Only (OCO) source materials
 *  Licensed Internal Code Source Materials
 *  IBM HostBoot Licensed Internal Code
 *
 *  The source code for this program is not published or other-
 *  wise divested of its trade secrets, irrespective of what has
 *  been deposited with the U.S. Copyright Office.
 *
 *  Origin: 30
 *
 *  IBM_PROLOG_END_TAG
 */
#ifndef ERRL_UDLOGREGISTER_H
#define ERRL_UDLOGREGISTER_H

/**
 *  @file errludlogregister.H
 *
 *  Defines the following classes:
 *
 *  ErrlUserDetailsLogRegister: Adds register FFDC to an error log as
 *                                  user detail data
 *  ErrlUserDetailsParserLogRegister: Parses register FFDC user detail in
 *                                  an error log
*/

#include <errl/errluserdetails.H>
#include <stdarg.h>

#ifndef PARSER

// Forward reference
namespace TARGETING
{
    class Target;
}

#include <devicefw/userif.H>

namespace ERRORLOG
{

/**
 * @class ErrlUserDetailsLogRegister
 *
 * Adds LogRegister FFDC to an error log as user detail data
 */
class ErrlUserDetailsLogRegister : public ErrlUserDetails
{
public:
    /**
     *  @brief Constructor - target only
     *
     *  @param[in] i_pTarget - target of the register reads
     *
     *  Creates a LogRegister UserDetail, storing the HUID. User will
     *   next need to call addData() in order to get data into this object,
     *   and addToLog() in order to push the data to the error log.
     *
     */
    ErrlUserDetailsLogRegister(TARGETING::Target * i_pTarget);

    /**
     *  @brief Constructor - target and register type/address
     *
     *  @param[in] i_pTarget - target of the register reads
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Creates a LogRegister UserDetail, storing the HUID, and perform
     *   the deviceOp() of the specified register type and address, storing
     *   that (type and address) as well as the result in this object.
     *
     *  Note that this can only be used for devicefw/userif.H register
     *   interface (DeviceFW::AccessType) types.
     *
     */
    ErrlUserDetailsLogRegister(TARGETING::Target * i_pTarget,
                                DeviceFW::AccessType i_accessType, ...);

    /**
     *  @brief Constructor - target, register type/address and data
     *
     *  @param[in] i_pTarget - target of the register reads
     *  @param[in] i_dataBuf - pointer to area with register data
     *  @param[in] i_dataSize - size of data pointed at by i_dataBuf
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Creates a LogRegister UserDetail, storing the HUID, and stores
     *   the register type and address, as well as the passed-in result
     *   in this object. The deviceOp() operation is NOT performed UNLESS
     *   i_dataBuf is NULL.
     *
     *  Note that this can only be used for devicefw/userif.H register
     *   interface (DeviceFW::AccessType) types.
     */
    ErrlUserDetailsLogRegister(TARGETING::Target * i_pTarget,
                                void *i_dataBuf,
                                size_t i_dataSize,
                                DeviceFW::AccessType i_accessType, ...);

    /**
     *
     * @brief addData - do the register read and store the data
     *
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Performs the deviceOp() of the specified register type and address,
     *   storing that (type and address) as well as the result in this object.
     *
     *  The template allows for userif.H AND deviceif.H register interfaces
     *   to be used. (ie, DeviceFW::AccessType_DriverOnly in addition to
     *   DeviceFW::AccessType).
     */
    template <typename ACCESS_TYPE>
    void addData(ACCESS_TYPE i_accessType, ...);

    /**
     *
     * @brief addDataBuffer - store the buffer of register data
     *
     *  @param[in] i_dataBuf - pointer to buffer with register data
     *  @param[in] i_dataSize - size of buffer pointed at by i_dataBuf
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Stores the specified register type and address, as well as the
     *   passed-in result in this object. The deviceOp() operation is NOT
     *   performed UNLESS i_dataBuf is NULL.
     *
     *  The template allows for userif.H AND deviceif.H register interfaces
     *   to be used. (ie, DeviceFW::AccessType_DriverOnly in addition to
     *   DeviceFW::AccessType).
     */
    template <typename ACCESS_TYPE>
    void addDataBuffer(void *i_dataBuf, size_t i_dataSize,
            ACCESS_TYPE i_accessType, ...);

    /**
     *  @brief Destructor
     */
    virtual ~ErrlUserDetailsLogRegister() { };

private:
    // Disabled
    ErrlUserDetailsLogRegister(const ErrlUserDetailsLogRegister &);
    ErrlUserDetailsLogRegister & operator=(const ErrlUserDetailsLogRegister &);

    // internal functions:

    /**
     *
     * @brief setStateLogHUID - set state and log HUID.
     *
     * Worker function that will set the ErrlUserDetails instance variables
     *  and puts the HUID into the error log.
     */
    void setStateLogHUID();

    /**
     *
     * @brief writeRegisterData - write the register data to the log
     *
     *  @param[in] i_dataBuf - pointer to buffer with register data
     *  @param[in] i_dataSize - size of buffer pointed at by i_dataBuf
     *  @param[in] i_numAddressArgs - number of arguments in i_args va_list
     *  @param[in] i_accessType - type of register access
     *  @param[in] i_args - va_list of parameters of device access method
     *
     *  Worker function that will write the register data (access type and
     *   deviceOp() parameters, and contents of the register) to the error
     *   log.
     */
    void writeRegisterData(void *i_dataBuf, size_t i_dataSize,
            int32_t i_numAddressArgs,
            uint8_t i_accessType, va_list i_args);

    /**
     *
     * @brief readRegister - worker function to do and log the deviceOp()
     *
     *  @param[in] i_accessType - type of register access
     *  @param[in] i_args      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Performs the deviceOp() of the specified register type and address,
     *   storing that (type and address) as well as the result in this object.
     *   This is called by the addData() and constructor that do not have
     *   passed-in register data.
     */
    void readRegister(uint8_t i_accessType, va_list i_args);

    /**
     *
     * @brief copyRegisterData - worker function to log the register data
     *
     *  @param[in] i_dataBuf - pointer to area with register data
     *  @param[in] i_dataSize - size of data pointed at by i_dataBuf
     *  @param[in] i_accessType - type of register access
     *  @param[in] i_args      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Stores the specified register type and address, as well as the
     *   passed-in result in this object. The deviceOp() operation is NOT
     *   performed.
     *   This is called by the addDataBuffer() and constructor that have the
     *   passed-in register data.
     */
    void copyRegisterData(void *i_dataBuf, size_t i_dataSize,
            uint8_t i_accessType, va_list i_args);

    /**
     *
     * @brief __addData - do the register read and store the data
     *
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Performs the deviceOp() of the specified register type and address,
     *   storing that (type and address) as well as the result in this object.
     *
     *  This is the actual function that does the work, where the AccessType
     *   and AccessType_DriverOnly enum is used as a generic uint8_t. The
     *   public addData() template functions are aliased to this function.
     */
    void __addData(uint8_t i_accessType, ...);

    /**
     *
     * @brief addDataBuffer - store the buffer of register data
     *
     *  @param[in] i_dataBuf - pointer to buffer with register data
     *  @param[in] i_dataSize - size of data pointed at by i_dataBuf
     *  @param[in] i_accessType - type of register access
     *  @param[in] ...      - these are generated by the devicefw/userif.H
     *                      macros (ie, DEVICE_SCOM_ADDRESS).
     *
     *  Stores the specified register type and address, as well as the
     *   passed-in result in this object. The deviceOp() operation is NOT
     *   performed.
     *
     *  This is the actual function that does the work, where the AccessType
     *   and AccessType_DriverOnly enum is used as a generic uint8_t. The
     *   public addDataBuffer() template functions are aliased to this function.
     */
    void __addDataBuffer(void *i_dataBuf, size_t i_dataSize,
            uint8_t i_accessType, ...);

    // allow for multiple calls to addData by user
    TARGETING::Target * iv_pTarget;
    uint32_t iv_dataSize;
};

}

#else // (if PARSER defined)

namespace ERRORLOG
{

/**
 * @class ErrlUserDetailsLogRegister
 *
 * Parses LogRegister user detail in an error log
*/
class ErrlUserDetailsParserLogRegister : public ErrlUserDetailsParser
{
public:
    /**
     *  @brief Constructor
     */
    ErrlUserDetailsParserLogRegister() {}

    /**
     *  @brief Destructor
     */
    virtual ~ErrlUserDetailsParserLogRegister() {}

    /**
     *  @brief Parses register user detail data from an error log
     *
     *  @param  i_version Version of the data
     *  @param  i_parse   ErrlUsrParser object for outputting information
     *  @param  i_pBuffer Pointer to buffer containing detail data
     *  @param  i_buflen  Length of the buffer
     */
    virtual void parse(errlver_t i_version,
                       ErrlUsrParser & i_parser,
                       void * i_pBuffer,
                       const uint32_t i_buflen) const
    {
        // TODO fix when parser if fix
        // RTC 41707
    }

private:
    // Disabled
    ErrlUserDetailsParserLogRegister(const ErrlUserDetailsParserLogRegister &);
    ErrlUserDetailsParserLogRegister & operator=(
        const ErrlUserDetailsParserLogRegister &);
};

}

#endif

#endif

