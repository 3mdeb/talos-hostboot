/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/include/utility $                                         */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* COPYRIGHT International Business Machines Corp. 2011,2014              */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
#ifndef STL_UTILITY
#define STL_UTILITY


namespace std
{
    /**
     * Standard template pair
     * See the C++ spec
     */
    template <typename T1, typename T2>
        struct pair
        {
            typedef T1 first_type;
            typedef T2 second_type;

            T1 first;
            T2 second;
            pair() : first(T1()), second(T2()) {}
            pair(const T1 & x, const T2 & y) : first(x), second(y) {}

            template <typename U, typename V>
                pair (const pair<U,V> & p) : first(p.first), second(p.second) {}
        };


    /**
     * Wrapper for creating a pair
     * @param[in] x The first object
     * @param[in] y The second object
     * @return a newly-constructed pair<> object
     */
    template <typename T1, typename T2> __attribute__ ((always_inline))
        inline pair<T1,T2> make_pair (T1 x, T2 y)
        {
            return ( pair<T1,T2>(x,y) );
        }

    /**
     * pair eq comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x is strictly eq y
     */
    template <typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y)
        {
            return x.first == y.first && x.second == y.second;
        }

    /**
     * pair lt comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x < y
     */
    template<typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y)
        { 
            return (x.first < y.first) ||
                (!(y.first < x.first) && x.second < y.second);
        }

    /**
     * pair ne comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x != y
     */
    template<typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y)
        { 
            return !(x == y);
        }


    /**
     * pair gt comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x > y
     */
    template<typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y)
        {
            return y < x;
        }

    /**
     * pair le comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x <= y
     */
    template<typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y)
        {
            return !(y < x);
        }

    /**
     * pair >= comparison
     * @param[in] x The first object
     * @param[in] y The second object
     * @return true if x >= y
     */
    template<typename T1, typename T2> __attribute__ ((always_inline))
        inline bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y)
        {
            return !(x < y);
        }
};


#endif
/* vim: set filetype=cpp : */
